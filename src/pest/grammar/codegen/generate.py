"""Code generation for parser modules from grammar rules.

This module provides functions to generate Python source code for a parser
from a set of grammar rules. It emits parser functions, rule closures, and
trivia parsing logic for whitespace and comments.
"""

from pest.grammar.codegen.builder import Builder
from pest.grammar.rule import BuiltInRule
from pest.grammar.rule import Rule

# TODO: include data and version number
PRELUDE = """\
\"\"\"This file was generated by Python pest.

DO NOT EDIT THIS FILE BY HAND.
\"\"\"

from __future__ import annotations

from enum import StrEnum
from enum import auto
from typing import TYPE_CHECKING

import regex as re

from pest.grammar.codegen.state import ParseError
from pest.grammar.codegen.state import RuleFrame
from pest.grammar.codegen.state import State
from pest.pairs import Pair
from pest.pairs import Pairs

if TYPE_CHECKING:
    from collections.abc import Callable

# ruff: noqa: D103 N802 N816 N806 PLR0912 PLR0915
"""


def generate_module(rules: dict[str, Rule]) -> str:
    """Generate the complete Python source code for a parser module.

    Args:
        rules: A dictionary mapping rule names to Rule objects.

    Returns:
        The generated Python source code as a string, including all parser
        functions and trivia parsing logic.
    """
    generated_rules = "\n\n".join(
        generate_rule(name, rules)
        for name, rule in rules.items()
        if not isinstance(rule, BuiltInRule) or name == "EOI"
    )
    return "\n\n".join(
        [
            PRELUDE,
            generate_rule_enum(rules),
            generated_rules,
            generate_parse_trivia(rules),
            generate_rule_map(rules),
            generate_parse_entry_point(),
        ]
    )


def generate_rule(name: str, rules: dict[str, Rule]) -> str:
    """Generate the full parser function for a single grammar rule.

    Returns the source of a top-level assignment:
        parse_<rule> = _parse_<rule>()

    The generated closure includes:
      - rule-local constants (regexes, tables, etc.)
      - a RuleFrame instance for the rule
      - the inner parser function implementing the rule body

    Args:
        name: The name of the rule to generate.
        rules: A dictionary mapping rule names to Rule objects.

    Returns:
        The generated Python source code for the rule as a string.
    """
    rule = rules[name]
    # First, generate the inner function body
    inner_gen = Builder(rules=rules)
    rule.generate(inner_gen, "")

    # Now build the outer closure
    gen = Builder()
    func_name = f"parse_{rule.name}"

    gen.writeln(f"def _{func_name}() -> Callable[[State], Pairs]:")
    with gen.block():
        # Emit rule-scoped constants (regexes, tables, etc.)
        if inner_gen.rule_constants:
            for const_name, expr in inner_gen.rule_constants:
                gen.writeln(f"{const_name} = {expr}")
            gen.writeln("")  # spacer after constants

        # Each closure has its own RuleFrame
        gen.writeln(f"rule_frame = RuleFrame({rule.name!r}, {rule.modifier})")
        gen.writeln("")

        # Inline the inner function body generated earlier
        for line in inner_gen.lines:
            gen.writeln(line)
        gen.writeln("")

        # Expose the inner parser function
        gen.writeln("return inner")
        gen.writeln("")

    # At module scope, instantiate the closure
    gen.writeln(f"{func_name} = _{func_name}()")

    return gen.render()


def generate_parse_trivia(rules: dict[str, Rule]) -> str:
    """Generate a `parse_trivia` function that parses implicit rules.

    The generated function parses whitespace and comments according to the
    presence of `WHITESPACE`, `COMMENT`, or the optimized `SKIP` rule in
    the grammar. If none are present, the function is a no-op.

    Args:
        rules: A dictionary mapping rule names to Rule objects.

    Returns:
        The generated Python source code for trivia parsing as a string.
    """
    has_skip = "SKIP" in rules
    has_ws = "WHITESPACE" in rules
    has_comment = "COMMENT" in rules

    gen = Builder()
    gen.writeln("def parse_trivia(state: State, pairs: list[Pair]) -> None:")
    with gen.block():
        if not (has_skip or has_ws or has_comment):
            # Nothing to do
            gen.writeln("pass")
            return gen.render()

        gen.writeln("if state.atomic_depth > 0:")
        with gen.block():
            gen.writeln("return")

        if has_skip:
            gen.writeln("parse_SKIP(state, pairs)")
            return gen.render()

        gen.writeln("while True:")
        with gen.block():
            gen.writeln("state.checkpoint()")
            gen.writeln("matched = False")

            if has_ws:
                gen.writeln("try:")
                with gen.block():
                    gen.writeln("pairs.extend(parse_WHITESPACE(state))")
                    gen.writeln("state.ok()")
                    gen.writeln("matched = True")
                gen.writeln("except ParseError:")
                with gen.block():
                    gen.writeln("state.restore()")

            if has_comment:
                gen.writeln(
                    "if not state.rule_stack or state.rule_stack[-1].name != 'COMMENT':"
                )
                with gen.block():
                    gen.writeln("state.checkpoint()")
                    gen.writeln("try:")
                    with gen.block():
                        gen.writeln("pairs.extend(parse_COMMENT(state))")
                        gen.writeln("state.ok()")
                        gen.writeln("matched = True")
                    gen.writeln("except ParseError:")
                    with gen.block():
                        gen.writeln("state.restore()")

            gen.writeln("if not matched:")
            with gen.block():
                gen.writeln("break")

    return gen.render()


def generate_rule_enum(rules: dict[str, Rule]) -> str:
    """Generate a `StrEnum` class definition with one item per rule."""
    gen = Builder()
    gen.writeln("class Rule(StrEnum):")
    with gen.block():
        gen.writeln('"""Grammar rules."""')
        for name, rule in rules.items():
            if not isinstance(rule, BuiltInRule) or rule.name == "EOI":
                gen.writeln(f"{name.upper()} = auto()")

    return gen.render()


def generate_rule_map(rules: dict[str, Rule]) -> str:
    """Generate a dictionary mapping rule names to `parse_*` callables."""
    gen = Builder()
    gen.writeln("_RULE_MAP: dict[str, Callable[[State], Pairs]] = {")
    with gen.block():
        for name, rule in rules.items():
            if not isinstance(rule, BuiltInRule) or rule.name == "EOI":
                gen.writeln(f"{name!r}: parse_{name},")
    gen.writeln("}")
    return gen.render()


def generate_parse_entry_point() -> str:
    """Generate a `parse` function."""
    gen = Builder()
    gen.writeln(
        "def parse(start_rule: str, input_: str, *, start_pos: int = 0) -> Pairs:"
    )
    with gen.block():
        # TODO: improve doc comment
        gen.writeln('"""Parse `input_` starting from `rule`."""')
        gen.writeln("state = State(input_, start_pos)")
        # TODO: error handling!!
        gen.writeln("return _RULE_MAP[start_rule](state)")

    return gen.render()
