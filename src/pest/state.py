"""Parser generator state."""

from __future__ import annotations

from contextlib import contextmanager
from dataclasses import dataclass
from typing import TYPE_CHECKING
from typing import Iterator
from typing import Never
from typing import Sequence

from .exceptions import PestParsingError
from .grammar import Choice
from .grammar import NegativePredicate
from .grammar.expression import Success
from .grammar.rule import Rule
from .stack import Stack

if TYPE_CHECKING:
    from pest.grammar.expression import Expression

    from .parser import Parser


@dataclass
class Attempt:
    """A parse attempt at a specific position."""

    expr: Expression
    rule: Rule | None
    pos: int
    positive: bool  # True for positive, False for negative


class ParserState:
    """Holds parsing state.

    Includes input string, current parsing context, and a stack for stateful
    grammar operations.
    """

    __slots__ = (
        "parser",
        "input",
        "_atomic_depth",
        "stack",
        "cache",
        "rule_stack",
        "attempts",
        "furthest_failure",
        "_neg_pred_depth",
        "skip",
        "tag_stack",
    )

    def __init__(self, parser: Parser, input_: str, start_rule: Rule) -> None:
        self.parser = parser
        self.input = input_
        # TODO: a snapshotting int class?
        self._atomic_depth: list[int] = [0]  # A stack so we can restore state.
        self._neg_pred_depth: list[int] = [0]  # A stack so we can restore state.
        self.tag_stack: list[str | None] = []

        self.stack: Stack[str] = Stack()  # User stack

        # TODO: Simplify rule stack and attempts.
        self.rule_stack: list[Rule] = [start_rule]
        self.attempts: list[Attempt] = []
        self.furthest_failure: tuple[int, list[Attempt]] | None = None

        self.skip = parser.rules.get("SKIP")

    @property
    def atomic_depth(self) -> int:
        """The current atomic rule state."""
        return self._atomic_depth[-1]

    @atomic_depth.setter
    def atomic_depth(self, value: int) -> None:
        """Set the current atomic depth."""
        self._atomic_depth[-1] = value

    @property
    def neg_pred_depth(self) -> int:
        """The current negative predicate depth."""
        return self._neg_pred_depth[-1]

    @neg_pred_depth.setter
    def neg_pred_depth(self, value: int) -> None:
        """Set the current negative predicate depth."""
        self._neg_pred_depth[-1] = value

    def parse(
        self, expr: Expression, pos: int, tag: str | None = None
    ) -> Iterator[Success]:
        """Parse `expr` or return a cached parse result."""
        # TODO: context manager for tag stack?
        if tag:
            self.tag_stack.append(tag)

        # The tag to assign to this nodes generated by the current expression.
        node_tag: str | None = None

        # TODO: context manager for rule stack?
        if isinstance(expr, Rule):
            self.rule_stack.append(expr)
            # If there's a tag on the stack, tag the current rule with it.
            if self.tag_stack:
                node_tag = self.tag_stack.pop()

        self.attempts.append(
            Attempt(
                expr,
                self.rule_stack[-1] if self.rule_stack else None,
                pos,
                self.neg_pred_depth == 0,
            )
        )
        results = list(expr.parse(self, pos))

        if isinstance(expr, Rule):
            assert id(self.rule_stack.pop()) == id(expr)

        # Empty `results` indicates a failed parse.
        if results:
            if node_tag:
                for success in results:
                    if success.pair:
                        success.pair.tag = node_tag
            yield from results
        elif (
            self.furthest_failure is None
            or pos > self.furthest_failure[0]
            or (pos == self.furthest_failure[0] and self.neg_pred_depth == 0)
        ):
            # Save a copy of the stack at this failure point
            # XXX: If pos hasn't changed, we aren't tracking deepest rule
            self.furthest_failure = (pos, self.attempts.copy())

        if tag and self.tag_stack and not node_tag:
            # Don't pop the last tag if the current expression is a rule.
            self.tag_stack.pop()

        # Failed choices naturally get popped off the stack here. Instead of
        # going out of our way to do extra tracking for every choice, we defer
        # positive and negative attempt management until there is actually a
        # parse failure. See `raise_failure`.
        self.attempts.pop()

    def raise_failure(self) -> Never:
        """Return a PestParsingError populated with context info."""
        if not self.furthest_failure:
            raise PestParsingError("no parse attempts recorded", [], [], -1, "", (0, 0))

        pos, attempts = self.furthest_failure

        if not attempts:
            raise PestParsingError(
                f"error at {pos}: unknown failure", [], [], pos, "", (0, 0)
            )

        furthest = max(attempts, key=lambda a: a.pos)
        expr = furthest.expr
        pos = furthest.pos
        positive = furthest.positive

        line = self.input.count("\n", 0, pos) + 1
        col = pos - self.input.rfind("\n", 0, pos)
        found = self.input[pos : pos + 10] or "end of input"

        context = "expected" if positive else "unexpected"
        if furthest.rule:
            rule = f" in {furthest.rule.name}"
        else:
            rule = ""

        # TODO: something with stack trace
        # stack_trace = " > ".join(
        #     getattr(a.expr, "name", str(a.expr)) for a in attempts if a.positive
        # )

        msg = f"error at {line}:{col}{rule}: {context} {expr}, found {found!r}"

        if isinstance(expr, Choice):
            positives = [
                str(e) for e in expr.children() if not isinstance(e, NegativePredicate)
            ]
            negatives = [
                str(e.expression)
                for e in expr.children()
                if isinstance(e, NegativePredicate)
            ]
        else:
            positives = [str(expr)] if positive else []
            negatives = [str(expr)] if not positive else []

        # TODO: if furthest is Choice, positive and negative come from Choice.expression
        # TODO: don't forget optimized choices.

        raise PestParsingError(
            msg,
            positives,
            negatives,
            pos,
            "",  # TODO: current line
            (line, col),
        )

    def parse_implicit_rules(self, pos: int) -> Iterator[Success]:
        """Parse any implicit rules (`WHITESPACE` and `COMMENT`) starting at `pos`.

        Returns a list of ParseResult instances. Each result represents one
        successful application of an implicit rule. `node` will be None if
        the rule was silent.
        """
        if self.atomic_depth > 0:
            return

        if self.skip:
            # Optimized skip rule.
            yield from self.parse(self.skip, pos)
            return

        # Unoptimized whitespace and comment rules.
        whitespace_rule = self.parser.rules.get("WHITESPACE")
        comment_rule = self.parser.rules.get("COMMENT")

        if not whitespace_rule and not comment_rule:
            return

        while True:
            new_pos = pos
            matched = False

            if whitespace_rule:
                for result in self.parse(whitespace_rule, new_pos):
                    matched = True
                    new_pos = result.pos
                    if result.pair and self.atomic_depth == 0:
                        yield result

            # XXX: bit of a hack
            # We're relying on knowing the name of the current rule so we don't
            # recurse indefinitely when parsing COMMENT, which will often
            # include a sequence with implicit whitespace.
            if comment_rule and (
                not self.rule_stack or self.rule_stack[-1].name != "COMMENT"
            ):
                for result in self.parse(comment_rule, new_pos):
                    matched = True
                    new_pos = result.pos
                    if result.pair and self.atomic_depth == 0:
                        yield result

            if not matched:
                yield Success(None, new_pos)
                break

            pos = new_pos

    def push(self, value: str) -> None:
        """Push a value onto the stack."""
        self.stack.push(value)

    def drop(self) -> None:
        """Pops one item from the top of the stack."""
        self.stack.pop()

    def peek(self) -> str | None:
        """Peek at the top element of the stack."""
        return self.stack.peek()

    def peek_slice(
        self, start: int | None = None, end: int | None = None
    ) -> Sequence[str]:
        """Peek at a slice of the stack, similar to pest's `PEEK(start..end)`.

        Args:
            start: Start index of the slice (0 = bottom of stack).
            end:   End index of the slice (exclusive).

        Returns:
            A list of values from the stack slice. If no arguments are given,
            return the entire stack.

        Example:
            stack = [1, 2, 3, 4]
            peek_slice()         -> [1, 2, 3, 4]
            peek_slice(0, 2)     -> [1, 2]
            peek_slice(1, 3)     -> [2, 3]
            peek_slice(-2, None) -> [3, 4]
        """
        if start is None and end is None:
            return self.stack[:]
        return self.stack[slice(start, end)]

    def snapshot(self) -> None:
        """Mark the current state as a checkpoint."""
        self.stack.snapshot()
        self._atomic_depth.append(self.atomic_depth)
        self._neg_pred_depth.append(self.neg_pred_depth)

    def ok(self) -> None:
        """Discard the last checkpoint after a successful match."""
        self.stack.drop_snapshot()
        self.atomic_depth = self._atomic_depth.pop()
        self.neg_pred_depth = self._neg_pred_depth.pop()

    def restore(self) -> None:
        """Restore the state to the most recent checkpoint."""
        self.stack.restore()
        self._atomic_depth.pop()
        self._neg_pred_depth.pop()

    @contextmanager
    def suppress(self, *, negative: bool = False) -> Iterator[ParserState]:
        """A context manager that resets parser state on exit."""
        self.stack.snapshot()
        # TODO: rule stack too?
        atomic_depth = self.atomic_depth
        if negative:
            self.neg_pred_depth += 1

        yield self

        if negative:
            self.neg_pred_depth -= 1
        self.atomic_depth = atomic_depth
        self.stack.restore()
