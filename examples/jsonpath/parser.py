"""This file was generated by Python Pest version 0.1.0.

Usage:

    from module_name import Rule
    from module_name import parse

    parse_tree = parse(Rule.START_RULE, "input text")

Running this module directly exposes a basic command line interface for
debugging grammars.
    
    python -m module_name --help
"""

from __future__ import annotations

from enum import StrEnum
from typing import TYPE_CHECKING

import regex as re

from pest.exceptions import PestParsingError
from pest.pairs import Pair
from pest.pairs import Pairs
from pest.state import ParserState
from pest.state import RuleFrame

if TYPE_CHECKING:
    from collections.abc import Callable

# ruff: noqa: D103 N802 N816 N806 PLR0912 PLR0915 PLR2004


class Rule(StrEnum):
    """Grammar rules."""
    EOI = 'EOI'
    JSONPATH = 'jsonpath'
    JSONPATH_QUERY = 'jsonpath_query'
    SEGMENTS = 'segments'
    B = 'B'
    S = 'S'
    ROOT_IDENTIFIER = 'root_identifier'
    SELECTOR = 'selector'
    NAME_SELECTOR = 'name_selector'
    STRING_LITERAL = 'string_literal'
    DOUBLE_QUOTED = 'double_quoted'
    SINGLE_QUOTED = 'single_quoted'
    DOUBLE_QUOTED_CHAR = 'double_quoted_char'
    SINGLE_QUOTED_CHAR = 'single_quoted_char'
    ESC = 'ESC'
    UNESCAPED = 'unescaped'
    ESCAPABLE = 'escapable'
    HEXCHAR = 'hexchar'
    NON_SURROGATE = 'non_surrogate'
    HIGH_SURROGATE = 'high_surrogate'
    LOW_SURROGATE = 'low_surrogate'
    WILDCARD_SELECTOR = 'wildcard_selector'
    INDEX_SELECTOR = 'index_selector'
    INT = 'int'
    SLICE_SELECTOR = 'slice_selector'
    START = 'start'
    STOP = 'stop'
    STEP = 'step'
    FILTER_SELECTOR = 'filter_selector'
    LOGICAL_EXPR = 'logical_expr'
    LOGICAL_OR_EXPR = 'logical_or_expr'
    LOGICAL_AND_EXPR = 'logical_and_expr'
    BASIC_EXPR = 'basic_expr'
    PAREN_EXPR = 'paren_expr'
    LOGICAL_NOT_OP = 'logical_not_op'
    TEST_EXPR = 'test_expr'
    FILTER_QUERY = 'filter_query'
    ROOT_QUERY = 'root_query'
    REL_QUERY = 'rel_query'
    CURRENT_NODE_IDENTIFIER = 'current_node_identifier'
    COMPARISON_EXPR = 'comparison_expr'
    LITERAL = 'literal'
    COMPARABLE = 'comparable'
    COMPARISON_OP = 'comparison_op'
    SINGULAR_QUERY = 'singular_query'
    REL_SINGULAR_QUERY = 'rel_singular_query'
    ABS_SINGULAR_QUERY = 'abs_singular_query'
    SINGULAR_QUERY_SEGMENTS = 'singular_query_segments'
    NAME_SEGMENT = 'name_segment'
    INDEX_SEGMENT = 'index_segment'
    NUMBER = 'number'
    FRAC = 'frac'
    EXP = 'exp'
    TRUE_LITERAL = 'true_literal'
    FALSE_LITERAL = 'false_literal'
    NULL = 'null'
    FUNCTION_NAME = 'function_name'
    FUNCTION_NAME_FIRST = 'function_name_first'
    FUNCTION_NAME_CHAR = 'function_name_char'
    FUNCTION_EXPR = 'function_expr'
    FUNCTION_ARGUMENT = 'function_argument'
    SEGMENT = 'segment'
    CHILD_SEGMENT = 'child_segment'
    BRACKETED_SELECTION = 'bracketed_selection'
    MEMBER_NAME_SHORTHAND = 'member_name_shorthand'
    NAME_FIRST = 'name_first'
    NAME_CHAR = 'name_char'
    DESCENDANT_SEGMENT = 'descendant_segment'

def _parse_EOI() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('EOI', 0)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse EOI."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        if state.pos != len(state.input):
            matched = False
        else:
            matched = True
        state.rule_stack.pop()
        if state.tag_stack:
            tag3: str | None = state.tag_stack.pop()
        else:
            tag3 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag3,))
        return matched
    
    return inner
    
parse_EOI = _parse_EOI()

def _parse_jsonpath() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('jsonpath', 2)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse jsonpath."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=3>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            if state.pos == 0:
                matched3 = True
            else:
                matched3 = False
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Sequence n=2>
            all_ok6 = True
            if all_ok6:
                matched5 = False
                # <Identifier>
                matched5 = parse_root_identifier(state, children2)
                # </Identifier>
                if not matched5:
                    all_ok6 = False
                if all_ok6:
                    parse_trivia(state, children2)
            if all_ok6:
                matched5 = False
                # <Identifier>
                matched5 = parse_segments(state, children2)
                # </Identifier>
                if not matched5:
                    all_ok6 = False
            matched3 = all_ok6
            # </Sequence>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Identifier>
            matched3 = parse_EOI(state, children2)
            # </Identifier>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        # Silent rule 'jsonpath'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_jsonpath = _parse_jsonpath()

def _parse_jsonpath_query() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('jsonpath_query', 2)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse jsonpath_query."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=2>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            # <String>
            if state.input.startswith('$', state.pos):
                state.pos += 1
                matched3 = True
            else:
                matched3 = False
                state.fail('"$"')
            # </String>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Repeat>
            trivia_pos6 = state.pos
            children5: list[Pair] = []
            while True:
                state.checkpoint()
                # <Group>
                # <Sequence n=2>
                all_ok8 = True
                if all_ok8:
                    matched7 = False
                    # <Identifier>
                    matched7 = parse_S(state, children5)
                    # </Identifier>
                    if not matched7:
                        all_ok8 = False
                    if all_ok8:
                        parse_trivia(state, children5)
                if all_ok8:
                    matched7 = False
                    # <Identifier>
                    matched7 = parse_segment(state, children5)
                    # </Identifier>
                    if not matched7:
                        all_ok8 = False
                matched3 = all_ok8
                # </Sequence>
                # </Group>
                if matched3:
                    state.ok()
                    children2.extend(children5)
                    children5.clear()
                    trivia_pos6 = state.pos
                    parse_trivia(state, children5)
                else:
                    state.restore()
                    state.pos = trivia_pos6
                    matched3 = True
                    break
            # </Repeat>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        # Silent rule 'jsonpath_query'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_jsonpath_query = _parse_jsonpath_query()

def _parse_segments() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('segments', 2)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse segments."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Repeat>
        trivia_pos4 = state.pos
        children3: list[Pair] = []
        while True:
            state.checkpoint()
            # <Group>
            # <Sequence n=2>
            all_ok6 = True
            if all_ok6:
                matched5 = False
                # <Repeat>
                trivia_pos8 = state.pos
                children7: list[Pair] = []
                while True:
                    state.checkpoint()
                    # <Identifier>
                    matched5 = parse_B(state, children7)
                    # </Identifier>
                    if matched5:
                        state.ok()
                        children3.extend(children7)
                        children7.clear()
                        trivia_pos8 = state.pos
                        parse_trivia(state, children7)
                    else:
                        state.restore()
                        state.pos = trivia_pos8
                        matched5 = True
                        break
                # </Repeat>
                if not matched5:
                    all_ok6 = False
                if all_ok6:
                    parse_trivia(state, children3)
            if all_ok6:
                matched5 = False
                # <Choice>
                children9: list[Pair] = []
                matched5 = False
                if not matched5:
                    state.checkpoint()
                    # <Identifier>
                    matched5 = parse_child_segment(state, children9)
                    # </Identifier>
                    if matched5:
                        state.ok()
                        children3.extend(children9)
                    else:
                        state.restore()
                        children9.clear()
                if not matched5:
                    state.checkpoint()
                    # <Identifier>
                    matched5 = parse_descendant_segment(state, children9)
                    # </Identifier>
                    if matched5:
                        state.ok()
                        children3.extend(children9)
                    else:
                        state.restore()
                        children9.clear()
                # </Choice>
                if not matched5:
                    all_ok6 = False
            matched = all_ok6
            # </Sequence>
            # </Group>
            if matched:
                state.ok()
                children2.extend(children3)
                children3.clear()
                trivia_pos4 = state.pos
                parse_trivia(state, children3)
            else:
                state.restore()
                state.pos = trivia_pos4
                matched = True
                break
        # </Repeat>
        state.rule_stack.pop()
        # Silent rule 'segments'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_segments = _parse_segments()

def _parse_B() -> Callable[[ParserState, list[Pair]], bool]:
    RE3 = re.compile('[\\\t\\\n\\\r\\ ]', re.VERSION1)
    
    rule_frame = RuleFrame('B', 2)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse B."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <ChoiceRegex>
        if match := RE3.match(state.input, state.pos):
            state.pos = match.end()
            matched = True
        else:
            matched = False
        # </ChoiceRegex>
        state.rule_stack.pop()
        # Silent rule 'B'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_B = _parse_B()

def _parse_S() -> Callable[[ParserState, list[Pair]], bool]:
    RE5 = re.compile('[\\\t\\\n\\\r\\ ]', re.VERSION1)
    
    rule_frame = RuleFrame('S', 2)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse S."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Repeat>
        trivia_pos4 = state.pos
        children3: list[Pair] = []
        while True:
            state.checkpoint()
            # <ChoiceRegex>
            if match := RE5.match(state.input, state.pos):
                state.pos = match.end()
                matched = True
            else:
                matched = False
            # </ChoiceRegex>
            if matched:
                state.ok()
                children2.extend(children3)
                children3.clear()
                trivia_pos4 = state.pos
                parse_trivia(state, children3)
            else:
                state.restore()
                state.pos = trivia_pos4
                matched = True
                break
        # </Repeat>
        state.rule_stack.pop()
        # Silent rule 'S'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_S = _parse_S()

def _parse_root_identifier() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('root_identifier', 2)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse root_identifier."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <String>
        if state.input.startswith('$', state.pos):
            state.pos += 1
            matched = True
        else:
            matched = False
            state.fail('"$"')
        # </String>
        state.rule_stack.pop()
        # Silent rule 'root_identifier'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_root_identifier = _parse_root_identifier()

def _parse_selector() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('selector', 2)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse selector."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Choice>
        children3: list[Pair] = []
        matched = False
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_string_literal(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_wildcard_selector(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_slice_selector(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_index_selector(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_filter_selector(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        # </Choice>
        state.rule_stack.pop()
        # Silent rule 'selector'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_selector = _parse_selector()

def _parse_name_selector() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('name_selector', 2)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse name_selector."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Choice>
        children3: list[Pair] = []
        matched = False
        if not matched:
            state.checkpoint()
            # <Group>
            # <Sequence n=3>
            all_ok5 = True
            if all_ok5:
                matched4 = False
                # <String>
                if state.input.startswith('"', state.pos):
                    state.pos += 1
                    matched4 = True
                else:
                    matched4 = False
                    state.fail('"""')
                # </String>
                if not matched4:
                    all_ok5 = False
                if all_ok5:
                    parse_trivia(state, children3)
            if all_ok5:
                matched4 = False
                # <Identifier>
                matched4 = parse_double_quoted(state, children3)
                # </Identifier>
                if not matched4:
                    all_ok5 = False
                if all_ok5:
                    parse_trivia(state, children3)
            if all_ok5:
                matched4 = False
                # <String>
                if state.input.startswith('"', state.pos):
                    state.pos += 1
                    matched4 = True
                else:
                    matched4 = False
                    state.fail('"""')
                # </String>
                if not matched4:
                    all_ok5 = False
            matched = all_ok5
            # </Sequence>
            # </Group>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Group>
            # <Sequence n=3>
            all_ok7 = True
            if all_ok7:
                matched6 = False
                # <String>
                if state.input.startswith("'", state.pos):
                    state.pos += 1
                    matched6 = True
                else:
                    matched6 = False
                    state.fail('"\'"')
                # </String>
                if not matched6:
                    all_ok7 = False
                if all_ok7:
                    parse_trivia(state, children3)
            if all_ok7:
                matched6 = False
                # <Identifier>
                matched6 = parse_single_quoted(state, children3)
                # </Identifier>
                if not matched6:
                    all_ok7 = False
                if all_ok7:
                    parse_trivia(state, children3)
            if all_ok7:
                matched6 = False
                # <String>
                if state.input.startswith("'", state.pos):
                    state.pos += 1
                    matched6 = True
                else:
                    matched6 = False
                    state.fail('"\'"')
                # </String>
                if not matched6:
                    all_ok7 = False
            matched = all_ok7
            # </Sequence>
            # </Group>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        # </Choice>
        state.rule_stack.pop()
        # Silent rule 'name_selector'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_name_selector = _parse_name_selector()

def _parse_string_literal() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('string_literal', 2)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse string_literal."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Choice>
        children3: list[Pair] = []
        matched = False
        if not matched:
            state.checkpoint()
            # <Group>
            # <Sequence n=3>
            all_ok5 = True
            if all_ok5:
                matched4 = False
                # <String>
                if state.input.startswith('"', state.pos):
                    state.pos += 1
                    matched4 = True
                else:
                    matched4 = False
                    state.fail('"""')
                # </String>
                if not matched4:
                    all_ok5 = False
                if all_ok5:
                    parse_trivia(state, children3)
            if all_ok5:
                matched4 = False
                # <Identifier>
                matched4 = parse_double_quoted(state, children3)
                # </Identifier>
                if not matched4:
                    all_ok5 = False
                if all_ok5:
                    parse_trivia(state, children3)
            if all_ok5:
                matched4 = False
                # <String>
                if state.input.startswith('"', state.pos):
                    state.pos += 1
                    matched4 = True
                else:
                    matched4 = False
                    state.fail('"""')
                # </String>
                if not matched4:
                    all_ok5 = False
            matched = all_ok5
            # </Sequence>
            # </Group>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Group>
            # <Sequence n=3>
            all_ok7 = True
            if all_ok7:
                matched6 = False
                # <String>
                if state.input.startswith("'", state.pos):
                    state.pos += 1
                    matched6 = True
                else:
                    matched6 = False
                    state.fail('"\'"')
                # </String>
                if not matched6:
                    all_ok7 = False
                if all_ok7:
                    parse_trivia(state, children3)
            if all_ok7:
                matched6 = False
                # <Identifier>
                matched6 = parse_single_quoted(state, children3)
                # </Identifier>
                if not matched6:
                    all_ok7 = False
                if all_ok7:
                    parse_trivia(state, children3)
            if all_ok7:
                matched6 = False
                # <String>
                if state.input.startswith("'", state.pos):
                    state.pos += 1
                    matched6 = True
                else:
                    matched6 = False
                    state.fail('"\'"')
                # </String>
                if not matched6:
                    all_ok7 = False
            matched = all_ok7
            # </Sequence>
            # </Group>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        # </Choice>
        state.rule_stack.pop()
        # Silent rule 'string_literal'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_string_literal = _parse_string_literal()

def _parse_double_quoted() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('double_quoted', 0)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse double_quoted."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Repeat>
        trivia_pos4 = state.pos
        children3: list[Pair] = []
        while True:
            state.checkpoint()
            # <Choice>
            children5: list[Pair] = []
            matched = False
            if not matched:
                state.checkpoint()
                # <Identifier>
                matched = parse_unescaped(state, children5)
                # </Identifier>
                if matched:
                    state.ok()
                    children3.extend(children5)
                else:
                    state.restore()
                    children5.clear()
            if not matched:
                state.checkpoint()
                # <String>
                if state.input.startswith("'", state.pos):
                    state.pos += 1
                    matched = True
                else:
                    matched = False
                    state.fail('"\'"')
                # </String>
                if matched:
                    state.ok()
                    children3.extend(children5)
                else:
                    state.restore()
                    children5.clear()
            if not matched:
                state.checkpoint()
                # <Group>
                # <Sequence n=2>
                all_ok7 = True
                if all_ok7:
                    matched6 = False
                    # <Identifier>
                    matched6 = parse_ESC(state, children5)
                    # </Identifier>
                    if not matched6:
                        all_ok7 = False
                    if all_ok7:
                        parse_trivia(state, children5)
                if all_ok7:
                    matched6 = False
                    # <String>
                    if state.input.startswith('"', state.pos):
                        state.pos += 1
                        matched6 = True
                    else:
                        matched6 = False
                        state.fail('"""')
                    # </String>
                    if not matched6:
                        all_ok7 = False
                matched = all_ok7
                # </Sequence>
                # </Group>
                if matched:
                    state.ok()
                    children3.extend(children5)
                else:
                    state.restore()
                    children5.clear()
            if not matched:
                state.checkpoint()
                # <Group>
                # <Sequence n=2>
                all_ok9 = True
                if all_ok9:
                    matched8 = False
                    # <Identifier>
                    matched8 = parse_ESC(state, children5)
                    # </Identifier>
                    if not matched8:
                        all_ok9 = False
                    if all_ok9:
                        parse_trivia(state, children5)
                if all_ok9:
                    matched8 = False
                    # <Identifier>
                    matched8 = parse_escapable(state, children5)
                    # </Identifier>
                    if not matched8:
                        all_ok9 = False
                matched = all_ok9
                # </Sequence>
                # </Group>
                if matched:
                    state.ok()
                    children3.extend(children5)
                else:
                    state.restore()
                    children5.clear()
            # </Choice>
            if matched:
                state.ok()
                children2.extend(children3)
                children3.clear()
                trivia_pos4 = state.pos
                parse_trivia(state, children3)
            else:
                state.restore()
                state.pos = trivia_pos4
                matched = True
                break
        # </Repeat>
        state.rule_stack.pop()
        if state.tag_stack:
            tag10: str | None = state.tag_stack.pop()
        else:
            tag10 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag10,))
        return matched
    
    return inner
    
parse_double_quoted = _parse_double_quoted()

def _parse_single_quoted() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('single_quoted', 0)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse single_quoted."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Repeat>
        trivia_pos4 = state.pos
        children3: list[Pair] = []
        while True:
            state.checkpoint()
            # <Choice>
            children5: list[Pair] = []
            matched = False
            if not matched:
                state.checkpoint()
                # <Identifier>
                matched = parse_unescaped(state, children5)
                # </Identifier>
                if matched:
                    state.ok()
                    children3.extend(children5)
                else:
                    state.restore()
                    children5.clear()
            if not matched:
                state.checkpoint()
                # <String>
                if state.input.startswith('"', state.pos):
                    state.pos += 1
                    matched = True
                else:
                    matched = False
                    state.fail('"""')
                # </String>
                if matched:
                    state.ok()
                    children3.extend(children5)
                else:
                    state.restore()
                    children5.clear()
            if not matched:
                state.checkpoint()
                # <Group>
                # <Sequence n=2>
                all_ok7 = True
                if all_ok7:
                    matched6 = False
                    # <Identifier>
                    matched6 = parse_ESC(state, children5)
                    # </Identifier>
                    if not matched6:
                        all_ok7 = False
                    if all_ok7:
                        parse_trivia(state, children5)
                if all_ok7:
                    matched6 = False
                    # <String>
                    if state.input.startswith("'", state.pos):
                        state.pos += 1
                        matched6 = True
                    else:
                        matched6 = False
                        state.fail('"\'"')
                    # </String>
                    if not matched6:
                        all_ok7 = False
                matched = all_ok7
                # </Sequence>
                # </Group>
                if matched:
                    state.ok()
                    children3.extend(children5)
                else:
                    state.restore()
                    children5.clear()
            if not matched:
                state.checkpoint()
                # <Group>
                # <Sequence n=2>
                all_ok9 = True
                if all_ok9:
                    matched8 = False
                    # <Identifier>
                    matched8 = parse_ESC(state, children5)
                    # </Identifier>
                    if not matched8:
                        all_ok9 = False
                    if all_ok9:
                        parse_trivia(state, children5)
                if all_ok9:
                    matched8 = False
                    # <Identifier>
                    matched8 = parse_escapable(state, children5)
                    # </Identifier>
                    if not matched8:
                        all_ok9 = False
                matched = all_ok9
                # </Sequence>
                # </Group>
                if matched:
                    state.ok()
                    children3.extend(children5)
                else:
                    state.restore()
                    children5.clear()
            # </Choice>
            if matched:
                state.ok()
                children2.extend(children3)
                children3.clear()
                trivia_pos4 = state.pos
                parse_trivia(state, children3)
            else:
                state.restore()
                state.pos = trivia_pos4
                matched = True
                break
        # </Repeat>
        state.rule_stack.pop()
        if state.tag_stack:
            tag10: str | None = state.tag_stack.pop()
        else:
            tag10 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag10,))
        return matched
    
    return inner
    
parse_single_quoted = _parse_single_quoted()

def _parse_double_quoted_char() -> Callable[[ParserState, list[Pair]], bool]:
    RE4 = re.compile('[\\ -!\\#-\\&\\(-\\[\\]-\ud7ff\ue000-\U0010ffff]', re.VERSION1)
    
    rule_frame = RuleFrame('double_quoted_char', 2)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse double_quoted_char."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Choice>
        children3: list[Pair] = []
        matched = False
        if not matched:
            state.checkpoint()
            # <ChoiceRegex>
            if match := RE4.match(state.input, state.pos):
                state.pos = match.end()
                matched = True
            else:
                matched = False
            # </ChoiceRegex>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <String>
            if state.input.startswith("'", state.pos):
                state.pos += 1
                matched = True
            else:
                matched = False
                state.fail('"\'"')
            # </String>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Group>
            # <Sequence n=2>
            all_ok6 = True
            if all_ok6:
                matched5 = False
                # <String>
                if state.input.startswith('\\', state.pos):
                    state.pos += 1
                    matched5 = True
                else:
                    matched5 = False
                    state.fail('"\\"')
                # </String>
                if not matched5:
                    all_ok6 = False
                if all_ok6:
                    parse_trivia(state, children3)
            if all_ok6:
                matched5 = False
                # <String>
                if state.input.startswith('"', state.pos):
                    state.pos += 1
                    matched5 = True
                else:
                    matched5 = False
                    state.fail('"""')
                # </String>
                if not matched5:
                    all_ok6 = False
            matched = all_ok6
            # </Sequence>
            # </Group>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Group>
            # <Sequence n=2>
            all_ok8 = True
            if all_ok8:
                matched7 = False
                # <String>
                if state.input.startswith('\\', state.pos):
                    state.pos += 1
                    matched7 = True
                else:
                    matched7 = False
                    state.fail('"\\"')
                # </String>
                if not matched7:
                    all_ok8 = False
                if all_ok8:
                    parse_trivia(state, children3)
            if all_ok8:
                matched7 = False
                # <Choice>
                children9: list[Pair] = []
                matched7 = False
                if not matched7:
                    state.checkpoint()
                    # <String>
                    if state.input.startswith('b', state.pos):
                        state.pos += 1
                        matched7 = True
                    else:
                        matched7 = False
                        state.fail('"b"')
                    # </String>
                    if matched7:
                        state.ok()
                        children3.extend(children9)
                    else:
                        state.restore()
                        children9.clear()
                if not matched7:
                    state.checkpoint()
                    # <String>
                    if state.input.startswith('f', state.pos):
                        state.pos += 1
                        matched7 = True
                    else:
                        matched7 = False
                        state.fail('"f"')
                    # </String>
                    if matched7:
                        state.ok()
                        children3.extend(children9)
                    else:
                        state.restore()
                        children9.clear()
                if not matched7:
                    state.checkpoint()
                    # <String>
                    if state.input.startswith('n', state.pos):
                        state.pos += 1
                        matched7 = True
                    else:
                        matched7 = False
                        state.fail('"n"')
                    # </String>
                    if matched7:
                        state.ok()
                        children3.extend(children9)
                    else:
                        state.restore()
                        children9.clear()
                if not matched7:
                    state.checkpoint()
                    # <String>
                    if state.input.startswith('r', state.pos):
                        state.pos += 1
                        matched7 = True
                    else:
                        matched7 = False
                        state.fail('"r"')
                    # </String>
                    if matched7:
                        state.ok()
                        children3.extend(children9)
                    else:
                        state.restore()
                        children9.clear()
                if not matched7:
                    state.checkpoint()
                    # <String>
                    if state.input.startswith('t', state.pos):
                        state.pos += 1
                        matched7 = True
                    else:
                        matched7 = False
                        state.fail('"t"')
                    # </String>
                    if matched7:
                        state.ok()
                        children3.extend(children9)
                    else:
                        state.restore()
                        children9.clear()
                if not matched7:
                    state.checkpoint()
                    # <String>
                    if state.input.startswith('/', state.pos):
                        state.pos += 1
                        matched7 = True
                    else:
                        matched7 = False
                        state.fail('"/"')
                    # </String>
                    if matched7:
                        state.ok()
                        children3.extend(children9)
                    else:
                        state.restore()
                        children9.clear()
                if not matched7:
                    state.checkpoint()
                    # <String>
                    if state.input.startswith('\\', state.pos):
                        state.pos += 1
                        matched7 = True
                    else:
                        matched7 = False
                        state.fail('"\\"')
                    # </String>
                    if matched7:
                        state.ok()
                        children3.extend(children9)
                    else:
                        state.restore()
                        children9.clear()
                if not matched7:
                    state.checkpoint()
                    # <Group>
                    # <Sequence n=2>
                    all_ok11 = True
                    if all_ok11:
                        matched10 = False
                        # <String>
                        if state.input.startswith('u', state.pos):
                            state.pos += 1
                            matched10 = True
                        else:
                            matched10 = False
                            state.fail('"u"')
                        # </String>
                        if not matched10:
                            all_ok11 = False
                        if all_ok11:
                            parse_trivia(state, children9)
                    if all_ok11:
                        matched10 = False
                        # <Identifier>
                        matched10 = parse_hexchar(state, children9)
                        # </Identifier>
                        if not matched10:
                            all_ok11 = False
                    matched7 = all_ok11
                    # </Sequence>
                    # </Group>
                    if matched7:
                        state.ok()
                        children3.extend(children9)
                    else:
                        state.restore()
                        children9.clear()
                # </Choice>
                if not matched7:
                    all_ok8 = False
            matched = all_ok8
            # </Sequence>
            # </Group>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        # </Choice>
        state.rule_stack.pop()
        # Silent rule 'double_quoted_char'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_double_quoted_char = _parse_double_quoted_char()

def _parse_single_quoted_char() -> Callable[[ParserState, list[Pair]], bool]:
    RE4 = re.compile('[\\ -!\\#-\\&\\(-\\[\\]-\ud7ff\ue000-\U0010ffff]', re.VERSION1)
    
    rule_frame = RuleFrame('single_quoted_char', 2)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse single_quoted_char."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Choice>
        children3: list[Pair] = []
        matched = False
        if not matched:
            state.checkpoint()
            # <ChoiceRegex>
            if match := RE4.match(state.input, state.pos):
                state.pos = match.end()
                matched = True
            else:
                matched = False
            # </ChoiceRegex>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <String>
            if state.input.startswith('"', state.pos):
                state.pos += 1
                matched = True
            else:
                matched = False
                state.fail('"""')
            # </String>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Group>
            # <Sequence n=2>
            all_ok6 = True
            if all_ok6:
                matched5 = False
                # <String>
                if state.input.startswith('\\', state.pos):
                    state.pos += 1
                    matched5 = True
                else:
                    matched5 = False
                    state.fail('"\\"')
                # </String>
                if not matched5:
                    all_ok6 = False
                if all_ok6:
                    parse_trivia(state, children3)
            if all_ok6:
                matched5 = False
                # <String>
                if state.input.startswith("'", state.pos):
                    state.pos += 1
                    matched5 = True
                else:
                    matched5 = False
                    state.fail('"\'"')
                # </String>
                if not matched5:
                    all_ok6 = False
            matched = all_ok6
            # </Sequence>
            # </Group>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Group>
            # <Sequence n=2>
            all_ok8 = True
            if all_ok8:
                matched7 = False
                # <String>
                if state.input.startswith('\\', state.pos):
                    state.pos += 1
                    matched7 = True
                else:
                    matched7 = False
                    state.fail('"\\"')
                # </String>
                if not matched7:
                    all_ok8 = False
                if all_ok8:
                    parse_trivia(state, children3)
            if all_ok8:
                matched7 = False
                # <Choice>
                children9: list[Pair] = []
                matched7 = False
                if not matched7:
                    state.checkpoint()
                    # <String>
                    if state.input.startswith('b', state.pos):
                        state.pos += 1
                        matched7 = True
                    else:
                        matched7 = False
                        state.fail('"b"')
                    # </String>
                    if matched7:
                        state.ok()
                        children3.extend(children9)
                    else:
                        state.restore()
                        children9.clear()
                if not matched7:
                    state.checkpoint()
                    # <String>
                    if state.input.startswith('f', state.pos):
                        state.pos += 1
                        matched7 = True
                    else:
                        matched7 = False
                        state.fail('"f"')
                    # </String>
                    if matched7:
                        state.ok()
                        children3.extend(children9)
                    else:
                        state.restore()
                        children9.clear()
                if not matched7:
                    state.checkpoint()
                    # <String>
                    if state.input.startswith('n', state.pos):
                        state.pos += 1
                        matched7 = True
                    else:
                        matched7 = False
                        state.fail('"n"')
                    # </String>
                    if matched7:
                        state.ok()
                        children3.extend(children9)
                    else:
                        state.restore()
                        children9.clear()
                if not matched7:
                    state.checkpoint()
                    # <String>
                    if state.input.startswith('r', state.pos):
                        state.pos += 1
                        matched7 = True
                    else:
                        matched7 = False
                        state.fail('"r"')
                    # </String>
                    if matched7:
                        state.ok()
                        children3.extend(children9)
                    else:
                        state.restore()
                        children9.clear()
                if not matched7:
                    state.checkpoint()
                    # <String>
                    if state.input.startswith('t', state.pos):
                        state.pos += 1
                        matched7 = True
                    else:
                        matched7 = False
                        state.fail('"t"')
                    # </String>
                    if matched7:
                        state.ok()
                        children3.extend(children9)
                    else:
                        state.restore()
                        children9.clear()
                if not matched7:
                    state.checkpoint()
                    # <String>
                    if state.input.startswith('/', state.pos):
                        state.pos += 1
                        matched7 = True
                    else:
                        matched7 = False
                        state.fail('"/"')
                    # </String>
                    if matched7:
                        state.ok()
                        children3.extend(children9)
                    else:
                        state.restore()
                        children9.clear()
                if not matched7:
                    state.checkpoint()
                    # <String>
                    if state.input.startswith('\\', state.pos):
                        state.pos += 1
                        matched7 = True
                    else:
                        matched7 = False
                        state.fail('"\\"')
                    # </String>
                    if matched7:
                        state.ok()
                        children3.extend(children9)
                    else:
                        state.restore()
                        children9.clear()
                if not matched7:
                    state.checkpoint()
                    # <Group>
                    # <Sequence n=2>
                    all_ok11 = True
                    if all_ok11:
                        matched10 = False
                        # <String>
                        if state.input.startswith('u', state.pos):
                            state.pos += 1
                            matched10 = True
                        else:
                            matched10 = False
                            state.fail('"u"')
                        # </String>
                        if not matched10:
                            all_ok11 = False
                        if all_ok11:
                            parse_trivia(state, children9)
                    if all_ok11:
                        matched10 = False
                        # <Identifier>
                        matched10 = parse_hexchar(state, children9)
                        # </Identifier>
                        if not matched10:
                            all_ok11 = False
                    matched7 = all_ok11
                    # </Sequence>
                    # </Group>
                    if matched7:
                        state.ok()
                        children3.extend(children9)
                    else:
                        state.restore()
                        children9.clear()
                # </Choice>
                if not matched7:
                    all_ok8 = False
            matched = all_ok8
            # </Sequence>
            # </Group>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        # </Choice>
        state.rule_stack.pop()
        # Silent rule 'single_quoted_char'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_single_quoted_char = _parse_single_quoted_char()

def _parse_ESC() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('ESC', 2)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse ESC."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <String>
        if state.input.startswith('\\', state.pos):
            state.pos += 1
            matched = True
        else:
            matched = False
            state.fail('"\\"')
        # </String>
        state.rule_stack.pop()
        # Silent rule 'ESC'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_ESC = _parse_ESC()

def _parse_unescaped() -> Callable[[ParserState, list[Pair]], bool]:
    RE3 = re.compile('[\\ -!\\#-\\&\\(-\\[\\]-\ud7ff\ue000-\U0010ffff]', re.VERSION1)
    
    rule_frame = RuleFrame('unescaped', 2)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse unescaped."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <ChoiceRegex>
        if match := RE3.match(state.input, state.pos):
            state.pos = match.end()
            matched = True
        else:
            matched = False
        # </ChoiceRegex>
        state.rule_stack.pop()
        # Silent rule 'unescaped'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_unescaped = _parse_unescaped()

def _parse_escapable() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('escapable', 2)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse escapable."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Choice>
        children3: list[Pair] = []
        matched = False
        if not matched:
            state.checkpoint()
            # <String>
            if state.input.startswith('b', state.pos):
                state.pos += 1
                matched = True
            else:
                matched = False
                state.fail('"b"')
            # </String>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <String>
            if state.input.startswith('f', state.pos):
                state.pos += 1
                matched = True
            else:
                matched = False
                state.fail('"f"')
            # </String>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <String>
            if state.input.startswith('n', state.pos):
                state.pos += 1
                matched = True
            else:
                matched = False
                state.fail('"n"')
            # </String>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <String>
            if state.input.startswith('r', state.pos):
                state.pos += 1
                matched = True
            else:
                matched = False
                state.fail('"r"')
            # </String>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <String>
            if state.input.startswith('t', state.pos):
                state.pos += 1
                matched = True
            else:
                matched = False
                state.fail('"t"')
            # </String>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <String>
            if state.input.startswith('/', state.pos):
                state.pos += 1
                matched = True
            else:
                matched = False
                state.fail('"/"')
            # </String>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <String>
            if state.input.startswith('\\', state.pos):
                state.pos += 1
                matched = True
            else:
                matched = False
                state.fail('"\\"')
            # </String>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Group>
            # <Sequence n=2>
            all_ok5 = True
            if all_ok5:
                matched4 = False
                # <String>
                if state.input.startswith('u', state.pos):
                    state.pos += 1
                    matched4 = True
                else:
                    matched4 = False
                    state.fail('"u"')
                # </String>
                if not matched4:
                    all_ok5 = False
                if all_ok5:
                    parse_trivia(state, children3)
            if all_ok5:
                matched4 = False
                # <Choice>
                children6: list[Pair] = []
                matched4 = False
                if not matched4:
                    state.checkpoint()
                    # <Identifier>
                    matched4 = parse_non_surrogate(state, children6)
                    # </Identifier>
                    if matched4:
                        state.ok()
                        children3.extend(children6)
                    else:
                        state.restore()
                        children6.clear()
                if not matched4:
                    state.checkpoint()
                    # <Group>
                    # <Sequence n=3>
                    all_ok8 = True
                    if all_ok8:
                        matched7 = False
                        # <Identifier>
                        matched7 = parse_high_surrogate(state, children6)
                        # </Identifier>
                        if not matched7:
                            all_ok8 = False
                        if all_ok8:
                            parse_trivia(state, children6)
                    if all_ok8:
                        matched7 = False
                        # <String>
                        if state.input.startswith('\\u', state.pos):
                            state.pos += 2
                            matched7 = True
                        else:
                            matched7 = False
                            state.fail('"\\u"')
                        # </String>
                        if not matched7:
                            all_ok8 = False
                        if all_ok8:
                            parse_trivia(state, children6)
                    if all_ok8:
                        matched7 = False
                        # <Identifier>
                        matched7 = parse_low_surrogate(state, children6)
                        # </Identifier>
                        if not matched7:
                            all_ok8 = False
                    matched4 = all_ok8
                    # </Sequence>
                    # </Group>
                    if matched4:
                        state.ok()
                        children3.extend(children6)
                    else:
                        state.restore()
                        children6.clear()
                # </Choice>
                if not matched4:
                    all_ok5 = False
            matched = all_ok5
            # </Sequence>
            # </Group>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        # </Choice>
        state.rule_stack.pop()
        # Silent rule 'escapable'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_escapable = _parse_escapable()

def _parse_hexchar() -> Callable[[ParserState, list[Pair]], bool]:
    RE7 = re.compile('[ABCEFabcef0-9]', re.VERSION1)
    RE10 = re.compile('[0-9A-Fa-f]', re.VERSION1)
    RE11 = re.compile('[0-9A-Fa-f]', re.VERSION1)
    RE12 = re.compile('[0-9A-Fa-f]', re.VERSION1)
    RE15 = re.compile('D', re.I)
    RE16 = re.compile('[0-7]', re.I)
    RE19 = re.compile('[0-9A-Fa-f]', re.VERSION1)
    RE20 = re.compile('[0-9A-Fa-f]', re.VERSION1)
    RE25 = re.compile('D', re.I)
    RE26 = re.compile('[89ABab]', re.VERSION1)
    RE29 = re.compile('[0-9A-Fa-f]', re.VERSION1)
    RE30 = re.compile('[0-9A-Fa-f]', re.VERSION1)
    RE33 = re.compile('D', re.I)
    RE34 = re.compile('[CDEFcdef]', re.VERSION1)
    RE37 = re.compile('[0-9A-Fa-f]', re.VERSION1)
    RE38 = re.compile('[0-9A-Fa-f]', re.VERSION1)
    
    rule_frame = RuleFrame('hexchar', 2)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse hexchar."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Choice>
        children3: list[Pair] = []
        matched = False
        if not matched:
            state.checkpoint()
            # <Choice>
            children4: list[Pair] = []
            matched = False
            if not matched:
                state.checkpoint()
                # <Group>
                # <Sequence n=2>
                all_ok6 = True
                if all_ok6:
                    matched5 = False
                    # <Group>
                    # <ChoiceRegex>
                    if match := RE7.match(state.input, state.pos):
                        state.pos = match.end()
                        matched5 = True
                    else:
                        matched5 = False
                    # </ChoiceRegex>
                    # </Group>
                    if not matched5:
                        all_ok6 = False
                    if all_ok6:
                        parse_trivia(state, children4)
                if all_ok6:
                    matched5 = False
                    # <Sequence n=3>
                    all_ok9 = True
                    if all_ok9:
                        matched8 = False
                        # <ChoiceRegex>
                        if match := RE10.match(state.input, state.pos):
                            state.pos = match.end()
                            matched8 = True
                        else:
                            matched8 = False
                        # </ChoiceRegex>
                        if not matched8:
                            all_ok9 = False
                        if all_ok9:
                            parse_trivia(state, children4)
                    if all_ok9:
                        matched8 = False
                        # <ChoiceRegex>
                        if match := RE11.match(state.input, state.pos):
                            state.pos = match.end()
                            matched8 = True
                        else:
                            matched8 = False
                        # </ChoiceRegex>
                        if not matched8:
                            all_ok9 = False
                        if all_ok9:
                            parse_trivia(state, children4)
                    if all_ok9:
                        matched8 = False
                        # <ChoiceRegex>
                        if match := RE12.match(state.input, state.pos):
                            state.pos = match.end()
                            matched8 = True
                        else:
                            matched8 = False
                        # </ChoiceRegex>
                        if not matched8:
                            all_ok9 = False
                    matched5 = all_ok9
                    # </Sequence>
                    if not matched5:
                        all_ok6 = False
                matched = all_ok6
                # </Sequence>
                # </Group>
                if matched:
                    state.ok()
                    children3.extend(children4)
                else:
                    state.restore()
                    children4.clear()
            if not matched:
                state.checkpoint()
                # <Group>
                # <Sequence n=3>
                all_ok14 = True
                if all_ok14:
                    matched13 = False
                    # <CIString>
                    if match := RE15.match(state.input, state.pos):
                        state.pos = match.end()
                        matched13 = True
                    else:
                        matched13 = False
                        state.fail('^"D"')
                    # </CIString>
                    if not matched13:
                        all_ok14 = False
                    if all_ok14:
                        parse_trivia(state, children4)
                if all_ok14:
                    matched13 = False
                    # <Range>
                    if match := RE16.match(state.input, state.pos):
                        state.pos = match.end()
                        matched13 = True
                    else:
                        matched13 = False
                        state.fail("''0''..''7''")
                    # </Range>
                    if not matched13:
                        all_ok14 = False
                    if all_ok14:
                        parse_trivia(state, children4)
                if all_ok14:
                    matched13 = False
                    # <Sequence n=2>
                    all_ok18 = True
                    if all_ok18:
                        matched17 = False
                        # <ChoiceRegex>
                        if match := RE19.match(state.input, state.pos):
                            state.pos = match.end()
                            matched17 = True
                        else:
                            matched17 = False
                        # </ChoiceRegex>
                        if not matched17:
                            all_ok18 = False
                        if all_ok18:
                            parse_trivia(state, children4)
                    if all_ok18:
                        matched17 = False
                        # <ChoiceRegex>
                        if match := RE20.match(state.input, state.pos):
                            state.pos = match.end()
                            matched17 = True
                        else:
                            matched17 = False
                        # </ChoiceRegex>
                        if not matched17:
                            all_ok18 = False
                    matched13 = all_ok18
                    # </Sequence>
                    if not matched13:
                        all_ok14 = False
                matched = all_ok14
                # </Sequence>
                # </Group>
                if matched:
                    state.ok()
                    children3.extend(children4)
                else:
                    state.restore()
                    children4.clear()
            # </Choice>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Group>
            # <Sequence n=3>
            all_ok22 = True
            if all_ok22:
                matched21 = False
                # <Sequence n=3>
                all_ok24 = True
                if all_ok24:
                    matched23 = False
                    # <CIString>
                    if match := RE25.match(state.input, state.pos):
                        state.pos = match.end()
                        matched23 = True
                    else:
                        matched23 = False
                        state.fail('^"D"')
                    # </CIString>
                    if not matched23:
                        all_ok24 = False
                    if all_ok24:
                        parse_trivia(state, children3)
                if all_ok24:
                    matched23 = False
                    # <Group>
                    # <ChoiceRegex>
                    if match := RE26.match(state.input, state.pos):
                        state.pos = match.end()
                        matched23 = True
                    else:
                        matched23 = False
                    # </ChoiceRegex>
                    # </Group>
                    if not matched23:
                        all_ok24 = False
                    if all_ok24:
                        parse_trivia(state, children3)
                if all_ok24:
                    matched23 = False
                    # <Sequence n=2>
                    all_ok28 = True
                    if all_ok28:
                        matched27 = False
                        # <ChoiceRegex>
                        if match := RE29.match(state.input, state.pos):
                            state.pos = match.end()
                            matched27 = True
                        else:
                            matched27 = False
                        # </ChoiceRegex>
                        if not matched27:
                            all_ok28 = False
                        if all_ok28:
                            parse_trivia(state, children3)
                    if all_ok28:
                        matched27 = False
                        # <ChoiceRegex>
                        if match := RE30.match(state.input, state.pos):
                            state.pos = match.end()
                            matched27 = True
                        else:
                            matched27 = False
                        # </ChoiceRegex>
                        if not matched27:
                            all_ok28 = False
                    matched23 = all_ok28
                    # </Sequence>
                    if not matched23:
                        all_ok24 = False
                matched21 = all_ok24
                # </Sequence>
                if not matched21:
                    all_ok22 = False
                if all_ok22:
                    parse_trivia(state, children3)
            if all_ok22:
                matched21 = False
                # <String>
                if state.input.startswith('\\u', state.pos):
                    state.pos += 2
                    matched21 = True
                else:
                    matched21 = False
                    state.fail('"\\u"')
                # </String>
                if not matched21:
                    all_ok22 = False
                if all_ok22:
                    parse_trivia(state, children3)
            if all_ok22:
                matched21 = False
                # <Sequence n=3>
                all_ok32 = True
                if all_ok32:
                    matched31 = False
                    # <CIString>
                    if match := RE33.match(state.input, state.pos):
                        state.pos = match.end()
                        matched31 = True
                    else:
                        matched31 = False
                        state.fail('^"D"')
                    # </CIString>
                    if not matched31:
                        all_ok32 = False
                    if all_ok32:
                        parse_trivia(state, children3)
                if all_ok32:
                    matched31 = False
                    # <Group>
                    # <ChoiceRegex>
                    if match := RE34.match(state.input, state.pos):
                        state.pos = match.end()
                        matched31 = True
                    else:
                        matched31 = False
                    # </ChoiceRegex>
                    # </Group>
                    if not matched31:
                        all_ok32 = False
                    if all_ok32:
                        parse_trivia(state, children3)
                if all_ok32:
                    matched31 = False
                    # <Sequence n=2>
                    all_ok36 = True
                    if all_ok36:
                        matched35 = False
                        # <ChoiceRegex>
                        if match := RE37.match(state.input, state.pos):
                            state.pos = match.end()
                            matched35 = True
                        else:
                            matched35 = False
                        # </ChoiceRegex>
                        if not matched35:
                            all_ok36 = False
                        if all_ok36:
                            parse_trivia(state, children3)
                    if all_ok36:
                        matched35 = False
                        # <ChoiceRegex>
                        if match := RE38.match(state.input, state.pos):
                            state.pos = match.end()
                            matched35 = True
                        else:
                            matched35 = False
                        # </ChoiceRegex>
                        if not matched35:
                            all_ok36 = False
                    matched31 = all_ok36
                    # </Sequence>
                    if not matched31:
                        all_ok32 = False
                matched21 = all_ok32
                # </Sequence>
                if not matched21:
                    all_ok22 = False
            matched = all_ok22
            # </Sequence>
            # </Group>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        # </Choice>
        state.rule_stack.pop()
        # Silent rule 'hexchar'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_hexchar = _parse_hexchar()

def _parse_non_surrogate() -> Callable[[ParserState, list[Pair]], bool]:
    RE6 = re.compile('[ABCEFabcef0-9]', re.VERSION1)
    RE9 = re.compile('[0-9A-Fa-f]', re.VERSION1)
    RE10 = re.compile('[0-9A-Fa-f]', re.VERSION1)
    RE11 = re.compile('[0-9A-Fa-f]', re.VERSION1)
    RE14 = re.compile('D', re.I)
    RE15 = re.compile('[0-7]', re.I)
    RE18 = re.compile('[0-9A-Fa-f]', re.VERSION1)
    RE19 = re.compile('[0-9A-Fa-f]', re.VERSION1)
    
    rule_frame = RuleFrame('non_surrogate', 2)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse non_surrogate."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Choice>
        children3: list[Pair] = []
        matched = False
        if not matched:
            state.checkpoint()
            # <Group>
            # <Sequence n=2>
            all_ok5 = True
            if all_ok5:
                matched4 = False
                # <Group>
                # <ChoiceRegex>
                if match := RE6.match(state.input, state.pos):
                    state.pos = match.end()
                    matched4 = True
                else:
                    matched4 = False
                # </ChoiceRegex>
                # </Group>
                if not matched4:
                    all_ok5 = False
                if all_ok5:
                    parse_trivia(state, children3)
            if all_ok5:
                matched4 = False
                # <Sequence n=3>
                all_ok8 = True
                if all_ok8:
                    matched7 = False
                    # <ChoiceRegex>
                    if match := RE9.match(state.input, state.pos):
                        state.pos = match.end()
                        matched7 = True
                    else:
                        matched7 = False
                    # </ChoiceRegex>
                    if not matched7:
                        all_ok8 = False
                    if all_ok8:
                        parse_trivia(state, children3)
                if all_ok8:
                    matched7 = False
                    # <ChoiceRegex>
                    if match := RE10.match(state.input, state.pos):
                        state.pos = match.end()
                        matched7 = True
                    else:
                        matched7 = False
                    # </ChoiceRegex>
                    if not matched7:
                        all_ok8 = False
                    if all_ok8:
                        parse_trivia(state, children3)
                if all_ok8:
                    matched7 = False
                    # <ChoiceRegex>
                    if match := RE11.match(state.input, state.pos):
                        state.pos = match.end()
                        matched7 = True
                    else:
                        matched7 = False
                    # </ChoiceRegex>
                    if not matched7:
                        all_ok8 = False
                matched4 = all_ok8
                # </Sequence>
                if not matched4:
                    all_ok5 = False
            matched = all_ok5
            # </Sequence>
            # </Group>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Group>
            # <Sequence n=3>
            all_ok13 = True
            if all_ok13:
                matched12 = False
                # <CIString>
                if match := RE14.match(state.input, state.pos):
                    state.pos = match.end()
                    matched12 = True
                else:
                    matched12 = False
                    state.fail('^"D"')
                # </CIString>
                if not matched12:
                    all_ok13 = False
                if all_ok13:
                    parse_trivia(state, children3)
            if all_ok13:
                matched12 = False
                # <Range>
                if match := RE15.match(state.input, state.pos):
                    state.pos = match.end()
                    matched12 = True
                else:
                    matched12 = False
                    state.fail("''0''..''7''")
                # </Range>
                if not matched12:
                    all_ok13 = False
                if all_ok13:
                    parse_trivia(state, children3)
            if all_ok13:
                matched12 = False
                # <Sequence n=2>
                all_ok17 = True
                if all_ok17:
                    matched16 = False
                    # <ChoiceRegex>
                    if match := RE18.match(state.input, state.pos):
                        state.pos = match.end()
                        matched16 = True
                    else:
                        matched16 = False
                    # </ChoiceRegex>
                    if not matched16:
                        all_ok17 = False
                    if all_ok17:
                        parse_trivia(state, children3)
                if all_ok17:
                    matched16 = False
                    # <ChoiceRegex>
                    if match := RE19.match(state.input, state.pos):
                        state.pos = match.end()
                        matched16 = True
                    else:
                        matched16 = False
                    # </ChoiceRegex>
                    if not matched16:
                        all_ok17 = False
                matched12 = all_ok17
                # </Sequence>
                if not matched12:
                    all_ok13 = False
            matched = all_ok13
            # </Sequence>
            # </Group>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        # </Choice>
        state.rule_stack.pop()
        # Silent rule 'non_surrogate'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_non_surrogate = _parse_non_surrogate()

def _parse_high_surrogate() -> Callable[[ParserState, list[Pair]], bool]:
    RE5 = re.compile('D', re.I)
    RE6 = re.compile('[89ABab]', re.VERSION1)
    RE9 = re.compile('[0-9A-Fa-f]', re.VERSION1)
    RE10 = re.compile('[0-9A-Fa-f]', re.VERSION1)
    
    rule_frame = RuleFrame('high_surrogate', 2)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse high_surrogate."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=3>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            # <CIString>
            if match := RE5.match(state.input, state.pos):
                state.pos = match.end()
                matched3 = True
            else:
                matched3 = False
                state.fail('^"D"')
            # </CIString>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Group>
            # <ChoiceRegex>
            if match := RE6.match(state.input, state.pos):
                state.pos = match.end()
                matched3 = True
            else:
                matched3 = False
            # </ChoiceRegex>
            # </Group>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Sequence n=2>
            all_ok8 = True
            if all_ok8:
                matched7 = False
                # <ChoiceRegex>
                if match := RE9.match(state.input, state.pos):
                    state.pos = match.end()
                    matched7 = True
                else:
                    matched7 = False
                # </ChoiceRegex>
                if not matched7:
                    all_ok8 = False
                if all_ok8:
                    parse_trivia(state, children2)
            if all_ok8:
                matched7 = False
                # <ChoiceRegex>
                if match := RE10.match(state.input, state.pos):
                    state.pos = match.end()
                    matched7 = True
                else:
                    matched7 = False
                # </ChoiceRegex>
                if not matched7:
                    all_ok8 = False
            matched3 = all_ok8
            # </Sequence>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        # Silent rule 'high_surrogate'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_high_surrogate = _parse_high_surrogate()

def _parse_low_surrogate() -> Callable[[ParserState, list[Pair]], bool]:
    RE5 = re.compile('D', re.I)
    RE6 = re.compile('[CDEFcdef]', re.VERSION1)
    RE9 = re.compile('[0-9A-Fa-f]', re.VERSION1)
    RE10 = re.compile('[0-9A-Fa-f]', re.VERSION1)
    
    rule_frame = RuleFrame('low_surrogate', 2)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse low_surrogate."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=3>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            # <CIString>
            if match := RE5.match(state.input, state.pos):
                state.pos = match.end()
                matched3 = True
            else:
                matched3 = False
                state.fail('^"D"')
            # </CIString>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Group>
            # <ChoiceRegex>
            if match := RE6.match(state.input, state.pos):
                state.pos = match.end()
                matched3 = True
            else:
                matched3 = False
            # </ChoiceRegex>
            # </Group>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Sequence n=2>
            all_ok8 = True
            if all_ok8:
                matched7 = False
                # <ChoiceRegex>
                if match := RE9.match(state.input, state.pos):
                    state.pos = match.end()
                    matched7 = True
                else:
                    matched7 = False
                # </ChoiceRegex>
                if not matched7:
                    all_ok8 = False
                if all_ok8:
                    parse_trivia(state, children2)
            if all_ok8:
                matched7 = False
                # <ChoiceRegex>
                if match := RE10.match(state.input, state.pos):
                    state.pos = match.end()
                    matched7 = True
                else:
                    matched7 = False
                # </ChoiceRegex>
                if not matched7:
                    all_ok8 = False
            matched3 = all_ok8
            # </Sequence>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        # Silent rule 'low_surrogate'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_low_surrogate = _parse_low_surrogate()

def _parse_wildcard_selector() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('wildcard_selector', 0)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse wildcard_selector."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <String>
        if state.input.startswith('*', state.pos):
            state.pos += 1
            matched = True
        else:
            matched = False
            state.fail('"*"')
        # </String>
        state.rule_stack.pop()
        if state.tag_stack:
            tag3: str | None = state.tag_stack.pop()
        else:
            tag3 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag3,))
        return matched
    
    return inner
    
parse_wildcard_selector = _parse_wildcard_selector()

def _parse_index_selector() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('index_selector', 4)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse index_selector."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        with state.atomic_checkpoint():
            state.atomic_depth += 1
            # <Identifier>
            matched = parse_int(state, children2)
            # </Identifier>
        state.rule_stack.pop()
        if state.tag_stack:
            tag3: str | None = state.tag_stack.pop()
        else:
            tag3 = None
        # Atomic rule: 'index_selector'
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, [], tag3,))
        return matched
    
    return inner
    
parse_index_selector = _parse_index_selector()

def _parse_int() -> Callable[[ParserState, list[Pair]], bool]:
    RE7 = re.compile('[1-9]', re.I)
    RE10 = re.compile('[0-9]', re.I)
    
    rule_frame = RuleFrame('int', 0)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse int."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Choice>
        children3: list[Pair] = []
        matched = False
        if not matched:
            state.checkpoint()
            # <String>
            if state.input.startswith('0', state.pos):
                state.pos += 1
                matched = True
            else:
                matched = False
                state.fail('"0"')
            # </String>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Group>
            # <Sequence n=3>
            all_ok5 = True
            if all_ok5:
                matched4 = False
                # <Optional>
                children6: list[Pair] = []
                state.checkpoint()
                # <String>
                if state.input.startswith('-', state.pos):
                    state.pos += 1
                    matched4 = True
                else:
                    matched4 = False
                    state.fail('"-"')
                # </String>
                if matched4:
                    state.ok()
                    children3.extend(children6)
                else:
                    state.restore()
                    children6.clear()
                matched4 = True
                # </Optional>
                if not matched4:
                    all_ok5 = False
                if all_ok5:
                    parse_trivia(state, children3)
            if all_ok5:
                matched4 = False
                # <Range>
                if match := RE7.match(state.input, state.pos):
                    state.pos = match.end()
                    matched4 = True
                else:
                    matched4 = False
                    state.fail("''1''..''9''")
                # </Range>
                if not matched4:
                    all_ok5 = False
                if all_ok5:
                    parse_trivia(state, children3)
            if all_ok5:
                matched4 = False
                # <Repeat>
                trivia_pos9 = state.pos
                children8: list[Pair] = []
                while True:
                    state.checkpoint()
                    # <Range>
                    if match := RE10.match(state.input, state.pos):
                        state.pos = match.end()
                        matched4 = True
                    else:
                        matched4 = False
                        state.fail("''0''..''9''")
                    # </Range>
                    if matched4:
                        state.ok()
                        children3.extend(children8)
                        children8.clear()
                        trivia_pos9 = state.pos
                        parse_trivia(state, children8)
                    else:
                        state.restore()
                        state.pos = trivia_pos9
                        matched4 = True
                        break
                # </Repeat>
                if not matched4:
                    all_ok5 = False
            matched = all_ok5
            # </Sequence>
            # </Group>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        # </Choice>
        state.rule_stack.pop()
        if state.tag_stack:
            tag11: str | None = state.tag_stack.pop()
        else:
            tag11 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag11,))
        return matched
    
    return inner
    
parse_int = _parse_int()

def _parse_slice_selector() -> Callable[[ParserState, list[Pair]], bool]:
    RE10 = re.compile('[\\\t\\\n\\\r\\ ]', re.VERSION1)
    RE13 = re.compile('[\\\t\\\n\\\r\\ ]', re.VERSION1)
    RE19 = re.compile('[\\\t\\\n\\\r\\ ]', re.VERSION1)
    RE28 = re.compile('[\\\t\\\n\\\r\\ ]', re.VERSION1)
    
    rule_frame = RuleFrame('slice_selector', 0)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse slice_selector."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=5>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            # <Optional>
            children5: list[Pair] = []
            state.checkpoint()
            # <Group>
            # <Sequence n=2>
            all_ok7 = True
            if all_ok7:
                matched6 = False
                # <Identifier>
                matched6 = parse_start(state, children5)
                # </Identifier>
                if not matched6:
                    all_ok7 = False
                if all_ok7:
                    parse_trivia(state, children5)
            if all_ok7:
                matched6 = False
                # <Repeat>
                trivia_pos9 = state.pos
                children8: list[Pair] = []
                while True:
                    state.checkpoint()
                    # <ChoiceRegex>
                    if match := RE10.match(state.input, state.pos):
                        state.pos = match.end()
                        matched6 = True
                    else:
                        matched6 = False
                    # </ChoiceRegex>
                    if matched6:
                        state.ok()
                        children5.extend(children8)
                        children8.clear()
                        trivia_pos9 = state.pos
                        parse_trivia(state, children8)
                    else:
                        state.restore()
                        state.pos = trivia_pos9
                        matched6 = True
                        break
                # </Repeat>
                if not matched6:
                    all_ok7 = False
            matched3 = all_ok7
            # </Sequence>
            # </Group>
            if matched3:
                state.ok()
                children2.extend(children5)
            else:
                state.restore()
                children5.clear()
            matched3 = True
            # </Optional>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <String>
            if state.input.startswith(':', state.pos):
                state.pos += 1
                matched3 = True
            else:
                matched3 = False
                state.fail('":"')
            # </String>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Repeat>
            trivia_pos12 = state.pos
            children11: list[Pair] = []
            while True:
                state.checkpoint()
                # <ChoiceRegex>
                if match := RE13.match(state.input, state.pos):
                    state.pos = match.end()
                    matched3 = True
                else:
                    matched3 = False
                # </ChoiceRegex>
                if matched3:
                    state.ok()
                    children2.extend(children11)
                    children11.clear()
                    trivia_pos12 = state.pos
                    parse_trivia(state, children11)
                else:
                    state.restore()
                    state.pos = trivia_pos12
                    matched3 = True
                    break
            # </Repeat>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Optional>
            children14: list[Pair] = []
            state.checkpoint()
            # <Group>
            # <Sequence n=2>
            all_ok16 = True
            if all_ok16:
                matched15 = False
                # <Identifier>
                matched15 = parse_stop(state, children14)
                # </Identifier>
                if not matched15:
                    all_ok16 = False
                if all_ok16:
                    parse_trivia(state, children14)
            if all_ok16:
                matched15 = False
                # <Repeat>
                trivia_pos18 = state.pos
                children17: list[Pair] = []
                while True:
                    state.checkpoint()
                    # <ChoiceRegex>
                    if match := RE19.match(state.input, state.pos):
                        state.pos = match.end()
                        matched15 = True
                    else:
                        matched15 = False
                    # </ChoiceRegex>
                    if matched15:
                        state.ok()
                        children14.extend(children17)
                        children17.clear()
                        trivia_pos18 = state.pos
                        parse_trivia(state, children17)
                    else:
                        state.restore()
                        state.pos = trivia_pos18
                        matched15 = True
                        break
                # </Repeat>
                if not matched15:
                    all_ok16 = False
            matched3 = all_ok16
            # </Sequence>
            # </Group>
            if matched3:
                state.ok()
                children2.extend(children14)
            else:
                state.restore()
                children14.clear()
            matched3 = True
            # </Optional>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Optional>
            children20: list[Pair] = []
            state.checkpoint()
            # <Group>
            # <Sequence n=2>
            all_ok22 = True
            if all_ok22:
                matched21 = False
                # <String>
                if state.input.startswith(':', state.pos):
                    state.pos += 1
                    matched21 = True
                else:
                    matched21 = False
                    state.fail('":"')
                # </String>
                if not matched21:
                    all_ok22 = False
                if all_ok22:
                    parse_trivia(state, children20)
            if all_ok22:
                matched21 = False
                # <Optional>
                children23: list[Pair] = []
                state.checkpoint()
                # <Group>
                # <Sequence n=2>
                all_ok25 = True
                if all_ok25:
                    matched24 = False
                    # <Repeat>
                    trivia_pos27 = state.pos
                    children26: list[Pair] = []
                    while True:
                        state.checkpoint()
                        # <ChoiceRegex>
                        if match := RE28.match(state.input, state.pos):
                            state.pos = match.end()
                            matched24 = True
                        else:
                            matched24 = False
                        # </ChoiceRegex>
                        if matched24:
                            state.ok()
                            children23.extend(children26)
                            children26.clear()
                            trivia_pos27 = state.pos
                            parse_trivia(state, children26)
                        else:
                            state.restore()
                            state.pos = trivia_pos27
                            matched24 = True
                            break
                    # </Repeat>
                    if not matched24:
                        all_ok25 = False
                    if all_ok25:
                        parse_trivia(state, children23)
                if all_ok25:
                    matched24 = False
                    # <Identifier>
                    matched24 = parse_step(state, children23)
                    # </Identifier>
                    if not matched24:
                        all_ok25 = False
                matched21 = all_ok25
                # </Sequence>
                # </Group>
                if matched21:
                    state.ok()
                    children20.extend(children23)
                else:
                    state.restore()
                    children23.clear()
                matched21 = True
                # </Optional>
                if not matched21:
                    all_ok22 = False
            matched3 = all_ok22
            # </Sequence>
            # </Group>
            if matched3:
                state.ok()
                children2.extend(children20)
            else:
                state.restore()
                children20.clear()
            matched3 = True
            # </Optional>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag29: str | None = state.tag_stack.pop()
        else:
            tag29 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag29,))
        return matched
    
    return inner
    
parse_slice_selector = _parse_slice_selector()

def _parse_start() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('start', 4)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse start."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        with state.atomic_checkpoint():
            state.atomic_depth += 1
            # <Identifier>
            matched = parse_int(state, children2)
            # </Identifier>
        state.rule_stack.pop()
        if state.tag_stack:
            tag3: str | None = state.tag_stack.pop()
        else:
            tag3 = None
        # Atomic rule: 'start'
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, [], tag3,))
        return matched
    
    return inner
    
parse_start = _parse_start()

def _parse_stop() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('stop', 4)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse stop."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        with state.atomic_checkpoint():
            state.atomic_depth += 1
            # <Identifier>
            matched = parse_int(state, children2)
            # </Identifier>
        state.rule_stack.pop()
        if state.tag_stack:
            tag3: str | None = state.tag_stack.pop()
        else:
            tag3 = None
        # Atomic rule: 'stop'
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, [], tag3,))
        return matched
    
    return inner
    
parse_stop = _parse_stop()

def _parse_step() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('step', 4)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse step."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        with state.atomic_checkpoint():
            state.atomic_depth += 1
            # <Identifier>
            matched = parse_int(state, children2)
            # </Identifier>
        state.rule_stack.pop()
        if state.tag_stack:
            tag3: str | None = state.tag_stack.pop()
        else:
            tag3 = None
        # Atomic rule: 'step'
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, [], tag3,))
        return matched
    
    return inner
    
parse_step = _parse_step()

def _parse_filter_selector() -> Callable[[ParserState, list[Pair]], bool]:
    RE7 = re.compile('[\\\t\\\n\\\r\\ ]', re.VERSION1)
    
    rule_frame = RuleFrame('filter_selector', 0)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse filter_selector."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=3>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            # <String>
            if state.input.startswith('?', state.pos):
                state.pos += 1
                matched3 = True
            else:
                matched3 = False
                state.fail('"?"')
            # </String>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Repeat>
            trivia_pos6 = state.pos
            children5: list[Pair] = []
            while True:
                state.checkpoint()
                # <ChoiceRegex>
                if match := RE7.match(state.input, state.pos):
                    state.pos = match.end()
                    matched3 = True
                else:
                    matched3 = False
                # </ChoiceRegex>
                if matched3:
                    state.ok()
                    children2.extend(children5)
                    children5.clear()
                    trivia_pos6 = state.pos
                    parse_trivia(state, children5)
                else:
                    state.restore()
                    state.pos = trivia_pos6
                    matched3 = True
                    break
            # </Repeat>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Identifier>
            matched3 = parse_logical_or_expr(state, children2)
            # </Identifier>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag8: str | None = state.tag_stack.pop()
        else:
            tag8 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag8,))
        return matched
    
    return inner
    
parse_filter_selector = _parse_filter_selector()

def _parse_logical_expr() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('logical_expr', 2)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse logical_expr."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Identifier>
        matched = parse_logical_or_expr(state, children2)
        # </Identifier>
        state.rule_stack.pop()
        # Silent rule 'logical_expr'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_logical_expr = _parse_logical_expr()

def _parse_logical_or_expr() -> Callable[[ParserState, list[Pair]], bool]:
    RE11 = re.compile('[\\\t\\\n\\\r\\ ]', re.VERSION1)
    RE14 = re.compile('[\\\t\\\n\\\r\\ ]', re.VERSION1)
    
    rule_frame = RuleFrame('logical_or_expr', 0)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse logical_or_expr."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=2>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            # <Identifier>
            matched3 = parse_logical_and_expr(state, children2)
            # </Identifier>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Repeat>
            trivia_pos6 = state.pos
            children5: list[Pair] = []
            while True:
                state.checkpoint()
                # <Group>
                # <Sequence n=4>
                all_ok8 = True
                if all_ok8:
                    matched7 = False
                    # <Repeat>
                    trivia_pos10 = state.pos
                    children9: list[Pair] = []
                    while True:
                        state.checkpoint()
                        # <ChoiceRegex>
                        if match := RE11.match(state.input, state.pos):
                            state.pos = match.end()
                            matched7 = True
                        else:
                            matched7 = False
                        # </ChoiceRegex>
                        if matched7:
                            state.ok()
                            children5.extend(children9)
                            children9.clear()
                            trivia_pos10 = state.pos
                            parse_trivia(state, children9)
                        else:
                            state.restore()
                            state.pos = trivia_pos10
                            matched7 = True
                            break
                    # </Repeat>
                    if not matched7:
                        all_ok8 = False
                    if all_ok8:
                        parse_trivia(state, children5)
                if all_ok8:
                    matched7 = False
                    # <String>
                    if state.input.startswith('||', state.pos):
                        state.pos += 2
                        matched7 = True
                    else:
                        matched7 = False
                        state.fail('"||"')
                    # </String>
                    if not matched7:
                        all_ok8 = False
                    if all_ok8:
                        parse_trivia(state, children5)
                if all_ok8:
                    matched7 = False
                    # <Repeat>
                    trivia_pos13 = state.pos
                    children12: list[Pair] = []
                    while True:
                        state.checkpoint()
                        # <ChoiceRegex>
                        if match := RE14.match(state.input, state.pos):
                            state.pos = match.end()
                            matched7 = True
                        else:
                            matched7 = False
                        # </ChoiceRegex>
                        if matched7:
                            state.ok()
                            children5.extend(children12)
                            children12.clear()
                            trivia_pos13 = state.pos
                            parse_trivia(state, children12)
                        else:
                            state.restore()
                            state.pos = trivia_pos13
                            matched7 = True
                            break
                    # </Repeat>
                    if not matched7:
                        all_ok8 = False
                    if all_ok8:
                        parse_trivia(state, children5)
                if all_ok8:
                    matched7 = False
                    # <Identifier>
                    matched7 = parse_logical_and_expr(state, children5)
                    # </Identifier>
                    if not matched7:
                        all_ok8 = False
                matched3 = all_ok8
                # </Sequence>
                # </Group>
                if matched3:
                    state.ok()
                    children2.extend(children5)
                    children5.clear()
                    trivia_pos6 = state.pos
                    parse_trivia(state, children5)
                else:
                    state.restore()
                    state.pos = trivia_pos6
                    matched3 = True
                    break
            # </Repeat>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag15: str | None = state.tag_stack.pop()
        else:
            tag15 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag15,))
        return matched
    
    return inner
    
parse_logical_or_expr = _parse_logical_or_expr()

def _parse_logical_and_expr() -> Callable[[ParserState, list[Pair]], bool]:
    RE12 = re.compile('[\\\t\\\n\\\r\\ ]', re.VERSION1)
    RE15 = re.compile('[\\\t\\\n\\\r\\ ]', re.VERSION1)
    
    rule_frame = RuleFrame('logical_and_expr', 0)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse logical_and_expr."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=2>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            # <Choice>
            children5: list[Pair] = []
            matched3 = False
            if not matched3:
                state.checkpoint()
                # <Identifier>
                matched3 = parse_paren_expr(state, children5)
                # </Identifier>
                if matched3:
                    state.ok()
                    children2.extend(children5)
                else:
                    state.restore()
                    children5.clear()
            if not matched3:
                state.checkpoint()
                # <Identifier>
                matched3 = parse_comparison_expr(state, children5)
                # </Identifier>
                if matched3:
                    state.ok()
                    children2.extend(children5)
                else:
                    state.restore()
                    children5.clear()
            if not matched3:
                state.checkpoint()
                # <Identifier>
                matched3 = parse_test_expr(state, children5)
                # </Identifier>
                if matched3:
                    state.ok()
                    children2.extend(children5)
                else:
                    state.restore()
                    children5.clear()
            # </Choice>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Repeat>
            trivia_pos7 = state.pos
            children6: list[Pair] = []
            while True:
                state.checkpoint()
                # <Group>
                # <Sequence n=4>
                all_ok9 = True
                if all_ok9:
                    matched8 = False
                    # <Repeat>
                    trivia_pos11 = state.pos
                    children10: list[Pair] = []
                    while True:
                        state.checkpoint()
                        # <ChoiceRegex>
                        if match := RE12.match(state.input, state.pos):
                            state.pos = match.end()
                            matched8 = True
                        else:
                            matched8 = False
                        # </ChoiceRegex>
                        if matched8:
                            state.ok()
                            children6.extend(children10)
                            children10.clear()
                            trivia_pos11 = state.pos
                            parse_trivia(state, children10)
                        else:
                            state.restore()
                            state.pos = trivia_pos11
                            matched8 = True
                            break
                    # </Repeat>
                    if not matched8:
                        all_ok9 = False
                    if all_ok9:
                        parse_trivia(state, children6)
                if all_ok9:
                    matched8 = False
                    # <String>
                    if state.input.startswith('&&', state.pos):
                        state.pos += 2
                        matched8 = True
                    else:
                        matched8 = False
                        state.fail('"&&"')
                    # </String>
                    if not matched8:
                        all_ok9 = False
                    if all_ok9:
                        parse_trivia(state, children6)
                if all_ok9:
                    matched8 = False
                    # <Repeat>
                    trivia_pos14 = state.pos
                    children13: list[Pair] = []
                    while True:
                        state.checkpoint()
                        # <ChoiceRegex>
                        if match := RE15.match(state.input, state.pos):
                            state.pos = match.end()
                            matched8 = True
                        else:
                            matched8 = False
                        # </ChoiceRegex>
                        if matched8:
                            state.ok()
                            children6.extend(children13)
                            children13.clear()
                            trivia_pos14 = state.pos
                            parse_trivia(state, children13)
                        else:
                            state.restore()
                            state.pos = trivia_pos14
                            matched8 = True
                            break
                    # </Repeat>
                    if not matched8:
                        all_ok9 = False
                    if all_ok9:
                        parse_trivia(state, children6)
                if all_ok9:
                    matched8 = False
                    # <Choice>
                    children16: list[Pair] = []
                    matched8 = False
                    if not matched8:
                        state.checkpoint()
                        # <Identifier>
                        matched8 = parse_paren_expr(state, children16)
                        # </Identifier>
                        if matched8:
                            state.ok()
                            children6.extend(children16)
                        else:
                            state.restore()
                            children16.clear()
                    if not matched8:
                        state.checkpoint()
                        # <Identifier>
                        matched8 = parse_comparison_expr(state, children16)
                        # </Identifier>
                        if matched8:
                            state.ok()
                            children6.extend(children16)
                        else:
                            state.restore()
                            children16.clear()
                    if not matched8:
                        state.checkpoint()
                        # <Identifier>
                        matched8 = parse_test_expr(state, children16)
                        # </Identifier>
                        if matched8:
                            state.ok()
                            children6.extend(children16)
                        else:
                            state.restore()
                            children16.clear()
                    # </Choice>
                    if not matched8:
                        all_ok9 = False
                matched3 = all_ok9
                # </Sequence>
                # </Group>
                if matched3:
                    state.ok()
                    children2.extend(children6)
                    children6.clear()
                    trivia_pos7 = state.pos
                    parse_trivia(state, children6)
                else:
                    state.restore()
                    state.pos = trivia_pos7
                    matched3 = True
                    break
            # </Repeat>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag17: str | None = state.tag_stack.pop()
        else:
            tag17 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag17,))
        return matched
    
    return inner
    
parse_logical_and_expr = _parse_logical_and_expr()

def _parse_basic_expr() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('basic_expr', 2)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse basic_expr."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Choice>
        children3: list[Pair] = []
        matched = False
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_paren_expr(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_comparison_expr(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_test_expr(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        # </Choice>
        state.rule_stack.pop()
        # Silent rule 'basic_expr'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_basic_expr = _parse_basic_expr()

def _parse_paren_expr() -> Callable[[ParserState, list[Pair]], bool]:
    RE10 = re.compile('[\\\t\\\n\\\r\\ ]', re.VERSION1)
    RE13 = re.compile('[\\\t\\\n\\\r\\ ]', re.VERSION1)
    RE16 = re.compile('[\\\t\\\n\\\r\\ ]', re.VERSION1)
    
    rule_frame = RuleFrame('paren_expr', 0)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse paren_expr."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=6>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            # <Optional>
            children5: list[Pair] = []
            state.checkpoint()
            # <Group>
            # <Sequence n=2>
            all_ok7 = True
            if all_ok7:
                matched6 = False
                # <Identifier>
                matched6 = parse_logical_not_op(state, children5)
                # </Identifier>
                if not matched6:
                    all_ok7 = False
                if all_ok7:
                    parse_trivia(state, children5)
            if all_ok7:
                matched6 = False
                # <Repeat>
                trivia_pos9 = state.pos
                children8: list[Pair] = []
                while True:
                    state.checkpoint()
                    # <ChoiceRegex>
                    if match := RE10.match(state.input, state.pos):
                        state.pos = match.end()
                        matched6 = True
                    else:
                        matched6 = False
                    # </ChoiceRegex>
                    if matched6:
                        state.ok()
                        children5.extend(children8)
                        children8.clear()
                        trivia_pos9 = state.pos
                        parse_trivia(state, children8)
                    else:
                        state.restore()
                        state.pos = trivia_pos9
                        matched6 = True
                        break
                # </Repeat>
                if not matched6:
                    all_ok7 = False
            matched3 = all_ok7
            # </Sequence>
            # </Group>
            if matched3:
                state.ok()
                children2.extend(children5)
            else:
                state.restore()
                children5.clear()
            matched3 = True
            # </Optional>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <String>
            if state.input.startswith('(', state.pos):
                state.pos += 1
                matched3 = True
            else:
                matched3 = False
                state.fail('"("')
            # </String>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Repeat>
            trivia_pos12 = state.pos
            children11: list[Pair] = []
            while True:
                state.checkpoint()
                # <ChoiceRegex>
                if match := RE13.match(state.input, state.pos):
                    state.pos = match.end()
                    matched3 = True
                else:
                    matched3 = False
                # </ChoiceRegex>
                if matched3:
                    state.ok()
                    children2.extend(children11)
                    children11.clear()
                    trivia_pos12 = state.pos
                    parse_trivia(state, children11)
                else:
                    state.restore()
                    state.pos = trivia_pos12
                    matched3 = True
                    break
            # </Repeat>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Identifier>
            matched3 = parse_logical_or_expr(state, children2)
            # </Identifier>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Repeat>
            trivia_pos15 = state.pos
            children14: list[Pair] = []
            while True:
                state.checkpoint()
                # <ChoiceRegex>
                if match := RE16.match(state.input, state.pos):
                    state.pos = match.end()
                    matched3 = True
                else:
                    matched3 = False
                # </ChoiceRegex>
                if matched3:
                    state.ok()
                    children2.extend(children14)
                    children14.clear()
                    trivia_pos15 = state.pos
                    parse_trivia(state, children14)
                else:
                    state.restore()
                    state.pos = trivia_pos15
                    matched3 = True
                    break
            # </Repeat>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <String>
            if state.input.startswith(')', state.pos):
                state.pos += 1
                matched3 = True
            else:
                matched3 = False
                state.fail('")"')
            # </String>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag17: str | None = state.tag_stack.pop()
        else:
            tag17 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag17,))
        return matched
    
    return inner
    
parse_paren_expr = _parse_paren_expr()

def _parse_logical_not_op() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('logical_not_op', 0)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse logical_not_op."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <String>
        if state.input.startswith('!', state.pos):
            state.pos += 1
            matched = True
        else:
            matched = False
            state.fail('"!"')
        # </String>
        state.rule_stack.pop()
        if state.tag_stack:
            tag3: str | None = state.tag_stack.pop()
        else:
            tag3 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag3,))
        return matched
    
    return inner
    
parse_logical_not_op = _parse_logical_not_op()

def _parse_test_expr() -> Callable[[ParserState, list[Pair]], bool]:
    RE10 = re.compile('[\\\t\\\n\\\r\\ ]', re.VERSION1)
    
    rule_frame = RuleFrame('test_expr', 0)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse test_expr."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=2>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            # <Optional>
            children5: list[Pair] = []
            state.checkpoint()
            # <Group>
            # <Sequence n=2>
            all_ok7 = True
            if all_ok7:
                matched6 = False
                # <Identifier>
                matched6 = parse_logical_not_op(state, children5)
                # </Identifier>
                if not matched6:
                    all_ok7 = False
                if all_ok7:
                    parse_trivia(state, children5)
            if all_ok7:
                matched6 = False
                # <Repeat>
                trivia_pos9 = state.pos
                children8: list[Pair] = []
                while True:
                    state.checkpoint()
                    # <ChoiceRegex>
                    if match := RE10.match(state.input, state.pos):
                        state.pos = match.end()
                        matched6 = True
                    else:
                        matched6 = False
                    # </ChoiceRegex>
                    if matched6:
                        state.ok()
                        children5.extend(children8)
                        children8.clear()
                        trivia_pos9 = state.pos
                        parse_trivia(state, children8)
                    else:
                        state.restore()
                        state.pos = trivia_pos9
                        matched6 = True
                        break
                # </Repeat>
                if not matched6:
                    all_ok7 = False
            matched3 = all_ok7
            # </Sequence>
            # </Group>
            if matched3:
                state.ok()
                children2.extend(children5)
            else:
                state.restore()
                children5.clear()
            matched3 = True
            # </Optional>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Group>
            # <Choice>
            children11: list[Pair] = []
            matched3 = False
            if not matched3:
                state.checkpoint()
                # <Choice>
                children12: list[Pair] = []
                matched3 = False
                if not matched3:
                    state.checkpoint()
                    # <Identifier>
                    matched3 = parse_rel_query(state, children12)
                    # </Identifier>
                    if matched3:
                        state.ok()
                        children11.extend(children12)
                    else:
                        state.restore()
                        children12.clear()
                if not matched3:
                    state.checkpoint()
                    # <Identifier>
                    matched3 = parse_root_query(state, children12)
                    # </Identifier>
                    if matched3:
                        state.ok()
                        children11.extend(children12)
                    else:
                        state.restore()
                        children12.clear()
                # </Choice>
                if matched3:
                    state.ok()
                    children2.extend(children11)
                else:
                    state.restore()
                    children11.clear()
            if not matched3:
                state.checkpoint()
                # <Identifier>
                matched3 = parse_function_expr(state, children11)
                # </Identifier>
                if matched3:
                    state.ok()
                    children2.extend(children11)
                else:
                    state.restore()
                    children11.clear()
            # </Choice>
            # </Group>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag13: str | None = state.tag_stack.pop()
        else:
            tag13 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag13,))
        return matched
    
    return inner
    
parse_test_expr = _parse_test_expr()

def _parse_filter_query() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('filter_query', 2)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse filter_query."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Choice>
        children3: list[Pair] = []
        matched = False
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_rel_query(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_root_query(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        # </Choice>
        state.rule_stack.pop()
        # Silent rule 'filter_query'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_filter_query = _parse_filter_query()

def _parse_root_query() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('root_query', 0)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse root_query."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=2>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            # <String>
            if state.input.startswith('$', state.pos):
                state.pos += 1
                matched3 = True
            else:
                matched3 = False
                state.fail('"$"')
            # </String>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Repeat>
            trivia_pos6 = state.pos
            children5: list[Pair] = []
            while True:
                state.checkpoint()
                # <Group>
                # <Sequence n=2>
                all_ok8 = True
                if all_ok8:
                    matched7 = False
                    # <Identifier>
                    matched7 = parse_S(state, children5)
                    # </Identifier>
                    if not matched7:
                        all_ok8 = False
                    if all_ok8:
                        parse_trivia(state, children5)
                if all_ok8:
                    matched7 = False
                    # <Identifier>
                    matched7 = parse_segment(state, children5)
                    # </Identifier>
                    if not matched7:
                        all_ok8 = False
                matched3 = all_ok8
                # </Sequence>
                # </Group>
                if matched3:
                    state.ok()
                    children2.extend(children5)
                    children5.clear()
                    trivia_pos6 = state.pos
                    parse_trivia(state, children5)
                else:
                    state.restore()
                    state.pos = trivia_pos6
                    matched3 = True
                    break
            # </Repeat>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag9: str | None = state.tag_stack.pop()
        else:
            tag9 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag9,))
        return matched
    
    return inner
    
parse_root_query = _parse_root_query()

def _parse_rel_query() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('rel_query', 0)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse rel_query."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=2>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            # <String>
            if state.input.startswith('@', state.pos):
                state.pos += 1
                matched3 = True
            else:
                matched3 = False
                state.fail('"@"')
            # </String>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Repeat>
            trivia_pos6 = state.pos
            children5: list[Pair] = []
            while True:
                state.checkpoint()
                # <Group>
                # <Sequence n=2>
                all_ok8 = True
                if all_ok8:
                    matched7 = False
                    # <Repeat>
                    trivia_pos10 = state.pos
                    children9: list[Pair] = []
                    while True:
                        state.checkpoint()
                        # <Identifier>
                        matched7 = parse_B(state, children9)
                        # </Identifier>
                        if matched7:
                            state.ok()
                            children5.extend(children9)
                            children9.clear()
                            trivia_pos10 = state.pos
                            parse_trivia(state, children9)
                        else:
                            state.restore()
                            state.pos = trivia_pos10
                            matched7 = True
                            break
                    # </Repeat>
                    if not matched7:
                        all_ok8 = False
                    if all_ok8:
                        parse_trivia(state, children5)
                if all_ok8:
                    matched7 = False
                    # <Choice>
                    children11: list[Pair] = []
                    matched7 = False
                    if not matched7:
                        state.checkpoint()
                        # <Identifier>
                        matched7 = parse_child_segment(state, children11)
                        # </Identifier>
                        if matched7:
                            state.ok()
                            children5.extend(children11)
                        else:
                            state.restore()
                            children11.clear()
                    if not matched7:
                        state.checkpoint()
                        # <Identifier>
                        matched7 = parse_descendant_segment(state, children11)
                        # </Identifier>
                        if matched7:
                            state.ok()
                            children5.extend(children11)
                        else:
                            state.restore()
                            children11.clear()
                    # </Choice>
                    if not matched7:
                        all_ok8 = False
                matched3 = all_ok8
                # </Sequence>
                # </Group>
                if matched3:
                    state.ok()
                    children2.extend(children5)
                    children5.clear()
                    trivia_pos6 = state.pos
                    parse_trivia(state, children5)
                else:
                    state.restore()
                    state.pos = trivia_pos6
                    matched3 = True
                    break
            # </Repeat>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag12: str | None = state.tag_stack.pop()
        else:
            tag12 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag12,))
        return matched
    
    return inner
    
parse_rel_query = _parse_rel_query()

def _parse_current_node_identifier() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('current_node_identifier', 2)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse current_node_identifier."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <String>
        if state.input.startswith('@', state.pos):
            state.pos += 1
            matched = True
        else:
            matched = False
            state.fail('"@"')
        # </String>
        state.rule_stack.pop()
        # Silent rule 'current_node_identifier'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_current_node_identifier = _parse_current_node_identifier()

def _parse_comparison_expr() -> Callable[[ParserState, list[Pair]], bool]:
    RE8 = re.compile('[\\\t\\\n\\\r\\ ]', re.VERSION1)
    RE11 = re.compile('[\\\t\\\n\\\r\\ ]', re.VERSION1)
    
    rule_frame = RuleFrame('comparison_expr', 0)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse comparison_expr."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=5>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            # <Choice>
            children5: list[Pair] = []
            matched3 = False
            if not matched3:
                state.checkpoint()
                # <Identifier>
                matched3 = parse_literal(state, children5)
                # </Identifier>
                if matched3:
                    state.ok()
                    children2.extend(children5)
                else:
                    state.restore()
                    children5.clear()
            if not matched3:
                state.checkpoint()
                # <Identifier>
                matched3 = parse_singular_query(state, children5)
                # </Identifier>
                if matched3:
                    state.ok()
                    children2.extend(children5)
                else:
                    state.restore()
                    children5.clear()
            if not matched3:
                state.checkpoint()
                # <Identifier>
                matched3 = parse_function_expr(state, children5)
                # </Identifier>
                if matched3:
                    state.ok()
                    children2.extend(children5)
                else:
                    state.restore()
                    children5.clear()
            # </Choice>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Repeat>
            trivia_pos7 = state.pos
            children6: list[Pair] = []
            while True:
                state.checkpoint()
                # <ChoiceRegex>
                if match := RE8.match(state.input, state.pos):
                    state.pos = match.end()
                    matched3 = True
                else:
                    matched3 = False
                # </ChoiceRegex>
                if matched3:
                    state.ok()
                    children2.extend(children6)
                    children6.clear()
                    trivia_pos7 = state.pos
                    parse_trivia(state, children6)
                else:
                    state.restore()
                    state.pos = trivia_pos7
                    matched3 = True
                    break
            # </Repeat>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Identifier>
            matched3 = parse_comparison_op(state, children2)
            # </Identifier>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Repeat>
            trivia_pos10 = state.pos
            children9: list[Pair] = []
            while True:
                state.checkpoint()
                # <ChoiceRegex>
                if match := RE11.match(state.input, state.pos):
                    state.pos = match.end()
                    matched3 = True
                else:
                    matched3 = False
                # </ChoiceRegex>
                if matched3:
                    state.ok()
                    children2.extend(children9)
                    children9.clear()
                    trivia_pos10 = state.pos
                    parse_trivia(state, children9)
                else:
                    state.restore()
                    state.pos = trivia_pos10
                    matched3 = True
                    break
            # </Repeat>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Choice>
            children12: list[Pair] = []
            matched3 = False
            if not matched3:
                state.checkpoint()
                # <Identifier>
                matched3 = parse_literal(state, children12)
                # </Identifier>
                if matched3:
                    state.ok()
                    children2.extend(children12)
                else:
                    state.restore()
                    children12.clear()
            if not matched3:
                state.checkpoint()
                # <Identifier>
                matched3 = parse_singular_query(state, children12)
                # </Identifier>
                if matched3:
                    state.ok()
                    children2.extend(children12)
                else:
                    state.restore()
                    children12.clear()
            if not matched3:
                state.checkpoint()
                # <Identifier>
                matched3 = parse_function_expr(state, children12)
                # </Identifier>
                if matched3:
                    state.ok()
                    children2.extend(children12)
                else:
                    state.restore()
                    children12.clear()
            # </Choice>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag13: str | None = state.tag_stack.pop()
        else:
            tag13 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag13,))
        return matched
    
    return inner
    
parse_comparison_expr = _parse_comparison_expr()

def _parse_literal() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('literal', 2)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse literal."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Choice>
        children3: list[Pair] = []
        matched = False
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_number(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Choice>
            children4: list[Pair] = []
            matched = False
            if not matched:
                state.checkpoint()
                # <Group>
                # <Sequence n=3>
                all_ok6 = True
                if all_ok6:
                    matched5 = False
                    # <String>
                    if state.input.startswith('"', state.pos):
                        state.pos += 1
                        matched5 = True
                    else:
                        matched5 = False
                        state.fail('"""')
                    # </String>
                    if not matched5:
                        all_ok6 = False
                    if all_ok6:
                        parse_trivia(state, children4)
                if all_ok6:
                    matched5 = False
                    # <Identifier>
                    matched5 = parse_double_quoted(state, children4)
                    # </Identifier>
                    if not matched5:
                        all_ok6 = False
                    if all_ok6:
                        parse_trivia(state, children4)
                if all_ok6:
                    matched5 = False
                    # <String>
                    if state.input.startswith('"', state.pos):
                        state.pos += 1
                        matched5 = True
                    else:
                        matched5 = False
                        state.fail('"""')
                    # </String>
                    if not matched5:
                        all_ok6 = False
                matched = all_ok6
                # </Sequence>
                # </Group>
                if matched:
                    state.ok()
                    children3.extend(children4)
                else:
                    state.restore()
                    children4.clear()
            if not matched:
                state.checkpoint()
                # <Group>
                # <Sequence n=3>
                all_ok8 = True
                if all_ok8:
                    matched7 = False
                    # <String>
                    if state.input.startswith("'", state.pos):
                        state.pos += 1
                        matched7 = True
                    else:
                        matched7 = False
                        state.fail('"\'"')
                    # </String>
                    if not matched7:
                        all_ok8 = False
                    if all_ok8:
                        parse_trivia(state, children4)
                if all_ok8:
                    matched7 = False
                    # <Identifier>
                    matched7 = parse_single_quoted(state, children4)
                    # </Identifier>
                    if not matched7:
                        all_ok8 = False
                    if all_ok8:
                        parse_trivia(state, children4)
                if all_ok8:
                    matched7 = False
                    # <String>
                    if state.input.startswith("'", state.pos):
                        state.pos += 1
                        matched7 = True
                    else:
                        matched7 = False
                        state.fail('"\'"')
                    # </String>
                    if not matched7:
                        all_ok8 = False
                matched = all_ok8
                # </Sequence>
                # </Group>
                if matched:
                    state.ok()
                    children3.extend(children4)
                else:
                    state.restore()
                    children4.clear()
            # </Choice>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_true_literal(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_false_literal(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_null(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        # </Choice>
        state.rule_stack.pop()
        # Silent rule 'literal'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_literal = _parse_literal()

def _parse_comparable() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('comparable', 2)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse comparable."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Choice>
        children3: list[Pair] = []
        matched = False
        if not matched:
            state.checkpoint()
            # <Choice>
            children4: list[Pair] = []
            matched = False
            if not matched:
                state.checkpoint()
                # <Identifier>
                matched = parse_number(state, children4)
                # </Identifier>
                if matched:
                    state.ok()
                    children3.extend(children4)
                else:
                    state.restore()
                    children4.clear()
            if not matched:
                state.checkpoint()
                # <Choice>
                children5: list[Pair] = []
                matched = False
                if not matched:
                    state.checkpoint()
                    # <Group>
                    # <Sequence n=3>
                    all_ok7 = True
                    if all_ok7:
                        matched6 = False
                        # <String>
                        if state.input.startswith('"', state.pos):
                            state.pos += 1
                            matched6 = True
                        else:
                            matched6 = False
                            state.fail('"""')
                        # </String>
                        if not matched6:
                            all_ok7 = False
                        if all_ok7:
                            parse_trivia(state, children5)
                    if all_ok7:
                        matched6 = False
                        # <Identifier>
                        matched6 = parse_double_quoted(state, children5)
                        # </Identifier>
                        if not matched6:
                            all_ok7 = False
                        if all_ok7:
                            parse_trivia(state, children5)
                    if all_ok7:
                        matched6 = False
                        # <String>
                        if state.input.startswith('"', state.pos):
                            state.pos += 1
                            matched6 = True
                        else:
                            matched6 = False
                            state.fail('"""')
                        # </String>
                        if not matched6:
                            all_ok7 = False
                    matched = all_ok7
                    # </Sequence>
                    # </Group>
                    if matched:
                        state.ok()
                        children4.extend(children5)
                    else:
                        state.restore()
                        children5.clear()
                if not matched:
                    state.checkpoint()
                    # <Group>
                    # <Sequence n=3>
                    all_ok9 = True
                    if all_ok9:
                        matched8 = False
                        # <String>
                        if state.input.startswith("'", state.pos):
                            state.pos += 1
                            matched8 = True
                        else:
                            matched8 = False
                            state.fail('"\'"')
                        # </String>
                        if not matched8:
                            all_ok9 = False
                        if all_ok9:
                            parse_trivia(state, children5)
                    if all_ok9:
                        matched8 = False
                        # <Identifier>
                        matched8 = parse_single_quoted(state, children5)
                        # </Identifier>
                        if not matched8:
                            all_ok9 = False
                        if all_ok9:
                            parse_trivia(state, children5)
                    if all_ok9:
                        matched8 = False
                        # <String>
                        if state.input.startswith("'", state.pos):
                            state.pos += 1
                            matched8 = True
                        else:
                            matched8 = False
                            state.fail('"\'"')
                        # </String>
                        if not matched8:
                            all_ok9 = False
                    matched = all_ok9
                    # </Sequence>
                    # </Group>
                    if matched:
                        state.ok()
                        children4.extend(children5)
                    else:
                        state.restore()
                        children5.clear()
                # </Choice>
                if matched:
                    state.ok()
                    children3.extend(children4)
                else:
                    state.restore()
                    children4.clear()
            if not matched:
                state.checkpoint()
                # <Identifier>
                matched = parse_true_literal(state, children4)
                # </Identifier>
                if matched:
                    state.ok()
                    children3.extend(children4)
                else:
                    state.restore()
                    children4.clear()
            if not matched:
                state.checkpoint()
                # <Identifier>
                matched = parse_false_literal(state, children4)
                # </Identifier>
                if matched:
                    state.ok()
                    children3.extend(children4)
                else:
                    state.restore()
                    children4.clear()
            if not matched:
                state.checkpoint()
                # <Identifier>
                matched = parse_null(state, children4)
                # </Identifier>
                if matched:
                    state.ok()
                    children3.extend(children4)
                else:
                    state.restore()
                    children4.clear()
            # </Choice>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Choice>
            children10: list[Pair] = []
            matched = False
            if not matched:
                state.checkpoint()
                # <Identifier>
                matched = parse_rel_singular_query(state, children10)
                # </Identifier>
                if matched:
                    state.ok()
                    children3.extend(children10)
                else:
                    state.restore()
                    children10.clear()
            if not matched:
                state.checkpoint()
                # <Identifier>
                matched = parse_abs_singular_query(state, children10)
                # </Identifier>
                if matched:
                    state.ok()
                    children3.extend(children10)
                else:
                    state.restore()
                    children10.clear()
            # </Choice>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_function_expr(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        # </Choice>
        state.rule_stack.pop()
        # Silent rule 'comparable'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_comparable = _parse_comparable()

def _parse_comparison_op() -> Callable[[ParserState, list[Pair]], bool]:
    RE3 = re.compile('(?:==|!=|<=|>=|[<>])', re.VERSION1)
    
    rule_frame = RuleFrame('comparison_op', 0)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse comparison_op."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <ChoiceRegex>
        if match := RE3.match(state.input, state.pos):
            state.pos = match.end()
            matched = True
        else:
            matched = False
        # </ChoiceRegex>
        state.rule_stack.pop()
        if state.tag_stack:
            tag4: str | None = state.tag_stack.pop()
        else:
            tag4 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag4,))
        return matched
    
    return inner
    
parse_comparison_op = _parse_comparison_op()

def _parse_singular_query() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('singular_query', 2)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse singular_query."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Choice>
        children3: list[Pair] = []
        matched = False
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_rel_singular_query(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_abs_singular_query(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        # </Choice>
        state.rule_stack.pop()
        # Silent rule 'singular_query'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_singular_query = _parse_singular_query()

def _parse_rel_singular_query() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('rel_singular_query', 0)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse rel_singular_query."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=2>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            # <String>
            if state.input.startswith('@', state.pos):
                state.pos += 1
                matched3 = True
            else:
                matched3 = False
                state.fail('"@"')
            # </String>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Repeat>
            trivia_pos6 = state.pos
            children5: list[Pair] = []
            while True:
                state.checkpoint()
                # <Group>
                # <Sequence n=2>
                all_ok8 = True
                if all_ok8:
                    matched7 = False
                    # <Identifier>
                    matched7 = parse_S(state, children5)
                    # </Identifier>
                    if not matched7:
                        all_ok8 = False
                    if all_ok8:
                        parse_trivia(state, children5)
                if all_ok8:
                    matched7 = False
                    # <Group>
                    # <Choice>
                    children9: list[Pair] = []
                    matched7 = False
                    if not matched7:
                        state.checkpoint()
                        # <Identifier>
                        matched7 = parse_name_segment(state, children9)
                        # </Identifier>
                        if matched7:
                            state.ok()
                            children5.extend(children9)
                        else:
                            state.restore()
                            children9.clear()
                    if not matched7:
                        state.checkpoint()
                        # <Identifier>
                        matched7 = parse_index_segment(state, children9)
                        # </Identifier>
                        if matched7:
                            state.ok()
                            children5.extend(children9)
                        else:
                            state.restore()
                            children9.clear()
                    # </Choice>
                    # </Group>
                    if not matched7:
                        all_ok8 = False
                matched3 = all_ok8
                # </Sequence>
                # </Group>
                if matched3:
                    state.ok()
                    children2.extend(children5)
                    children5.clear()
                    trivia_pos6 = state.pos
                    parse_trivia(state, children5)
                else:
                    state.restore()
                    state.pos = trivia_pos6
                    matched3 = True
                    break
            # </Repeat>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag10: str | None = state.tag_stack.pop()
        else:
            tag10 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag10,))
        return matched
    
    return inner
    
parse_rel_singular_query = _parse_rel_singular_query()

def _parse_abs_singular_query() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('abs_singular_query', 0)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse abs_singular_query."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=2>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            # <String>
            if state.input.startswith('$', state.pos):
                state.pos += 1
                matched3 = True
            else:
                matched3 = False
                state.fail('"$"')
            # </String>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Repeat>
            trivia_pos6 = state.pos
            children5: list[Pair] = []
            while True:
                state.checkpoint()
                # <Group>
                # <Sequence n=2>
                all_ok8 = True
                if all_ok8:
                    matched7 = False
                    # <Identifier>
                    matched7 = parse_S(state, children5)
                    # </Identifier>
                    if not matched7:
                        all_ok8 = False
                    if all_ok8:
                        parse_trivia(state, children5)
                if all_ok8:
                    matched7 = False
                    # <Group>
                    # <Choice>
                    children9: list[Pair] = []
                    matched7 = False
                    if not matched7:
                        state.checkpoint()
                        # <Identifier>
                        matched7 = parse_name_segment(state, children9)
                        # </Identifier>
                        if matched7:
                            state.ok()
                            children5.extend(children9)
                        else:
                            state.restore()
                            children9.clear()
                    if not matched7:
                        state.checkpoint()
                        # <Identifier>
                        matched7 = parse_index_segment(state, children9)
                        # </Identifier>
                        if matched7:
                            state.ok()
                            children5.extend(children9)
                        else:
                            state.restore()
                            children9.clear()
                    # </Choice>
                    # </Group>
                    if not matched7:
                        all_ok8 = False
                matched3 = all_ok8
                # </Sequence>
                # </Group>
                if matched3:
                    state.ok()
                    children2.extend(children5)
                    children5.clear()
                    trivia_pos6 = state.pos
                    parse_trivia(state, children5)
                else:
                    state.restore()
                    state.pos = trivia_pos6
                    matched3 = True
                    break
            # </Repeat>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag10: str | None = state.tag_stack.pop()
        else:
            tag10 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag10,))
        return matched
    
    return inner
    
parse_abs_singular_query = _parse_abs_singular_query()

def _parse_singular_query_segments() -> Callable[[ParserState, list[Pair]], bool]:
    RE9 = re.compile('[\\\t\\\n\\\r\\ ]', re.VERSION1)
    
    rule_frame = RuleFrame('singular_query_segments', 2)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse singular_query_segments."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Repeat>
        trivia_pos4 = state.pos
        children3: list[Pair] = []
        while True:
            state.checkpoint()
            # <Group>
            # <Sequence n=2>
            all_ok6 = True
            if all_ok6:
                matched5 = False
                # <Repeat>
                trivia_pos8 = state.pos
                children7: list[Pair] = []
                while True:
                    state.checkpoint()
                    # <ChoiceRegex>
                    if match := RE9.match(state.input, state.pos):
                        state.pos = match.end()
                        matched5 = True
                    else:
                        matched5 = False
                    # </ChoiceRegex>
                    if matched5:
                        state.ok()
                        children3.extend(children7)
                        children7.clear()
                        trivia_pos8 = state.pos
                        parse_trivia(state, children7)
                    else:
                        state.restore()
                        state.pos = trivia_pos8
                        matched5 = True
                        break
                # </Repeat>
                if not matched5:
                    all_ok6 = False
                if all_ok6:
                    parse_trivia(state, children3)
            if all_ok6:
                matched5 = False
                # <Group>
                # <Choice>
                children10: list[Pair] = []
                matched5 = False
                if not matched5:
                    state.checkpoint()
                    # <Identifier>
                    matched5 = parse_name_segment(state, children10)
                    # </Identifier>
                    if matched5:
                        state.ok()
                        children3.extend(children10)
                    else:
                        state.restore()
                        children10.clear()
                if not matched5:
                    state.checkpoint()
                    # <Identifier>
                    matched5 = parse_index_segment(state, children10)
                    # </Identifier>
                    if matched5:
                        state.ok()
                        children3.extend(children10)
                    else:
                        state.restore()
                        children10.clear()
                # </Choice>
                # </Group>
                if not matched5:
                    all_ok6 = False
            matched = all_ok6
            # </Sequence>
            # </Group>
            if matched:
                state.ok()
                children2.extend(children3)
                children3.clear()
                trivia_pos4 = state.pos
                parse_trivia(state, children3)
            else:
                state.restore()
                state.pos = trivia_pos4
                matched = True
                break
        # </Repeat>
        state.rule_stack.pop()
        # Silent rule 'singular_query_segments'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_singular_query_segments = _parse_singular_query_segments()

def _parse_name_segment() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('name_segment', 0)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse name_segment."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Choice>
        children3: list[Pair] = []
        matched = False
        if not matched:
            state.checkpoint()
            # <Group>
            # <Sequence n=3>
            all_ok5 = True
            if all_ok5:
                matched4 = False
                # <String>
                if state.input.startswith('[', state.pos):
                    state.pos += 1
                    matched4 = True
                else:
                    matched4 = False
                    state.fail('"["')
                # </String>
                if not matched4:
                    all_ok5 = False
                if all_ok5:
                    parse_trivia(state, children3)
            if all_ok5:
                matched4 = False
                # <Choice>
                children6: list[Pair] = []
                matched4 = False
                if not matched4:
                    state.checkpoint()
                    # <Group>
                    # <Sequence n=3>
                    all_ok8 = True
                    if all_ok8:
                        matched7 = False
                        # <String>
                        if state.input.startswith('"', state.pos):
                            state.pos += 1
                            matched7 = True
                        else:
                            matched7 = False
                            state.fail('"""')
                        # </String>
                        if not matched7:
                            all_ok8 = False
                        if all_ok8:
                            parse_trivia(state, children6)
                    if all_ok8:
                        matched7 = False
                        # <Identifier>
                        matched7 = parse_double_quoted(state, children6)
                        # </Identifier>
                        if not matched7:
                            all_ok8 = False
                        if all_ok8:
                            parse_trivia(state, children6)
                    if all_ok8:
                        matched7 = False
                        # <String>
                        if state.input.startswith('"', state.pos):
                            state.pos += 1
                            matched7 = True
                        else:
                            matched7 = False
                            state.fail('"""')
                        # </String>
                        if not matched7:
                            all_ok8 = False
                    matched4 = all_ok8
                    # </Sequence>
                    # </Group>
                    if matched4:
                        state.ok()
                        children3.extend(children6)
                    else:
                        state.restore()
                        children6.clear()
                if not matched4:
                    state.checkpoint()
                    # <Group>
                    # <Sequence n=3>
                    all_ok10 = True
                    if all_ok10:
                        matched9 = False
                        # <String>
                        if state.input.startswith("'", state.pos):
                            state.pos += 1
                            matched9 = True
                        else:
                            matched9 = False
                            state.fail('"\'"')
                        # </String>
                        if not matched9:
                            all_ok10 = False
                        if all_ok10:
                            parse_trivia(state, children6)
                    if all_ok10:
                        matched9 = False
                        # <Identifier>
                        matched9 = parse_single_quoted(state, children6)
                        # </Identifier>
                        if not matched9:
                            all_ok10 = False
                        if all_ok10:
                            parse_trivia(state, children6)
                    if all_ok10:
                        matched9 = False
                        # <String>
                        if state.input.startswith("'", state.pos):
                            state.pos += 1
                            matched9 = True
                        else:
                            matched9 = False
                            state.fail('"\'"')
                        # </String>
                        if not matched9:
                            all_ok10 = False
                    matched4 = all_ok10
                    # </Sequence>
                    # </Group>
                    if matched4:
                        state.ok()
                        children3.extend(children6)
                    else:
                        state.restore()
                        children6.clear()
                # </Choice>
                if not matched4:
                    all_ok5 = False
                if all_ok5:
                    parse_trivia(state, children3)
            if all_ok5:
                matched4 = False
                # <String>
                if state.input.startswith(']', state.pos):
                    state.pos += 1
                    matched4 = True
                else:
                    matched4 = False
                    state.fail('"]"')
                # </String>
                if not matched4:
                    all_ok5 = False
            matched = all_ok5
            # </Sequence>
            # </Group>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Group>
            # <Sequence n=2>
            all_ok12 = True
            if all_ok12:
                matched11 = False
                # <String>
                if state.input.startswith('.', state.pos):
                    state.pos += 1
                    matched11 = True
                else:
                    matched11 = False
                    state.fail('"."')
                # </String>
                if not matched11:
                    all_ok12 = False
                if all_ok12:
                    parse_trivia(state, children3)
            if all_ok12:
                matched11 = False
                # <Identifier>
                matched11 = parse_member_name_shorthand(state, children3)
                # </Identifier>
                if not matched11:
                    all_ok12 = False
            matched = all_ok12
            # </Sequence>
            # </Group>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        # </Choice>
        state.rule_stack.pop()
        if state.tag_stack:
            tag13: str | None = state.tag_stack.pop()
        else:
            tag13 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag13,))
        return matched
    
    return inner
    
parse_name_segment = _parse_name_segment()

def _parse_index_segment() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('index_segment', 0)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse index_segment."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=3>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            # <String>
            if state.input.startswith('[', state.pos):
                state.pos += 1
                matched3 = True
            else:
                matched3 = False
                state.fail('"["')
            # </String>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Identifier>
            matched3 = parse_index_selector(state, children2)
            # </Identifier>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <String>
            if state.input.startswith(']', state.pos):
                state.pos += 1
                matched3 = True
            else:
                matched3 = False
                state.fail('"]"')
            # </String>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag5: str | None = state.tag_stack.pop()
        else:
            tag5 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag5,))
        return matched
    
    return inner
    
parse_index_segment = _parse_index_segment()

def _parse_number() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('number', 0)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse number."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=3>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            # <Group>
            # <Choice>
            children5: list[Pair] = []
            matched3 = False
            if not matched3:
                state.checkpoint()
                # <Identifier>
                matched3 = parse_int(state, children5)
                # </Identifier>
                if matched3:
                    state.ok()
                    children2.extend(children5)
                else:
                    state.restore()
                    children5.clear()
            if not matched3:
                state.checkpoint()
                # <String>
                if state.input.startswith('-0', state.pos):
                    state.pos += 2
                    matched3 = True
                else:
                    matched3 = False
                    state.fail('"-0"')
                # </String>
                if matched3:
                    state.ok()
                    children2.extend(children5)
                else:
                    state.restore()
                    children5.clear()
            # </Choice>
            # </Group>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Optional>
            children6: list[Pair] = []
            state.checkpoint()
            # <Identifier>
            matched3 = parse_frac(state, children6)
            # </Identifier>
            if matched3:
                state.ok()
                children2.extend(children6)
            else:
                state.restore()
                children6.clear()
            matched3 = True
            # </Optional>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Optional>
            children7: list[Pair] = []
            state.checkpoint()
            # <Identifier>
            matched3 = parse_exp(state, children7)
            # </Identifier>
            if matched3:
                state.ok()
                children2.extend(children7)
            else:
                state.restore()
                children7.clear()
            matched3 = True
            # </Optional>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag8: str | None = state.tag_stack.pop()
        else:
            tag8 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag8,))
        return matched
    
    return inner
    
parse_number = _parse_number()

def _parse_frac() -> Callable[[ParserState, list[Pair]], bool]:
    RE7 = re.compile('[0-9]', re.I)
    RE10 = re.compile('[0-9]', re.I)
    
    rule_frame = RuleFrame('frac', 0)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse frac."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=2>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            # <String>
            if state.input.startswith('.', state.pos):
                state.pos += 1
                matched3 = True
            else:
                matched3 = False
                state.fail('"."')
            # </String>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Sequence n=2>
            all_ok6 = True
            if all_ok6:
                matched5 = False
                # <Range>
                if match := RE7.match(state.input, state.pos):
                    state.pos = match.end()
                    matched5 = True
                else:
                    matched5 = False
                    state.fail("''0''..''9''")
                # </Range>
                if not matched5:
                    all_ok6 = False
                if all_ok6:
                    parse_trivia(state, children2)
            if all_ok6:
                matched5 = False
                # <Repeat>
                trivia_pos9 = state.pos
                children8: list[Pair] = []
                while True:
                    state.checkpoint()
                    # <Range>
                    if match := RE10.match(state.input, state.pos):
                        state.pos = match.end()
                        matched5 = True
                    else:
                        matched5 = False
                        state.fail("''0''..''9''")
                    # </Range>
                    if matched5:
                        state.ok()
                        children2.extend(children8)
                        children8.clear()
                        trivia_pos9 = state.pos
                        parse_trivia(state, children8)
                    else:
                        state.restore()
                        state.pos = trivia_pos9
                        matched5 = True
                        break
                # </Repeat>
                if not matched5:
                    all_ok6 = False
            matched3 = all_ok6
            # </Sequence>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag11: str | None = state.tag_stack.pop()
        else:
            tag11 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag11,))
        return matched
    
    return inner
    
parse_frac = _parse_frac()

def _parse_exp() -> Callable[[ParserState, list[Pair]], bool]:
    RE5 = re.compile('e', re.I)
    RE7 = re.compile('[\\+\\-]', re.VERSION1)
    RE10 = re.compile('[0-9]', re.I)
    RE13 = re.compile('[0-9]', re.I)
    
    rule_frame = RuleFrame('exp', 0)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse exp."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=3>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            # <CIString>
            if match := RE5.match(state.input, state.pos):
                state.pos = match.end()
                matched3 = True
            else:
                matched3 = False
                state.fail('^"e"')
            # </CIString>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Optional>
            children6: list[Pair] = []
            state.checkpoint()
            # <Group>
            # <ChoiceRegex>
            if match := RE7.match(state.input, state.pos):
                state.pos = match.end()
                matched3 = True
            else:
                matched3 = False
            # </ChoiceRegex>
            # </Group>
            if matched3:
                state.ok()
                children2.extend(children6)
            else:
                state.restore()
                children6.clear()
            matched3 = True
            # </Optional>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Sequence n=2>
            all_ok9 = True
            if all_ok9:
                matched8 = False
                # <Range>
                if match := RE10.match(state.input, state.pos):
                    state.pos = match.end()
                    matched8 = True
                else:
                    matched8 = False
                    state.fail("''0''..''9''")
                # </Range>
                if not matched8:
                    all_ok9 = False
                if all_ok9:
                    parse_trivia(state, children2)
            if all_ok9:
                matched8 = False
                # <Repeat>
                trivia_pos12 = state.pos
                children11: list[Pair] = []
                while True:
                    state.checkpoint()
                    # <Range>
                    if match := RE13.match(state.input, state.pos):
                        state.pos = match.end()
                        matched8 = True
                    else:
                        matched8 = False
                        state.fail("''0''..''9''")
                    # </Range>
                    if matched8:
                        state.ok()
                        children2.extend(children11)
                        children11.clear()
                        trivia_pos12 = state.pos
                        parse_trivia(state, children11)
                    else:
                        state.restore()
                        state.pos = trivia_pos12
                        matched8 = True
                        break
                # </Repeat>
                if not matched8:
                    all_ok9 = False
            matched3 = all_ok9
            # </Sequence>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag14: str | None = state.tag_stack.pop()
        else:
            tag14 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag14,))
        return matched
    
    return inner
    
parse_exp = _parse_exp()

def _parse_true_literal() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('true_literal', 0)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse true_literal."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <String>
        if state.input.startswith('true', state.pos):
            state.pos += 4
            matched = True
        else:
            matched = False
            state.fail('"true"')
        # </String>
        state.rule_stack.pop()
        if state.tag_stack:
            tag3: str | None = state.tag_stack.pop()
        else:
            tag3 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag3,))
        return matched
    
    return inner
    
parse_true_literal = _parse_true_literal()

def _parse_false_literal() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('false_literal', 0)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse false_literal."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <String>
        if state.input.startswith('false', state.pos):
            state.pos += 5
            matched = True
        else:
            matched = False
            state.fail('"false"')
        # </String>
        state.rule_stack.pop()
        if state.tag_stack:
            tag3: str | None = state.tag_stack.pop()
        else:
            tag3 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag3,))
        return matched
    
    return inner
    
parse_false_literal = _parse_false_literal()

def _parse_null() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('null', 0)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse null."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <String>
        if state.input.startswith('null', state.pos):
            state.pos += 4
            matched = True
        else:
            matched = False
            state.fail('"null"')
        # </String>
        state.rule_stack.pop()
        if state.tag_stack:
            tag3: str | None = state.tag_stack.pop()
        else:
            tag3 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag3,))
        return matched
    
    return inner
    
parse_null = _parse_null()

def _parse_function_name() -> Callable[[ParserState, list[Pair]], bool]:
    RE5 = re.compile('[a-z]', re.I)
    RE9 = re.compile('[0-9]', re.I)
    
    rule_frame = RuleFrame('function_name', 0)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse function_name."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=2>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            # <Range>
            if match := RE5.match(state.input, state.pos):
                state.pos = match.end()
                matched3 = True
            else:
                matched3 = False
                state.fail("''a''..''z''")
            # </Range>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Repeat>
            trivia_pos7 = state.pos
            children6: list[Pair] = []
            while True:
                state.checkpoint()
                # <Choice>
                children8: list[Pair] = []
                matched3 = False
                if not matched3:
                    state.checkpoint()
                    # <Identifier>
                    matched3 = parse_function_name_first(state, children8)
                    # </Identifier>
                    if matched3:
                        state.ok()
                        children6.extend(children8)
                    else:
                        state.restore()
                        children8.clear()
                if not matched3:
                    state.checkpoint()
                    # <String>
                    if state.input.startswith('_', state.pos):
                        state.pos += 1
                        matched3 = True
                    else:
                        matched3 = False
                        state.fail('"_"')
                    # </String>
                    if matched3:
                        state.ok()
                        children6.extend(children8)
                    else:
                        state.restore()
                        children8.clear()
                if not matched3:
                    state.checkpoint()
                    # <Range>
                    if match := RE9.match(state.input, state.pos):
                        state.pos = match.end()
                        matched3 = True
                    else:
                        matched3 = False
                        state.fail("''0''..''9''")
                    # </Range>
                    if matched3:
                        state.ok()
                        children6.extend(children8)
                    else:
                        state.restore()
                        children8.clear()
                # </Choice>
                if matched3:
                    state.ok()
                    children2.extend(children6)
                    children6.clear()
                    trivia_pos7 = state.pos
                    parse_trivia(state, children6)
                else:
                    state.restore()
                    state.pos = trivia_pos7
                    matched3 = True
                    break
            # </Repeat>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag10: str | None = state.tag_stack.pop()
        else:
            tag10 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag10,))
        return matched
    
    return inner
    
parse_function_name = _parse_function_name()

def _parse_function_name_first() -> Callable[[ParserState, list[Pair]], bool]:
    RE3 = re.compile('[a-z]', re.I)
    
    rule_frame = RuleFrame('function_name_first', 2)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse function_name_first."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Range>
        if match := RE3.match(state.input, state.pos):
            state.pos = match.end()
            matched = True
        else:
            matched = False
            state.fail("''a''..''z''")
        # </Range>
        state.rule_stack.pop()
        # Silent rule 'function_name_first'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_function_name_first = _parse_function_name_first()

def _parse_function_name_char() -> Callable[[ParserState, list[Pair]], bool]:
    RE4 = re.compile('[a-z]', re.I)
    RE5 = re.compile('[0-9]', re.I)
    
    rule_frame = RuleFrame('function_name_char', 2)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse function_name_char."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Choice>
        children3: list[Pair] = []
        matched = False
        if not matched:
            state.checkpoint()
            # <Range>
            if match := RE4.match(state.input, state.pos):
                state.pos = match.end()
                matched = True
            else:
                matched = False
                state.fail("''a''..''z''")
            # </Range>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <String>
            if state.input.startswith('_', state.pos):
                state.pos += 1
                matched = True
            else:
                matched = False
                state.fail('"_"')
            # </String>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Range>
            if match := RE5.match(state.input, state.pos):
                state.pos = match.end()
                matched = True
            else:
                matched = False
                state.fail("''0''..''9''")
            # </Range>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        # </Choice>
        state.rule_stack.pop()
        # Silent rule 'function_name_char'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_function_name_char = _parse_function_name_char()

def _parse_function_expr() -> Callable[[ParserState, list[Pair]], bool]:
    RE7 = re.compile('[\\\t\\\n\\\r\\ ]', re.VERSION1)
    RE18 = re.compile('[\\\t\\\n\\\r\\ ]', re.VERSION1)
    RE21 = re.compile('[\\\t\\\n\\\r\\ ]', re.VERSION1)
    RE25 = re.compile('[\\\t\\\n\\\r\\ ]', re.VERSION1)
    
    rule_frame = RuleFrame('function_expr', 0)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse function_expr."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=6>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            # <Identifier>
            matched3 = parse_function_name(state, children2)
            # </Identifier>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <String>
            if state.input.startswith('(', state.pos):
                state.pos += 1
                matched3 = True
            else:
                matched3 = False
                state.fail('"("')
            # </String>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Repeat>
            trivia_pos6 = state.pos
            children5: list[Pair] = []
            while True:
                state.checkpoint()
                # <ChoiceRegex>
                if match := RE7.match(state.input, state.pos):
                    state.pos = match.end()
                    matched3 = True
                else:
                    matched3 = False
                # </ChoiceRegex>
                if matched3:
                    state.ok()
                    children2.extend(children5)
                    children5.clear()
                    trivia_pos6 = state.pos
                    parse_trivia(state, children5)
                else:
                    state.restore()
                    state.pos = trivia_pos6
                    matched3 = True
                    break
            # </Repeat>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Optional>
            children8: list[Pair] = []
            state.checkpoint()
            # <Group>
            # <Sequence n=2>
            all_ok10 = True
            if all_ok10:
                matched9 = False
                # <Choice>
                children11: list[Pair] = []
                matched9 = False
                if not matched9:
                    state.checkpoint()
                    # <Identifier>
                    matched9 = parse_filter_query(state, children11)
                    # </Identifier>
                    if matched9:
                        state.ok()
                        children8.extend(children11)
                    else:
                        state.restore()
                        children11.clear()
                if not matched9:
                    state.checkpoint()
                    # <Identifier>
                    matched9 = parse_logical_expr(state, children11)
                    # </Identifier>
                    if matched9:
                        state.ok()
                        children8.extend(children11)
                    else:
                        state.restore()
                        children11.clear()
                if not matched9:
                    state.checkpoint()
                    # <Identifier>
                    matched9 = parse_function_expr(state, children11)
                    # </Identifier>
                    if matched9:
                        state.ok()
                        children8.extend(children11)
                    else:
                        state.restore()
                        children11.clear()
                if not matched9:
                    state.checkpoint()
                    # <Identifier>
                    matched9 = parse_literal(state, children11)
                    # </Identifier>
                    if matched9:
                        state.ok()
                        children8.extend(children11)
                    else:
                        state.restore()
                        children11.clear()
                # </Choice>
                if not matched9:
                    all_ok10 = False
                if all_ok10:
                    parse_trivia(state, children8)
            if all_ok10:
                matched9 = False
                # <Repeat>
                trivia_pos13 = state.pos
                children12: list[Pair] = []
                while True:
                    state.checkpoint()
                    # <Group>
                    # <Sequence n=4>
                    all_ok15 = True
                    if all_ok15:
                        matched14 = False
                        # <Repeat>
                        trivia_pos17 = state.pos
                        children16: list[Pair] = []
                        while True:
                            state.checkpoint()
                            # <ChoiceRegex>
                            if match := RE18.match(state.input, state.pos):
                                state.pos = match.end()
                                matched14 = True
                            else:
                                matched14 = False
                            # </ChoiceRegex>
                            if matched14:
                                state.ok()
                                children12.extend(children16)
                                children16.clear()
                                trivia_pos17 = state.pos
                                parse_trivia(state, children16)
                            else:
                                state.restore()
                                state.pos = trivia_pos17
                                matched14 = True
                                break
                        # </Repeat>
                        if not matched14:
                            all_ok15 = False
                        if all_ok15:
                            parse_trivia(state, children12)
                    if all_ok15:
                        matched14 = False
                        # <String>
                        if state.input.startswith(',', state.pos):
                            state.pos += 1
                            matched14 = True
                        else:
                            matched14 = False
                            state.fail('","')
                        # </String>
                        if not matched14:
                            all_ok15 = False
                        if all_ok15:
                            parse_trivia(state, children12)
                    if all_ok15:
                        matched14 = False
                        # <Repeat>
                        trivia_pos20 = state.pos
                        children19: list[Pair] = []
                        while True:
                            state.checkpoint()
                            # <ChoiceRegex>
                            if match := RE21.match(state.input, state.pos):
                                state.pos = match.end()
                                matched14 = True
                            else:
                                matched14 = False
                            # </ChoiceRegex>
                            if matched14:
                                state.ok()
                                children12.extend(children19)
                                children19.clear()
                                trivia_pos20 = state.pos
                                parse_trivia(state, children19)
                            else:
                                state.restore()
                                state.pos = trivia_pos20
                                matched14 = True
                                break
                        # </Repeat>
                        if not matched14:
                            all_ok15 = False
                        if all_ok15:
                            parse_trivia(state, children12)
                    if all_ok15:
                        matched14 = False
                        # <Choice>
                        children22: list[Pair] = []
                        matched14 = False
                        if not matched14:
                            state.checkpoint()
                            # <Identifier>
                            matched14 = parse_filter_query(state, children22)
                            # </Identifier>
                            if matched14:
                                state.ok()
                                children12.extend(children22)
                            else:
                                state.restore()
                                children22.clear()
                        if not matched14:
                            state.checkpoint()
                            # <Identifier>
                            matched14 = parse_logical_expr(state, children22)
                            # </Identifier>
                            if matched14:
                                state.ok()
                                children12.extend(children22)
                            else:
                                state.restore()
                                children22.clear()
                        if not matched14:
                            state.checkpoint()
                            # <Identifier>
                            matched14 = parse_function_expr(state, children22)
                            # </Identifier>
                            if matched14:
                                state.ok()
                                children12.extend(children22)
                            else:
                                state.restore()
                                children22.clear()
                        if not matched14:
                            state.checkpoint()
                            # <Identifier>
                            matched14 = parse_literal(state, children22)
                            # </Identifier>
                            if matched14:
                                state.ok()
                                children12.extend(children22)
                            else:
                                state.restore()
                                children22.clear()
                        # </Choice>
                        if not matched14:
                            all_ok15 = False
                    matched9 = all_ok15
                    # </Sequence>
                    # </Group>
                    if matched9:
                        state.ok()
                        children8.extend(children12)
                        children12.clear()
                        trivia_pos13 = state.pos
                        parse_trivia(state, children12)
                    else:
                        state.restore()
                        state.pos = trivia_pos13
                        matched9 = True
                        break
                # </Repeat>
                if not matched9:
                    all_ok10 = False
            matched3 = all_ok10
            # </Sequence>
            # </Group>
            if matched3:
                state.ok()
                children2.extend(children8)
            else:
                state.restore()
                children8.clear()
            matched3 = True
            # </Optional>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Repeat>
            trivia_pos24 = state.pos
            children23: list[Pair] = []
            while True:
                state.checkpoint()
                # <ChoiceRegex>
                if match := RE25.match(state.input, state.pos):
                    state.pos = match.end()
                    matched3 = True
                else:
                    matched3 = False
                # </ChoiceRegex>
                if matched3:
                    state.ok()
                    children2.extend(children23)
                    children23.clear()
                    trivia_pos24 = state.pos
                    parse_trivia(state, children23)
                else:
                    state.restore()
                    state.pos = trivia_pos24
                    matched3 = True
                    break
            # </Repeat>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <String>
            if state.input.startswith(')', state.pos):
                state.pos += 1
                matched3 = True
            else:
                matched3 = False
                state.fail('")"')
            # </String>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag26: str | None = state.tag_stack.pop()
        else:
            tag26 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag26,))
        return matched
    
    return inner
    
parse_function_expr = _parse_function_expr()

def _parse_function_argument() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('function_argument', 2)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse function_argument."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Choice>
        children3: list[Pair] = []
        matched = False
        if not matched:
            state.checkpoint()
            # <Choice>
            children4: list[Pair] = []
            matched = False
            if not matched:
                state.checkpoint()
                # <Identifier>
                matched = parse_rel_query(state, children4)
                # </Identifier>
                if matched:
                    state.ok()
                    children3.extend(children4)
                else:
                    state.restore()
                    children4.clear()
            if not matched:
                state.checkpoint()
                # <Identifier>
                matched = parse_root_query(state, children4)
                # </Identifier>
                if matched:
                    state.ok()
                    children3.extend(children4)
                else:
                    state.restore()
                    children4.clear()
            # </Choice>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_logical_or_expr(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_function_expr(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Choice>
            children5: list[Pair] = []
            matched = False
            if not matched:
                state.checkpoint()
                # <Identifier>
                matched = parse_number(state, children5)
                # </Identifier>
                if matched:
                    state.ok()
                    children3.extend(children5)
                else:
                    state.restore()
                    children5.clear()
            if not matched:
                state.checkpoint()
                # <Choice>
                children6: list[Pair] = []
                matched = False
                if not matched:
                    state.checkpoint()
                    # <Group>
                    # <Sequence n=3>
                    all_ok8 = True
                    if all_ok8:
                        matched7 = False
                        # <String>
                        if state.input.startswith('"', state.pos):
                            state.pos += 1
                            matched7 = True
                        else:
                            matched7 = False
                            state.fail('"""')
                        # </String>
                        if not matched7:
                            all_ok8 = False
                        if all_ok8:
                            parse_trivia(state, children6)
                    if all_ok8:
                        matched7 = False
                        # <Identifier>
                        matched7 = parse_double_quoted(state, children6)
                        # </Identifier>
                        if not matched7:
                            all_ok8 = False
                        if all_ok8:
                            parse_trivia(state, children6)
                    if all_ok8:
                        matched7 = False
                        # <String>
                        if state.input.startswith('"', state.pos):
                            state.pos += 1
                            matched7 = True
                        else:
                            matched7 = False
                            state.fail('"""')
                        # </String>
                        if not matched7:
                            all_ok8 = False
                    matched = all_ok8
                    # </Sequence>
                    # </Group>
                    if matched:
                        state.ok()
                        children5.extend(children6)
                    else:
                        state.restore()
                        children6.clear()
                if not matched:
                    state.checkpoint()
                    # <Group>
                    # <Sequence n=3>
                    all_ok10 = True
                    if all_ok10:
                        matched9 = False
                        # <String>
                        if state.input.startswith("'", state.pos):
                            state.pos += 1
                            matched9 = True
                        else:
                            matched9 = False
                            state.fail('"\'"')
                        # </String>
                        if not matched9:
                            all_ok10 = False
                        if all_ok10:
                            parse_trivia(state, children6)
                    if all_ok10:
                        matched9 = False
                        # <Identifier>
                        matched9 = parse_single_quoted(state, children6)
                        # </Identifier>
                        if not matched9:
                            all_ok10 = False
                        if all_ok10:
                            parse_trivia(state, children6)
                    if all_ok10:
                        matched9 = False
                        # <String>
                        if state.input.startswith("'", state.pos):
                            state.pos += 1
                            matched9 = True
                        else:
                            matched9 = False
                            state.fail('"\'"')
                        # </String>
                        if not matched9:
                            all_ok10 = False
                    matched = all_ok10
                    # </Sequence>
                    # </Group>
                    if matched:
                        state.ok()
                        children5.extend(children6)
                    else:
                        state.restore()
                        children6.clear()
                # </Choice>
                if matched:
                    state.ok()
                    children3.extend(children5)
                else:
                    state.restore()
                    children5.clear()
            if not matched:
                state.checkpoint()
                # <Identifier>
                matched = parse_true_literal(state, children5)
                # </Identifier>
                if matched:
                    state.ok()
                    children3.extend(children5)
                else:
                    state.restore()
                    children5.clear()
            if not matched:
                state.checkpoint()
                # <Identifier>
                matched = parse_false_literal(state, children5)
                # </Identifier>
                if matched:
                    state.ok()
                    children3.extend(children5)
                else:
                    state.restore()
                    children5.clear()
            if not matched:
                state.checkpoint()
                # <Identifier>
                matched = parse_null(state, children5)
                # </Identifier>
                if matched:
                    state.ok()
                    children3.extend(children5)
                else:
                    state.restore()
                    children5.clear()
            # </Choice>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        # </Choice>
        state.rule_stack.pop()
        # Silent rule 'function_argument'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_function_argument = _parse_function_argument()

def _parse_segment() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('segment', 2)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse segment."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Choice>
        children3: list[Pair] = []
        matched = False
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_child_segment(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_descendant_segment(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        # </Choice>
        state.rule_stack.pop()
        # Silent rule 'segment'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_segment = _parse_segment()

def _parse_child_segment() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('child_segment', 0)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse child_segment."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Choice>
        children3: list[Pair] = []
        matched = False
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_bracketed_selection(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Group>
            # <Sequence n=2>
            all_ok5 = True
            if all_ok5:
                matched4 = False
                # <String>
                if state.input.startswith('.', state.pos):
                    state.pos += 1
                    matched4 = True
                else:
                    matched4 = False
                    state.fail('"."')
                # </String>
                if not matched4:
                    all_ok5 = False
                if all_ok5:
                    parse_trivia(state, children3)
            if all_ok5:
                matched4 = False
                # <Group>
                # <Choice>
                children6: list[Pair] = []
                matched4 = False
                if not matched4:
                    state.checkpoint()
                    # <Identifier>
                    matched4 = parse_wildcard_selector(state, children6)
                    # </Identifier>
                    if matched4:
                        state.ok()
                        children3.extend(children6)
                    else:
                        state.restore()
                        children6.clear()
                if not matched4:
                    state.checkpoint()
                    # <Identifier>
                    matched4 = parse_member_name_shorthand(state, children6)
                    # </Identifier>
                    if matched4:
                        state.ok()
                        children3.extend(children6)
                    else:
                        state.restore()
                        children6.clear()
                # </Choice>
                # </Group>
                if not matched4:
                    all_ok5 = False
            matched = all_ok5
            # </Sequence>
            # </Group>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        # </Choice>
        state.rule_stack.pop()
        if state.tag_stack:
            tag7: str | None = state.tag_stack.pop()
        else:
            tag7 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag7,))
        return matched
    
    return inner
    
parse_child_segment = _parse_child_segment()

def _parse_bracketed_selection() -> Callable[[ParserState, list[Pair]], bool]:
    RE7 = re.compile('[\\\t\\\n\\\r\\ ]', re.VERSION1)
    RE15 = re.compile('[\\\t\\\n\\\r\\ ]', re.VERSION1)
    RE18 = re.compile('[\\\t\\\n\\\r\\ ]', re.VERSION1)
    RE22 = re.compile('[\\\t\\\n\\\r\\ ]', re.VERSION1)
    
    rule_frame = RuleFrame('bracketed_selection', 0)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse bracketed_selection."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=6>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            # <String>
            if state.input.startswith('[', state.pos):
                state.pos += 1
                matched3 = True
            else:
                matched3 = False
                state.fail('"["')
            # </String>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Repeat>
            trivia_pos6 = state.pos
            children5: list[Pair] = []
            while True:
                state.checkpoint()
                # <ChoiceRegex>
                if match := RE7.match(state.input, state.pos):
                    state.pos = match.end()
                    matched3 = True
                else:
                    matched3 = False
                # </ChoiceRegex>
                if matched3:
                    state.ok()
                    children2.extend(children5)
                    children5.clear()
                    trivia_pos6 = state.pos
                    parse_trivia(state, children5)
                else:
                    state.restore()
                    state.pos = trivia_pos6
                    matched3 = True
                    break
            # </Repeat>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Choice>
            children8: list[Pair] = []
            matched3 = False
            if not matched3:
                state.checkpoint()
                # <Identifier>
                matched3 = parse_string_literal(state, children8)
                # </Identifier>
                if matched3:
                    state.ok()
                    children2.extend(children8)
                else:
                    state.restore()
                    children8.clear()
            if not matched3:
                state.checkpoint()
                # <Identifier>
                matched3 = parse_wildcard_selector(state, children8)
                # </Identifier>
                if matched3:
                    state.ok()
                    children2.extend(children8)
                else:
                    state.restore()
                    children8.clear()
            if not matched3:
                state.checkpoint()
                # <Identifier>
                matched3 = parse_slice_selector(state, children8)
                # </Identifier>
                if matched3:
                    state.ok()
                    children2.extend(children8)
                else:
                    state.restore()
                    children8.clear()
            if not matched3:
                state.checkpoint()
                # <Identifier>
                matched3 = parse_index_selector(state, children8)
                # </Identifier>
                if matched3:
                    state.ok()
                    children2.extend(children8)
                else:
                    state.restore()
                    children8.clear()
            if not matched3:
                state.checkpoint()
                # <Identifier>
                matched3 = parse_filter_selector(state, children8)
                # </Identifier>
                if matched3:
                    state.ok()
                    children2.extend(children8)
                else:
                    state.restore()
                    children8.clear()
            # </Choice>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Repeat>
            trivia_pos10 = state.pos
            children9: list[Pair] = []
            while True:
                state.checkpoint()
                # <Group>
                # <Sequence n=4>
                all_ok12 = True
                if all_ok12:
                    matched11 = False
                    # <Repeat>
                    trivia_pos14 = state.pos
                    children13: list[Pair] = []
                    while True:
                        state.checkpoint()
                        # <ChoiceRegex>
                        if match := RE15.match(state.input, state.pos):
                            state.pos = match.end()
                            matched11 = True
                        else:
                            matched11 = False
                        # </ChoiceRegex>
                        if matched11:
                            state.ok()
                            children9.extend(children13)
                            children13.clear()
                            trivia_pos14 = state.pos
                            parse_trivia(state, children13)
                        else:
                            state.restore()
                            state.pos = trivia_pos14
                            matched11 = True
                            break
                    # </Repeat>
                    if not matched11:
                        all_ok12 = False
                    if all_ok12:
                        parse_trivia(state, children9)
                if all_ok12:
                    matched11 = False
                    # <String>
                    if state.input.startswith(',', state.pos):
                        state.pos += 1
                        matched11 = True
                    else:
                        matched11 = False
                        state.fail('","')
                    # </String>
                    if not matched11:
                        all_ok12 = False
                    if all_ok12:
                        parse_trivia(state, children9)
                if all_ok12:
                    matched11 = False
                    # <Repeat>
                    trivia_pos17 = state.pos
                    children16: list[Pair] = []
                    while True:
                        state.checkpoint()
                        # <ChoiceRegex>
                        if match := RE18.match(state.input, state.pos):
                            state.pos = match.end()
                            matched11 = True
                        else:
                            matched11 = False
                        # </ChoiceRegex>
                        if matched11:
                            state.ok()
                            children9.extend(children16)
                            children16.clear()
                            trivia_pos17 = state.pos
                            parse_trivia(state, children16)
                        else:
                            state.restore()
                            state.pos = trivia_pos17
                            matched11 = True
                            break
                    # </Repeat>
                    if not matched11:
                        all_ok12 = False
                    if all_ok12:
                        parse_trivia(state, children9)
                if all_ok12:
                    matched11 = False
                    # <Choice>
                    children19: list[Pair] = []
                    matched11 = False
                    if not matched11:
                        state.checkpoint()
                        # <Identifier>
                        matched11 = parse_string_literal(state, children19)
                        # </Identifier>
                        if matched11:
                            state.ok()
                            children9.extend(children19)
                        else:
                            state.restore()
                            children19.clear()
                    if not matched11:
                        state.checkpoint()
                        # <Identifier>
                        matched11 = parse_wildcard_selector(state, children19)
                        # </Identifier>
                        if matched11:
                            state.ok()
                            children9.extend(children19)
                        else:
                            state.restore()
                            children19.clear()
                    if not matched11:
                        state.checkpoint()
                        # <Identifier>
                        matched11 = parse_slice_selector(state, children19)
                        # </Identifier>
                        if matched11:
                            state.ok()
                            children9.extend(children19)
                        else:
                            state.restore()
                            children19.clear()
                    if not matched11:
                        state.checkpoint()
                        # <Identifier>
                        matched11 = parse_index_selector(state, children19)
                        # </Identifier>
                        if matched11:
                            state.ok()
                            children9.extend(children19)
                        else:
                            state.restore()
                            children19.clear()
                    if not matched11:
                        state.checkpoint()
                        # <Identifier>
                        matched11 = parse_filter_selector(state, children19)
                        # </Identifier>
                        if matched11:
                            state.ok()
                            children9.extend(children19)
                        else:
                            state.restore()
                            children19.clear()
                    # </Choice>
                    if not matched11:
                        all_ok12 = False
                matched3 = all_ok12
                # </Sequence>
                # </Group>
                if matched3:
                    state.ok()
                    children2.extend(children9)
                    children9.clear()
                    trivia_pos10 = state.pos
                    parse_trivia(state, children9)
                else:
                    state.restore()
                    state.pos = trivia_pos10
                    matched3 = True
                    break
            # </Repeat>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Repeat>
            trivia_pos21 = state.pos
            children20: list[Pair] = []
            while True:
                state.checkpoint()
                # <ChoiceRegex>
                if match := RE22.match(state.input, state.pos):
                    state.pos = match.end()
                    matched3 = True
                else:
                    matched3 = False
                # </ChoiceRegex>
                if matched3:
                    state.ok()
                    children2.extend(children20)
                    children20.clear()
                    trivia_pos21 = state.pos
                    parse_trivia(state, children20)
                else:
                    state.restore()
                    state.pos = trivia_pos21
                    matched3 = True
                    break
            # </Repeat>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <String>
            if state.input.startswith(']', state.pos):
                state.pos += 1
                matched3 = True
            else:
                matched3 = False
                state.fail('"]"')
            # </String>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag23: str | None = state.tag_stack.pop()
        else:
            tag23 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag23,))
        return matched
    
    return inner
    
parse_bracketed_selection = _parse_bracketed_selection()

def _parse_member_name_shorthand() -> Callable[[ParserState, list[Pair]], bool]:
    RE5 = re.compile('[_A-Za-z\x80-\ud7ff\ue000-\U0010ffff]', re.VERSION1)
    RE9 = re.compile('[0-9]', re.I)
    
    rule_frame = RuleFrame('member_name_shorthand', 0)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse member_name_shorthand."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=2>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            # <ChoiceRegex>
            if match := RE5.match(state.input, state.pos):
                state.pos = match.end()
                matched3 = True
            else:
                matched3 = False
            # </ChoiceRegex>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Repeat>
            trivia_pos7 = state.pos
            children6: list[Pair] = []
            while True:
                state.checkpoint()
                # <Choice>
                children8: list[Pair] = []
                matched3 = False
                if not matched3:
                    state.checkpoint()
                    # <Identifier>
                    matched3 = parse_name_first(state, children8)
                    # </Identifier>
                    if matched3:
                        state.ok()
                        children6.extend(children8)
                    else:
                        state.restore()
                        children8.clear()
                if not matched3:
                    state.checkpoint()
                    # <Range>
                    if match := RE9.match(state.input, state.pos):
                        state.pos = match.end()
                        matched3 = True
                    else:
                        matched3 = False
                        state.fail("''0''..''9''")
                    # </Range>
                    if matched3:
                        state.ok()
                        children6.extend(children8)
                    else:
                        state.restore()
                        children8.clear()
                # </Choice>
                if matched3:
                    state.ok()
                    children2.extend(children6)
                    children6.clear()
                    trivia_pos7 = state.pos
                    parse_trivia(state, children6)
                else:
                    state.restore()
                    state.pos = trivia_pos7
                    matched3 = True
                    break
            # </Repeat>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag10: str | None = state.tag_stack.pop()
        else:
            tag10 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag10,))
        return matched
    
    return inner
    
parse_member_name_shorthand = _parse_member_name_shorthand()

def _parse_name_first() -> Callable[[ParserState, list[Pair]], bool]:
    RE3 = re.compile('[_A-Za-z\x80-\ud7ff\ue000-\U0010ffff]', re.VERSION1)
    
    rule_frame = RuleFrame('name_first', 2)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse name_first."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <ChoiceRegex>
        if match := RE3.match(state.input, state.pos):
            state.pos = match.end()
            matched = True
        else:
            matched = False
        # </ChoiceRegex>
        state.rule_stack.pop()
        # Silent rule 'name_first'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_name_first = _parse_name_first()

def _parse_name_char() -> Callable[[ParserState, list[Pair]], bool]:
    RE4 = re.compile('[_A-Za-z\x80-\ud7ff\ue000-\U0010ffff]', re.VERSION1)
    RE5 = re.compile('[0-9]', re.I)
    
    rule_frame = RuleFrame('name_char', 2)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse name_char."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Choice>
        children3: list[Pair] = []
        matched = False
        if not matched:
            state.checkpoint()
            # <ChoiceRegex>
            if match := RE4.match(state.input, state.pos):
                state.pos = match.end()
                matched = True
            else:
                matched = False
            # </ChoiceRegex>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Range>
            if match := RE5.match(state.input, state.pos):
                state.pos = match.end()
                matched = True
            else:
                matched = False
                state.fail("''0''..''9''")
            # </Range>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        # </Choice>
        state.rule_stack.pop()
        # Silent rule 'name_char'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_name_char = _parse_name_char()

def _parse_descendant_segment() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame('descendant_segment', 0)
    
    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse descendant_segment."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=2>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            # <String>
            if state.input.startswith('..', state.pos):
                state.pos += 2
                matched3 = True
            else:
                matched3 = False
                state.fail('".."')
            # </String>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Group>
            # <Choice>
            children5: list[Pair] = []
            matched3 = False
            if not matched3:
                state.checkpoint()
                # <Identifier>
                matched3 = parse_bracketed_selection(state, children5)
                # </Identifier>
                if matched3:
                    state.ok()
                    children2.extend(children5)
                else:
                    state.restore()
                    children5.clear()
            if not matched3:
                state.checkpoint()
                # <Identifier>
                matched3 = parse_wildcard_selector(state, children5)
                # </Identifier>
                if matched3:
                    state.ok()
                    children2.extend(children5)
                else:
                    state.restore()
                    children5.clear()
            if not matched3:
                state.checkpoint()
                # <Identifier>
                matched3 = parse_member_name_shorthand(state, children5)
                # </Identifier>
                if matched3:
                    state.ok()
                    children2.extend(children5)
                else:
                    state.restore()
                    children5.clear()
            # </Choice>
            # </Group>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag6: str | None = state.tag_stack.pop()
        else:
            tag6 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag6,))
        return matched
    
    return inner
    
parse_descendant_segment = _parse_descendant_segment()

def parse_trivia(state: ParserState, pairs: list[Pair]) -> bool:
    return True

_RULE_MAP: dict[str, Callable[[ParserState, list[Pair]], bool]] = {
    'EOI': parse_EOI,
    'jsonpath': parse_jsonpath,
    'jsonpath_query': parse_jsonpath_query,
    'segments': parse_segments,
    'B': parse_B,
    'S': parse_S,
    'root_identifier': parse_root_identifier,
    'selector': parse_selector,
    'name_selector': parse_name_selector,
    'string_literal': parse_string_literal,
    'double_quoted': parse_double_quoted,
    'single_quoted': parse_single_quoted,
    'double_quoted_char': parse_double_quoted_char,
    'single_quoted_char': parse_single_quoted_char,
    'ESC': parse_ESC,
    'unescaped': parse_unescaped,
    'escapable': parse_escapable,
    'hexchar': parse_hexchar,
    'non_surrogate': parse_non_surrogate,
    'high_surrogate': parse_high_surrogate,
    'low_surrogate': parse_low_surrogate,
    'wildcard_selector': parse_wildcard_selector,
    'index_selector': parse_index_selector,
    'int': parse_int,
    'slice_selector': parse_slice_selector,
    'start': parse_start,
    'stop': parse_stop,
    'step': parse_step,
    'filter_selector': parse_filter_selector,
    'logical_expr': parse_logical_expr,
    'logical_or_expr': parse_logical_or_expr,
    'logical_and_expr': parse_logical_and_expr,
    'basic_expr': parse_basic_expr,
    'paren_expr': parse_paren_expr,
    'logical_not_op': parse_logical_not_op,
    'test_expr': parse_test_expr,
    'filter_query': parse_filter_query,
    'root_query': parse_root_query,
    'rel_query': parse_rel_query,
    'current_node_identifier': parse_current_node_identifier,
    'comparison_expr': parse_comparison_expr,
    'literal': parse_literal,
    'comparable': parse_comparable,
    'comparison_op': parse_comparison_op,
    'singular_query': parse_singular_query,
    'rel_singular_query': parse_rel_singular_query,
    'abs_singular_query': parse_abs_singular_query,
    'singular_query_segments': parse_singular_query_segments,
    'name_segment': parse_name_segment,
    'index_segment': parse_index_segment,
    'number': parse_number,
    'frac': parse_frac,
    'exp': parse_exp,
    'true_literal': parse_true_literal,
    'false_literal': parse_false_literal,
    'null': parse_null,
    'function_name': parse_function_name,
    'function_name_first': parse_function_name_first,
    'function_name_char': parse_function_name_char,
    'function_expr': parse_function_expr,
    'function_argument': parse_function_argument,
    'segment': parse_segment,
    'child_segment': parse_child_segment,
    'bracketed_selection': parse_bracketed_selection,
    'member_name_shorthand': parse_member_name_shorthand,
    'name_first': parse_name_first,
    'name_char': parse_name_char,
    'descendant_segment': parse_descendant_segment,
}

def parse(start_rule: str, input_: str, *, start_pos: int = 0) -> Pairs:
    """Parse `input_` starting from `rule`."""
    state = ParserState(input_, start_pos)
    pairs: list[Pair] = []
    matched = _RULE_MAP[start_rule](state, pairs)
    if matched:
        return Pairs(pairs)
    raise PestParsingError(state)

class Parser:
    """A class wrapping `parse()` in `Parser.parse()`."""
    def parse(self, start_rule: str, input_: str, *, start_pos: int = 0) -> Pairs:
        """Parse `input_` starting from `start_rule`."""
        return parse(start_rule, input_, start_pos=start_pos)

def main() -> None:
    parser = argparse.ArgumentParser(
        prog="parser",
        description="A parser generated by Python pest.",
    )

    parser.add_argument(
        "rule",
        metavar="RULE",
        help="The name of the rule to start parsing from.",
    )

    group = parser.add_mutually_exclusive_group(required=True)

    group.add_argument(
        "-i",
        "--input",
        metavar="INPUT",
        help="Input text to parse.",
    )

    group.add_argument(
        "-f",
        "--file",
        metavar="FILE",
        type=argparse.FileType("r"),
        help="Path to a file containing text to parse, or `-` to read from stdin.",
    )

    parser.add_argument(
        "--verbose",
        action="store_true",
        help="Display verbose output",
    )

    args = parser.parse_args()
    text = args.input or args.file.read()

    print(  # noqa: T201
        parse(args.rule, text).dumps(compact=not args.verbose)
    )

if __name__ == "__main__":
    import argparse
    main()
