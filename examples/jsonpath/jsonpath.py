"""JSONPath query expression parser."""

from __future__ import annotations

from pest import Pair
from pest import PestParsingError

from ._ast import ChildSegment
from ._ast import FilterSelector
from ._ast import IndexSelector
from ._ast import NameSelector
from ._ast import RecursiveDescentSegment
from ._ast import Segment
from ._ast import Selector
from ._ast import SliceSelector
from ._ast import WildcardSelector
from ._types import ExpressionType
from .exceptions import JSONPathError
from .exceptions import JSONPathSyntaxError
from .exceptions import JSONPathTypeError
from .filter_expression import BooleanLiteral
from .filter_expression import ComparisonExpression
from .filter_expression import Expression
from .filter_expression import FilterExpression
from .filter_expression import FilterExpressionLiteral
from .filter_expression import FilterQuery
from .filter_expression import FloatLiteral
from .filter_expression import FunctionExtension
from .filter_expression import IntegerLiteral
from .filter_expression import LogicalExpression
from .filter_expression import NullLiteral
from .filter_expression import PrefixExpression
from .filter_expression import RelativeFilterQuery
from .filter_expression import RootFilterQuery
from .filter_expression import StringLiteral
from .function_extensions import Count
from .function_extensions import FilterFunction
from .function_extensions import Length
from .function_extensions import Match
from .function_extensions import Search
from .function_extensions import Value
from .parser import Parser

# ./parser.py is generated by ./generate.py
from .parser import Rule
from .query import JSONPathQuery
from .unescape import unescape_string


class JSONPathParser:
    """JSONPath query expression parser."""

    FUNCTION_EXTENSIONS: dict[str, FilterFunction] = {
        "count": Count(),
        "length": Length(),
        "match": Match(),
        "search": Search(),
        "value": Value(),
    }

    MAX_INT_INDEX = (2**53) - 1
    MIN_INT_INDEX = -(2**53) + 1

    PARSER = Parser()

    def parse(self, query: str) -> JSONPathQuery:
        try:
            segments = self.PARSER.parse(Rule.JSONPATH, query)
        except PestParsingError as err:
            raise JSONPathSyntaxError(str(err)) from err

        return JSONPathQuery(
            [self.parse_segment(pair) for pair in segments if pair.name != "EOI"]
        )

    def parse_segment(self, segment: Pair) -> Segment:
        match segment:
            case Pair(Rule.CHILD_SEGMENT, [inner]):
                return ChildSegment(segment, self.parse_segment_inner(inner))
            case Pair(Rule.DESCENDANT_SEGMENT, [inner]):
                return RecursiveDescentSegment(segment, self.parse_segment_inner(inner))
            case Pair(Rule.NAME_SEGMENT, [inner]) | Pair(Rule.INDEX_SEGMENT, [inner]):
                return ChildSegment(segment, [self.parse_selector(inner)])
            case _:
                raise JSONPathSyntaxError("expected a segment", segment)

    def parse_segment_inner(self, inner: Pair) -> list[Selector]:
        match inner:
            case Pair(Rule.BRACKETED_SELECTION, selectors):
                return [self.parse_selector(selector) for selector in selectors]
            case Pair(Rule.WILDCARD_SELECTOR):
                return [WildcardSelector(inner)]
            case Pair(Rule.MEMBER_NAME_SHORTHAND):
                return [NameSelector(inner, inner.text)]
            case _:
                raise JSONPathSyntaxError(
                    "expected a shorthand selector or bracketed selection", inner
                )

    def parse_selector(self, selector: Pair) -> Selector:
        match selector:
            case Pair(Rule.DOUBLE_QUOTED):
                return NameSelector(
                    selector, unescape_string(selector.text, selector, '"')
                )
            case Pair(Rule.SINGLE_QUOTED):
                return NameSelector(
                    selector, unescape_string(selector.text, selector, "'")
                )
            case Pair(Rule.WILDCARD_SELECTOR):
                return WildcardSelector(selector)
            case Pair(Rule.SLICE_SELECTOR):
                return self.parse_slice_selector(selector)
            case Pair(Rule.INDEX_SELECTOR):
                return IndexSelector(
                    selector, self._i_json_int(selector, str(selector))
                )
            case Pair(Rule.FILTER_SELECTOR, [expression]):
                return FilterSelector(
                    selector,
                    FilterExpression(
                        selector,
                        self.parse_logical_or_expression(
                            expression, function_argument=False
                        ),
                    ),
                )
            case Pair(Rule.MEMBER_NAME_SHORTHAND):
                return NameSelector(selector, str(selector))
            case _:
                raise JSONPathSyntaxError("expected a selector", selector)

    def parse_slice_selector(self, selector: Pair) -> SliceSelector:
        start: int | None = None
        stop: int | None = None
        step: int | None = None

        for rule in selector:
            match rule.name:
                case Rule.START:
                    start = self._i_json_int(rule, rule.text)
                case Rule.STOP:
                    stop = self._i_json_int(rule, rule.text)
                case Rule.STEP:
                    step = self._i_json_int(rule, rule.text)
                case _:
                    raise JSONPathSyntaxError("expected a slice index", selector)

        return SliceSelector(selector, start, stop, step)

    def parse_logical_or_expression(
        self, expression: Pair, *, function_argument: bool
    ) -> Expression:
        it = iter(expression)
        or_expr: Expression = self.parse_logical_and_expression(
            next(it), function_argument=function_argument
        )
        for expr in it:
            right = self.parse_logical_and_expression(
                expr, function_argument=function_argument
            )
            or_expr = LogicalExpression(expr, or_expr, "||", right)
        return or_expr

    def parse_logical_and_expression(
        self, expression: Pair, *, function_argument: bool
    ) -> Expression:
        it = iter(expression)
        and_expr: Expression = self.parse_basic_expression(next(it))

        if not function_argument:
            # If this expression a function that returns a value type and
            # is not a function argument, it must be part of a comparison
            # expression.
            self._assert_compared(and_expr)

        for expr in it:
            right = self.parse_basic_expression(expr)
            if not function_argument:
                self._assert_compared(right)
            and_expr = LogicalExpression(expr, and_expr, "&&", right)
        return and_expr

    def parse_basic_expression(self, expression: Pair) -> Expression:
        match expression:
            case Pair(Rule.PAREN_EXPR, [not_expr, or_expr]):
                return PrefixExpression(
                    not_expr,
                    "!",
                    self.parse_logical_or_expression(or_expr, function_argument=False),
                )
            case Pair(Rule.PAREN_EXPR, [or_expr]):
                return self.parse_logical_or_expression(
                    or_expr, function_argument=False
                )
            case Pair(Rule.COMPARISON_EXPR, [left, op, right]):
                return ComparisonExpression(
                    expression,
                    self.parse_comparable(left),
                    op.text,
                    self.parse_comparable(right),
                )
            case Pair(Rule.TEST_EXPR, [not_expr, test_expr]):
                return PrefixExpression(
                    not_expr,
                    "!",
                    self.parse_test_expression(test_expr),
                )
            case Pair(Rule.TEST_EXPR, [test_expr]):
                return self.parse_test_expression(test_expr)
            case _:
                raise JSONPathSyntaxError("expected a basic expression", expression)

    def parse_test_expression(self, expression: Pair) -> Expression:
        match expression:
            case Pair(Rule.REL_QUERY, segments):
                return RelativeFilterQuery(
                    expression, JSONPathQuery([self.parse_segment(s) for s in segments])
                )
            case Pair(Rule.ROOT_QUERY, segments):
                return RootFilterQuery(
                    expression, JSONPathQuery([self.parse_segment(s) for s in segments])
                )
            case Pair(Rule.FUNCTION_EXPR, [name, *rest]):
                func = self.FUNCTION_EXTENSIONS[name.text]

                return FunctionExtension(
                    expression,
                    name.text,
                    self._assert_well_typed(
                        name,
                        name.text,
                        func,
                        [self.parse_function_argument(e) for e in rest],
                    ),
                    func,
                )
            case _:
                raise JSONPathSyntaxError("expected a test expression", expression)

    def parse_comparable(self, expression: Pair) -> Expression:
        match expression:
            case Pair(Rule.NUMBER):
                return self.parse_number(expression)
            case Pair(Rule.DOUBLE_QUOTED):
                return StringLiteral(
                    expression, unescape_string(expression.text, expression, '"')
                )
            case Pair(Rule.SINGLE_QUOTED):
                return StringLiteral(
                    expression, unescape_string(expression.text, expression, "'")
                )
            case Pair(Rule.TRUE_LITERAL):
                return BooleanLiteral(expression, value=True)
            case Pair(Rule.FALSE_LITERAL):
                return BooleanLiteral(expression, value=False)
            case Pair(Rule.NULL):
                return NullLiteral(expression, value=None)
            case Pair(Rule.REL_SINGULAR_QUERY, inner):
                return RelativeFilterQuery(
                    expression, JSONPathQuery([self.parse_segment(s) for s in inner])
                )
            case Pair(Rule.ABS_SINGULAR_QUERY, inner):
                return RootFilterQuery(
                    expression, JSONPathQuery([self.parse_segment(s) for s in inner])
                )
            case Pair(Rule.FUNCTION_EXPR, [name, *rest]):
                func = self.FUNCTION_EXTENSIONS[name.text]

                if func.return_type != ExpressionType.VALUE:
                    raise JSONPathTypeError(f"result of {name} is not comparable", name)

                return FunctionExtension(
                    expression,
                    name.text,
                    self._assert_well_typed(
                        name,
                        name.text,
                        func,
                        [self.parse_function_argument(e) for e in rest],
                    ),
                    func,
                )
            case _:
                raise JSONPathSyntaxError("expected a comparable", expression)

    def parse_number(self, expression: Pair) -> Expression:
        match expression:
            case Pair(Rule.NUMBER, []):
                return IntegerLiteral(expression, int(expression.text))
            case Pair(Rule.NUMBER, [Pair(Rule.INT)]):
                return IntegerLiteral(expression, int(expression.text))
            case Pair(Rule.NUMBER, [Pair(Rule.INT), Pair(Rule.FRAC)]):
                return FloatLiteral(expression, float(expression.text))
            case Pair(Rule.NUMBER, [Pair(Rule.INT), Pair(Rule.FRAC), Pair(Rule.EXP)]):
                return FloatLiteral(expression, float(expression.text))
            case Pair(Rule.NUMBER, [Pair(Rule.INT), Pair(Rule.EXP)]):
                if "-" in expression.children[-1].text:
                    return FloatLiteral(expression, float(expression.text))
                return IntegerLiteral(expression, int(float(expression.text)))
            case _:
                raise JSONPathSyntaxError("expected a number", expression)

    def parse_function_argument(self, expression: Pair) -> Expression:
        match expression:
            case Pair(Rule.NUMBER):
                return self.parse_number(expression)
            case Pair(Rule.DOUBLE_QUOTED):
                return StringLiteral(
                    expression, unescape_string(expression.text, expression, '"')
                )
            case Pair(Rule.SINGLE_QUOTED):
                return StringLiteral(
                    expression, unescape_string(expression.text, expression, "'")
                )
            case Pair(Rule.TRUE_LITERAL):
                return BooleanLiteral(expression, value=True)
            case Pair(Rule.FALSE_LITERAL):
                return BooleanLiteral(expression, value=False)
            case Pair(Rule.NULL):
                return NullLiteral(expression, value=None)
            case Pair(Rule.REL_QUERY, inner):
                return RelativeFilterQuery(
                    expression, JSONPathQuery([self.parse_segment(s) for s in inner])
                )
            case Pair(Rule.ROOT_QUERY, inner):
                return RootFilterQuery(
                    expression, JSONPathQuery([self.parse_segment(s) for s in inner])
                )
            case Pair(Rule.FUNCTION_EXPR, [name, *rest]):
                func = self.FUNCTION_EXTENSIONS[name.text]
                return FunctionExtension(
                    expression,
                    name.text,
                    self._assert_well_typed(
                        name,
                        name.text,
                        func,
                        [self.parse_function_argument(e) for e in rest],
                    ),
                    func,
                )
            case Pair(Rule.LOGICAL_OR_EXPR):
                return self.parse_logical_or_expression(
                    expression, function_argument=True
                )
            case Pair(Rule.LOGICAL_AND_EXPR):
                return self.parse_logical_and_expression(
                    expression, function_argument=True
                )
            case _:
                raise JSONPathSyntaxError("expected a function argument", expression)

    def _i_json_int(self, token: Pair, value: str | float) -> int:
        i = int(value)
        if i < self.MIN_INT_INDEX or i > self.MAX_INT_INDEX:
            raise JSONPathError("index out of range", token)
        return i

    def _assert_well_typed(
        self, token: Pair, name: str, func: FilterFunction, args: list[Expression]
    ) -> list[Expression]:
        # Correct number of arguments?
        if len(args) != len(func.arg_types):
            plural = "" if len(func.arg_types) == 1 else "s"
            raise JSONPathTypeError(
                f"{name}() requires {len(func.arg_types)} argument{plural}", token
            )

        # Argument types
        for idx, typ in enumerate(func.arg_types):
            arg = args[idx]
            if typ == ExpressionType.VALUE:
                if not (
                    isinstance(arg, FilterExpressionLiteral)
                    or (isinstance(arg, FilterQuery) and arg.query.singular_query())
                    or (self._function_return_type(arg) == ExpressionType.VALUE)
                ):
                    raise JSONPathTypeError(
                        f"{name}() argument {idx} must be of ValueType",
                        token=token,
                    )
            elif typ == ExpressionType.LOGICAL:
                if not isinstance(
                    arg, (FilterQuery, LogicalExpression, ComparisonExpression)
                ):
                    raise JSONPathTypeError(
                        f"{name}() argument {idx} must be of LogicalType",
                        token=token,
                    )
            elif typ == ExpressionType.NODES and not (
                isinstance(arg, FilterQuery)
                or self._function_return_type(arg) == ExpressionType.NODES
            ):
                raise JSONPathTypeError(
                    f"{name}() argument {idx} must be of NodesType",
                    token=token,
                )

        return args

    def _function_return_type(self, expr: Expression) -> ExpressionType | None:
        """Return a filter function's return type.

        Returns `None` if _expr_ is not a function expression.
        """
        if not isinstance(expr, FunctionExtension):
            return None
        func = self.FUNCTION_EXTENSIONS.get(expr.name)
        if isinstance(func, FilterFunction):
            return func.return_type
        return None

    def _assert_compared(self, expr: Expression) -> Expression:
        if (
            isinstance(expr, FunctionExtension)
            and expr.func.return_type == ExpressionType.VALUE
        ):
            raise JSONPathTypeError(f"result of {expr.name} must be compared", expr)
        return expr
