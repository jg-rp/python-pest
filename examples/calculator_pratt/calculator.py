"""Example Pratt parser for a calculator grammar.

The grammar, `./calculator.pest`, was copied from the pest book
(https://pest.rs/book/precedence.html) and modified to support simple
variables.

If running this from the root of the Python pest repo, use
`python -m examples.calculator_pratt`
"""

from math import factorial
from operator import add
from operator import floordiv
from operator import mul
from operator import neg
from operator import sub
from typing import ClassVar

from pest import Pair
from pest import PrattParser

from ._ast import Expression
from ._ast import InfixExpr
from ._ast import IntExpr
from ._ast import PostfixExpr
from ._ast import PrefixExpr
from ._ast import VarExpr

# ./parser.py is generated by ./generate.py. tests/test_calculator_example.py
# also regenerates ./parser.py before each test run.
from .parser import Rule
from .parser import parse


class CalculatorParser(PrattParser[Expression]):
    """Example Pratt parser for a calculator grammar."""

    PREFIX_OPS: ClassVar[dict[str, int]] = {Rule.NEG: 6}

    POSTFIX_OPS: ClassVar[dict[str, int]] = {Rule.FAC: 7}

    INFIX_OPS: ClassVar[dict[str, tuple[int, bool]]] = {
        Rule.ADD: (3, False),
        Rule.SUB: (3, False),
        Rule.MUL: (4, False),
        Rule.DIV: (4, False),
        Rule.POW: (5, True),
    }

    def parse(self, program: str) -> Expression:
        pairs = parse(Rule.PROGRAM, program)
        # TODO:

    def parse_primary(self, pair: Pair) -> Expression:
        match pair:
            case Pair(Rule.INT):
                return IntExpr(int(pair.text))
            case Pair(Rule.IDENT):
                return VarExpr(pair.text)
            case Pair(Rule.EXPR):
                return self.parse_expr(pair.stream())
            case _:
                raise SyntaxError(f"Unexpected {pair.text!r}")

    def parse_prefix(self, op: Pair, rhs: Expression) -> Expression:
        if op.rule.name == Rule.NEG:
            return PrefixExpr(neg, rhs)
        raise SyntaxError(f"Unknown prefix operator {op.text!r}")

    def parse_postfix(self, lhs: Expression, op: Pair) -> Expression:
        if op.rule.name == Rule.FAC:
            return PostfixExpr(factorial, lhs)
        raise SyntaxError(f"Unknown postfix operator {op.text!r}")

    def parse_infix(self, lhs: Expression, op: Pair, rhs: Expression) -> Expression:
        match op.rule.name:
            case Rule.ADD:
                return InfixExpr(add, lhs, rhs)
            case Rule.SUB:
                return InfixExpr(sub, lhs, rhs)
            case Rule.MUL:
                return InfixExpr(mul, lhs, rhs)
            case Rule.DIV:
                return InfixExpr(floordiv, lhs, rhs)
            case Rule.POW:
                return InfixExpr(pow, lhs, rhs)
            case _:
                raise SyntaxError(f"Unknown infix operator {op.text!r}")
