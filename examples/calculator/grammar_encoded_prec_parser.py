"""This file was generated by Python pest.

DO NOT EDIT THIS FILE BY HAND.
"""

from __future__ import annotations

from enum import StrEnum
from typing import TYPE_CHECKING

import regex as re

from pest.exceptions import PestParsingError
from pest.exceptions import error_context
from pest.grammar.codegen.state import RuleFrame
from pest.grammar.codegen.state import State
from pest.pairs import Pair
from pest.pairs import Pairs

if TYPE_CHECKING:
    from collections.abc import Callable

# ruff: noqa: D103 N802 N816 N806 PLR0912 PLR0915 PLR2004


class Rule(StrEnum):
    """Grammar rules."""

    EOI = "EOI"
    WHITESPACE = "WHITESPACE"
    PROGRAM = "program"
    EXPR = "expr"
    ADD_SUB = "add_sub"
    ADD_OP = "add_op"
    ADD = "add"
    SUB = "sub"
    MUL_DIV = "mul_div"
    MUL_OP = "mul_op"
    MUL = "mul"
    DIV = "div"
    POW_EXPR = "pow_expr"
    POW_OP = "pow_op"
    POW = "pow"
    PREFIX = "prefix"
    PREFIX_OP = "prefix_op"
    NEG = "neg"
    POSTFIX = "postfix"
    POSTFIX_OP = "postfix_op"
    FAC = "fac"
    PRIMARY = "primary"
    INT = "int"
    IDENT = "ident"


def _parse_EOI() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame("EOI", 0)

    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse EOI."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        if state.pos != len(state.input):
            matched = False
        else:
            matched = True
        state.rule_stack.pop()
        if state.tag_stack:
            tag3: str | None = state.tag_stack.pop()
        else:
            tag3 = None
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    children2,
                    tag3,
                )
            )
        return matched

    return inner


parse_EOI = _parse_EOI()


def _parse_WHITESPACE() -> Callable[[State, list[Pair]], bool]:
    RE3 = re.compile("(?:\\\r\\\n|[\\\t\\\n\\\r\\ ])", re.VERSION1)

    rule_frame = RuleFrame("WHITESPACE", 2)

    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse WHITESPACE."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <ChoiceRegex>
        if match := RE3.match(state.input, state.pos):
            state.pos = match.end()
            matched = True
        else:
            matched = False
        # </ChoiceRegex>
        state.rule_stack.pop()
        # Silent rule 'WHITESPACE'
        pairs.extend(children2)
        return matched

    return inner


parse_WHITESPACE = _parse_WHITESPACE()


def _parse_program() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame("program", 0)

    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse program."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=3>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            if state.pos == 0:
                matched3 = True
            else:
                matched3 = False
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Identifier>
            matched3 = parse_expr(state, children2)
            # </Identifier>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Identifier>
            matched3 = parse_EOI(state, children2)
            # </Identifier>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag5: str | None = state.tag_stack.pop()
        else:
            tag5 = None
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    children2,
                    tag5,
                )
            )
        return matched

    return inner


parse_program = _parse_program()


def _parse_expr() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame("expr", 0)

    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse expr."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Identifier>
        matched = parse_add_sub(state, children2)
        # </Identifier>
        state.rule_stack.pop()
        if state.tag_stack:
            tag3: str | None = state.tag_stack.pop()
        else:
            tag3 = None
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    children2,
                    tag3,
                )
            )
        return matched

    return inner


parse_expr = _parse_expr()


def _parse_add_sub() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame("add_sub", 0)

    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse add_sub."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=2>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            # <Identifier>
            matched3 = parse_mul_div(state, children2)
            # </Identifier>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Repeat>
            trivia_pos6 = state.pos
            children5: list[Pair] = []
            while True:
                state.checkpoint()
                # <Group>
                # <Sequence n=2>
                all_ok8 = True
                if all_ok8:
                    matched7 = False
                    # <Choice>
                    children9: list[Pair] = []
                    matched7 = False
                    if not matched7:
                        state.checkpoint()
                        # <Identifier>
                        matched7 = parse_add(state, children9)
                        # </Identifier>
                        if matched7:
                            state.ok()
                            children5.extend(children9)
                        else:
                            state.restore()
                            children9.clear()
                    if not matched7:
                        state.checkpoint()
                        # <Identifier>
                        matched7 = parse_sub(state, children9)
                        # </Identifier>
                        if matched7:
                            state.ok()
                            children5.extend(children9)
                        else:
                            state.restore()
                            children9.clear()
                    # </Choice>
                    if not matched7:
                        all_ok8 = False
                    if all_ok8:
                        parse_trivia(state, children5)
                if all_ok8:
                    matched7 = False
                    # <Identifier>
                    matched7 = parse_mul_div(state, children5)
                    # </Identifier>
                    if not matched7:
                        all_ok8 = False
                matched3 = all_ok8
                # </Sequence>
                # </Group>
                if matched3:
                    state.ok()
                    children2.extend(children5)
                    children5.clear()
                    trivia_pos6 = state.pos
                    parse_trivia(state, children5)
                else:
                    state.restore()
                    state.pos = trivia_pos6
                    matched3 = True
                    break
            # </Repeat>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag10: str | None = state.tag_stack.pop()
        else:
            tag10 = None
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    children2,
                    tag10,
                )
            )
        return matched

    return inner


parse_add_sub = _parse_add_sub()


def _parse_add_op() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame("add_op", 2)

    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse add_op."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Choice>
        children3: list[Pair] = []
        matched = False
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_add(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_sub(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        # </Choice>
        state.rule_stack.pop()
        # Silent rule 'add_op'
        pairs.extend(children2)
        return matched

    return inner


parse_add_op = _parse_add_op()


def _parse_add() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame("add", 0)

    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse add."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <String>
        if state.input.startswith("+", state.pos):
            state.pos += 1
            matched = True
        else:
            matched = False
            state.fail('"+"')
        # </String>
        state.rule_stack.pop()
        if state.tag_stack:
            tag3: str | None = state.tag_stack.pop()
        else:
            tag3 = None
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    children2,
                    tag3,
                )
            )
        return matched

    return inner


parse_add = _parse_add()


def _parse_sub() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame("sub", 0)

    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse sub."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <String>
        if state.input.startswith("-", state.pos):
            state.pos += 1
            matched = True
        else:
            matched = False
            state.fail('"-"')
        # </String>
        state.rule_stack.pop()
        if state.tag_stack:
            tag3: str | None = state.tag_stack.pop()
        else:
            tag3 = None
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    children2,
                    tag3,
                )
            )
        return matched

    return inner


parse_sub = _parse_sub()


def _parse_mul_div() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame("mul_div", 0)

    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse mul_div."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=2>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            # <Identifier>
            matched3 = parse_pow_expr(state, children2)
            # </Identifier>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Repeat>
            trivia_pos6 = state.pos
            children5: list[Pair] = []
            while True:
                state.checkpoint()
                # <Group>
                # <Sequence n=2>
                all_ok8 = True
                if all_ok8:
                    matched7 = False
                    # <Choice>
                    children9: list[Pair] = []
                    matched7 = False
                    if not matched7:
                        state.checkpoint()
                        # <Identifier>
                        matched7 = parse_mul(state, children9)
                        # </Identifier>
                        if matched7:
                            state.ok()
                            children5.extend(children9)
                        else:
                            state.restore()
                            children9.clear()
                    if not matched7:
                        state.checkpoint()
                        # <Identifier>
                        matched7 = parse_div(state, children9)
                        # </Identifier>
                        if matched7:
                            state.ok()
                            children5.extend(children9)
                        else:
                            state.restore()
                            children9.clear()
                    # </Choice>
                    if not matched7:
                        all_ok8 = False
                    if all_ok8:
                        parse_trivia(state, children5)
                if all_ok8:
                    matched7 = False
                    # <Identifier>
                    matched7 = parse_pow_expr(state, children5)
                    # </Identifier>
                    if not matched7:
                        all_ok8 = False
                matched3 = all_ok8
                # </Sequence>
                # </Group>
                if matched3:
                    state.ok()
                    children2.extend(children5)
                    children5.clear()
                    trivia_pos6 = state.pos
                    parse_trivia(state, children5)
                else:
                    state.restore()
                    state.pos = trivia_pos6
                    matched3 = True
                    break
            # </Repeat>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag10: str | None = state.tag_stack.pop()
        else:
            tag10 = None
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    children2,
                    tag10,
                )
            )
        return matched

    return inner


parse_mul_div = _parse_mul_div()


def _parse_mul_op() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame("mul_op", 2)

    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse mul_op."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Choice>
        children3: list[Pair] = []
        matched = False
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_mul(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_div(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        # </Choice>
        state.rule_stack.pop()
        # Silent rule 'mul_op'
        pairs.extend(children2)
        return matched

    return inner


parse_mul_op = _parse_mul_op()


def _parse_mul() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame("mul", 0)

    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse mul."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <String>
        if state.input.startswith("*", state.pos):
            state.pos += 1
            matched = True
        else:
            matched = False
            state.fail('"*"')
        # </String>
        state.rule_stack.pop()
        if state.tag_stack:
            tag3: str | None = state.tag_stack.pop()
        else:
            tag3 = None
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    children2,
                    tag3,
                )
            )
        return matched

    return inner


parse_mul = _parse_mul()


def _parse_div() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame("div", 0)

    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse div."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <String>
        if state.input.startswith("/", state.pos):
            state.pos += 1
            matched = True
        else:
            matched = False
            state.fail('"/"')
        # </String>
        state.rule_stack.pop()
        if state.tag_stack:
            tag3: str | None = state.tag_stack.pop()
        else:
            tag3 = None
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    children2,
                    tag3,
                )
            )
        return matched

    return inner


parse_div = _parse_div()


def _parse_pow_expr() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame("pow_expr", 0)

    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse pow_expr."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=2>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            # <Identifier>
            matched3 = parse_prefix(state, children2)
            # </Identifier>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Repeat>
            trivia_pos6 = state.pos
            children5: list[Pair] = []
            while True:
                state.checkpoint()
                # <Group>
                # <Sequence n=2>
                all_ok8 = True
                if all_ok8:
                    matched7 = False
                    # <Identifier>
                    matched7 = parse_pow(state, children5)
                    # </Identifier>
                    if not matched7:
                        all_ok8 = False
                    if all_ok8:
                        parse_trivia(state, children5)
                if all_ok8:
                    matched7 = False
                    # <Identifier>
                    matched7 = parse_prefix(state, children5)
                    # </Identifier>
                    if not matched7:
                        all_ok8 = False
                matched3 = all_ok8
                # </Sequence>
                # </Group>
                if matched3:
                    state.ok()
                    children2.extend(children5)
                    children5.clear()
                    trivia_pos6 = state.pos
                    parse_trivia(state, children5)
                else:
                    state.restore()
                    state.pos = trivia_pos6
                    matched3 = True
                    break
            # </Repeat>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag9: str | None = state.tag_stack.pop()
        else:
            tag9 = None
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    children2,
                    tag9,
                )
            )
        return matched

    return inner


parse_pow_expr = _parse_pow_expr()


def _parse_pow_op() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame("pow_op", 2)

    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse pow_op."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Identifier>
        matched = parse_pow(state, children2)
        # </Identifier>
        state.rule_stack.pop()
        # Silent rule 'pow_op'
        pairs.extend(children2)
        return matched

    return inner


parse_pow_op = _parse_pow_op()


def _parse_pow() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame("pow", 0)

    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse pow."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <String>
        if state.input.startswith("^", state.pos):
            state.pos += 1
            matched = True
        else:
            matched = False
            state.fail('"^"')
        # </String>
        state.rule_stack.pop()
        if state.tag_stack:
            tag3: str | None = state.tag_stack.pop()
        else:
            tag3 = None
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    children2,
                    tag3,
                )
            )
        return matched

    return inner


parse_pow = _parse_pow()


def _parse_prefix() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame("prefix", 0)

    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse prefix."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=2>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            # <Repeat>
            trivia_pos6 = state.pos
            children5: list[Pair] = []
            while True:
                state.checkpoint()
                # <Identifier>
                matched3 = parse_neg(state, children5)
                # </Identifier>
                if matched3:
                    state.ok()
                    children2.extend(children5)
                    children5.clear()
                    trivia_pos6 = state.pos
                    parse_trivia(state, children5)
                else:
                    state.restore()
                    state.pos = trivia_pos6
                    matched3 = True
                    break
            # </Repeat>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Identifier>
            matched3 = parse_postfix(state, children2)
            # </Identifier>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag7: str | None = state.tag_stack.pop()
        else:
            tag7 = None
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    children2,
                    tag7,
                )
            )
        return matched

    return inner


parse_prefix = _parse_prefix()


def _parse_prefix_op() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame("prefix_op", 2)

    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse prefix_op."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Identifier>
        matched = parse_neg(state, children2)
        # </Identifier>
        state.rule_stack.pop()
        # Silent rule 'prefix_op'
        pairs.extend(children2)
        return matched

    return inner


parse_prefix_op = _parse_prefix_op()


def _parse_neg() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame("neg", 0)

    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse neg."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <String>
        if state.input.startswith("-", state.pos):
            state.pos += 1
            matched = True
        else:
            matched = False
            state.fail('"-"')
        # </String>
        state.rule_stack.pop()
        if state.tag_stack:
            tag3: str | None = state.tag_stack.pop()
        else:
            tag3 = None
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    children2,
                    tag3,
                )
            )
        return matched

    return inner


parse_neg = _parse_neg()


def _parse_postfix() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame("postfix", 0)

    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse postfix."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=2>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            # <Choice>
            children5: list[Pair] = []
            matched3 = False
            if not matched3:
                state.checkpoint()
                # <Identifier>
                matched3 = parse_int(state, children5)
                # </Identifier>
                if matched3:
                    state.ok()
                    children2.extend(children5)
                else:
                    state.restore()
                    children5.clear()
            if not matched3:
                state.checkpoint()
                # <Identifier>
                matched3 = parse_ident(state, children5)
                # </Identifier>
                if matched3:
                    state.ok()
                    children2.extend(children5)
                else:
                    state.restore()
                    children5.clear()
            if not matched3:
                state.checkpoint()
                # <Sequence n=3>
                all_ok7 = True
                if all_ok7:
                    matched6 = False
                    # <String>
                    if state.input.startswith("(", state.pos):
                        state.pos += 1
                        matched6 = True
                    else:
                        matched6 = False
                        state.fail('"("')
                    # </String>
                    if not matched6:
                        all_ok7 = False
                    if all_ok7:
                        parse_trivia(state, children5)
                if all_ok7:
                    matched6 = False
                    # <Identifier>
                    matched6 = parse_expr(state, children5)
                    # </Identifier>
                    if not matched6:
                        all_ok7 = False
                    if all_ok7:
                        parse_trivia(state, children5)
                if all_ok7:
                    matched6 = False
                    # <String>
                    if state.input.startswith(")", state.pos):
                        state.pos += 1
                        matched6 = True
                    else:
                        matched6 = False
                        state.fail('")"')
                    # </String>
                    if not matched6:
                        all_ok7 = False
                matched3 = all_ok7
                # </Sequence>
                if matched3:
                    state.ok()
                    children2.extend(children5)
                else:
                    state.restore()
                    children5.clear()
            # </Choice>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Repeat>
            trivia_pos9 = state.pos
            children8: list[Pair] = []
            while True:
                state.checkpoint()
                # <Identifier>
                matched3 = parse_fac(state, children8)
                # </Identifier>
                if matched3:
                    state.ok()
                    children2.extend(children8)
                    children8.clear()
                    trivia_pos9 = state.pos
                    parse_trivia(state, children8)
                else:
                    state.restore()
                    state.pos = trivia_pos9
                    matched3 = True
                    break
            # </Repeat>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag10: str | None = state.tag_stack.pop()
        else:
            tag10 = None
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    children2,
                    tag10,
                )
            )
        return matched

    return inner


parse_postfix = _parse_postfix()


def _parse_postfix_op() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame("postfix_op", 2)

    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse postfix_op."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Identifier>
        matched = parse_fac(state, children2)
        # </Identifier>
        state.rule_stack.pop()
        # Silent rule 'postfix_op'
        pairs.extend(children2)
        return matched

    return inner


parse_postfix_op = _parse_postfix_op()


def _parse_fac() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame("fac", 0)

    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse fac."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <String>
        if state.input.startswith("!", state.pos):
            state.pos += 1
            matched = True
        else:
            matched = False
            state.fail('"!"')
        # </String>
        state.rule_stack.pop()
        if state.tag_stack:
            tag3: str | None = state.tag_stack.pop()
        else:
            tag3 = None
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    children2,
                    tag3,
                )
            )
        return matched

    return inner


parse_fac = _parse_fac()


def _parse_primary() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame("primary", 2)

    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse primary."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Choice>
        children3: list[Pair] = []
        matched = False
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_int(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_ident(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Sequence n=3>
            all_ok5 = True
            if all_ok5:
                matched4 = False
                # <String>
                if state.input.startswith("(", state.pos):
                    state.pos += 1
                    matched4 = True
                else:
                    matched4 = False
                    state.fail('"("')
                # </String>
                if not matched4:
                    all_ok5 = False
                if all_ok5:
                    parse_trivia(state, children3)
            if all_ok5:
                matched4 = False
                # <Identifier>
                matched4 = parse_expr(state, children3)
                # </Identifier>
                if not matched4:
                    all_ok5 = False
                if all_ok5:
                    parse_trivia(state, children3)
            if all_ok5:
                matched4 = False
                # <String>
                if state.input.startswith(")", state.pos):
                    state.pos += 1
                    matched4 = True
                else:
                    matched4 = False
                    state.fail('")"')
                # </String>
                if not matched4:
                    all_ok5 = False
            matched = all_ok5
            # </Sequence>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        # </Choice>
        state.rule_stack.pop()
        # Silent rule 'primary'
        pairs.extend(children2)
        return matched

    return inner


parse_primary = _parse_primary()


def _parse_int() -> Callable[[State, list[Pair]], bool]:
    RE6 = re.compile("[1-9]", re.I)
    RE9 = re.compile("[0-9]", re.I)
    RE12 = re.compile("[0-9]", re.I)
    RE13 = re.compile("[0-9]", re.I)

    rule_frame = RuleFrame("int", 4)

    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse int."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        with state.atomic_checkpoint():
            state.atomic_depth += 1
            # <Group>
            # <Choice>
            children3: list[Pair] = []
            matched = False
            if not matched:
                state.checkpoint()
                # <Sequence n=2>
                all_ok5 = True
                if all_ok5:
                    matched4 = False
                    # <Range>
                    if match := RE6.match(state.input, state.pos):
                        state.pos = match.end()
                        matched4 = True
                    else:
                        matched4 = False
                        state.fail("''1''..''9''")
                    # </Range>
                    if not matched4:
                        all_ok5 = False
                    if all_ok5:
                        parse_trivia(state, children3)
                if all_ok5:
                    matched4 = False
                    # <Sequence n=2>
                    all_ok8 = True
                    if all_ok8:
                        matched7 = False
                        # <Range>
                        if match := RE9.match(state.input, state.pos):
                            state.pos = match.end()
                            matched7 = True
                        else:
                            matched7 = False
                            state.fail("''0''..''9''")
                        # </Range>
                        if not matched7:
                            all_ok8 = False
                        if all_ok8:
                            parse_trivia(state, children3)
                    if all_ok8:
                        matched7 = False
                        # <Repeat>
                        trivia_pos11 = state.pos
                        children10: list[Pair] = []
                        while True:
                            state.checkpoint()
                            # <Range>
                            if match := RE12.match(state.input, state.pos):
                                state.pos = match.end()
                                matched7 = True
                            else:
                                matched7 = False
                                state.fail("''0''..''9''")
                            # </Range>
                            if matched7:
                                state.ok()
                                children3.extend(children10)
                                children10.clear()
                                trivia_pos11 = state.pos
                                parse_trivia(state, children10)
                            else:
                                state.restore()
                                state.pos = trivia_pos11
                                matched7 = True
                                break
                        # </Repeat>
                        if not matched7:
                            all_ok8 = False
                    matched4 = all_ok8
                    # </Sequence>
                    if not matched4:
                        all_ok5 = False
                matched = all_ok5
                # </Sequence>
                if matched:
                    state.ok()
                    children2.extend(children3)
                else:
                    state.restore()
                    children3.clear()
            if not matched:
                state.checkpoint()
                # <Range>
                if match := RE13.match(state.input, state.pos):
                    state.pos = match.end()
                    matched = True
                else:
                    matched = False
                    state.fail("''0''..''9''")
                # </Range>
                if matched:
                    state.ok()
                    children2.extend(children3)
                else:
                    state.restore()
                    children3.clear()
            # </Choice>
            # </Group>
        state.rule_stack.pop()
        if state.tag_stack:
            tag14: str | None = state.tag_stack.pop()
        else:
            tag14 = None
        # Atomic rule: 'int'
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    [],
                    tag14,
                )
            )
        return matched

    return inner


parse_int = _parse_int()


def _parse_ident() -> Callable[[State, list[Pair]], bool]:
    RE5 = re.compile("[A-Za-z]", re.VERSION1)
    RE8 = re.compile("[A-Za-z]", re.VERSION1)

    rule_frame = RuleFrame("ident", 4)

    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse ident."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        with state.atomic_checkpoint():
            state.atomic_depth += 1
            # <Sequence n=2>
            all_ok4 = True
            if all_ok4:
                matched3 = False
                # <ChoiceRegex>
                if match := RE5.match(state.input, state.pos):
                    state.pos = match.end()
                    matched3 = True
                else:
                    matched3 = False
                # </ChoiceRegex>
                if not matched3:
                    all_ok4 = False
                if all_ok4:
                    parse_trivia(state, children2)
            if all_ok4:
                matched3 = False
                # <Repeat>
                trivia_pos7 = state.pos
                children6: list[Pair] = []
                while True:
                    state.checkpoint()
                    # <ChoiceRegex>
                    if match := RE8.match(state.input, state.pos):
                        state.pos = match.end()
                        matched3 = True
                    else:
                        matched3 = False
                    # </ChoiceRegex>
                    if matched3:
                        state.ok()
                        children2.extend(children6)
                        children6.clear()
                        trivia_pos7 = state.pos
                        parse_trivia(state, children6)
                    else:
                        state.restore()
                        state.pos = trivia_pos7
                        matched3 = True
                        break
                # </Repeat>
                if not matched3:
                    all_ok4 = False
            matched = all_ok4
            # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag9: str | None = state.tag_stack.pop()
        else:
            tag9 = None
        # Atomic rule: 'ident'
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    [],
                    tag9,
                )
            )
        return matched

    return inner


parse_ident = _parse_ident()


def parse_trivia(state: State, pairs: list[Pair]) -> bool:
    if state.atomic_depth > 0:
        return True
    while True:
        state.checkpoint()
        matched = False
        matched = parse_WHITESPACE(state, pairs)
        if matched:
            state.ok()
            continue
        else:
            state.restore()
        if not matched:
            break
    return True


_RULE_MAP: dict[str, Callable[[State, list[Pair]], bool]] = {
    "EOI": parse_EOI,
    "WHITESPACE": parse_WHITESPACE,
    "program": parse_program,
    "expr": parse_expr,
    "add_sub": parse_add_sub,
    "add_op": parse_add_op,
    "add": parse_add,
    "sub": parse_sub,
    "mul_div": parse_mul_div,
    "mul_op": parse_mul_op,
    "mul": parse_mul,
    "div": parse_div,
    "pow_expr": parse_pow_expr,
    "pow_op": parse_pow_op,
    "pow": parse_pow,
    "prefix": parse_prefix,
    "prefix_op": parse_prefix_op,
    "neg": parse_neg,
    "postfix": parse_postfix,
    "postfix_op": parse_postfix_op,
    "fac": parse_fac,
    "primary": parse_primary,
    "int": parse_int,
    "ident": parse_ident,
}


def parse(start_rule: str, input_: str, *, start_pos: int = 0) -> Pairs:
    """Parse `input_` starting from `rule`."""
    state = State(input_, start_pos)
    pairs: list[Pair] = []
    matched = _RULE_MAP[start_rule](state, pairs)
    if matched:
        return Pairs(pairs)
    raise PestParsingError(
        state.furthest_stack,
        list(state.furthest_expected),
        [],
        state.furthest_pos,
        *error_context(state.input, state.furthest_pos),
    )
