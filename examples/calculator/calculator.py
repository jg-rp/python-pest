"""Example precedence climbing parser for a calculator grammar.

If running this from the root of the Python pest repo, use
`python -m examples.calculator`
"""

from enum import IntEnum
from math import factorial
from operator import add
from operator import floordiv
from operator import mul
from operator import neg
from operator import sub

from pest import Pair

from ._ast import Expression
from ._ast import InfixExpr
from ._ast import IntExpr
from ._ast import PostfixExpr
from ._ast import PrefixExpr
from ._ast import VarExpr

# ./parser.py is generated by ./generate.py
from .parser import Rule
from .parser import parse


class Precedence(IntEnum):
    """Operator precedence."""

    LOWEST = 1
    ADD_SUB = 3
    MUL_DIV = 4
    POW = 5
    FAC = 7


PRECEDENCES: dict[str, int] = {
    Rule.ADD: Precedence.ADD_SUB,
    Rule.SUB: Precedence.ADD_SUB,
    Rule.MUL: Precedence.MUL_DIV,
    Rule.DIV: Precedence.MUL_DIV,
    Rule.POW: Precedence.POW,
    Rule.FAC: Precedence.FAC,
}

INFIX_OPERATORS = frozenset(
    [
        Rule.ADD,
        Rule.SUB,
        Rule.MUL,
        Rule.DIV,
        Rule.POW,
    ]
)

PREFIX_OPERATORS = frozenset(
    [
        Rule.NEG,
    ]
)

POSTFIX_OPERATORS = frozenset(
    [
        Rule.FAC,
    ]
)


class CalculatorSyntaxError(Exception):
    """Exception raised when there is a syntax error."""


# TODO: build this into `pest.Pairs`
class Pairs:
    def __init__(self, pairs: list[Pair]):
        self.pos = 0
        self.pairs = pairs

    def next(self) -> Pair | None:
        if self.pos < len(self.pairs):
            pair = self.pairs[self.pos]
            self.pos += 1
            return pair
        return None

    def backup(self) -> None:
        self.pos -= 1


def parse_expr(pairs: Pairs, precedence: int = Precedence.LOWEST) -> Expression:
    """Parse an expression from a stream of pest Pairs, handling operator precedence.

    This function implements a precedence-climbing parser. It recursively
    parses subexpressions based on the current precedence level.
    """
    pair = pairs.next()

    if pair is None:
        raise CalculatorSyntaxError("unexpected end of expression")

    # Parse the left-hand side (the "prefix" part)
    #
    # If we see a prefix operator (e.g. unary minus), handle that first.
    # Otherwise, parse a primary expression (number or parenthesized expression).
    if pair.name in PREFIX_OPERATORS:
        left: Expression = parse_prefix_expression(pair, pairs)
    else:
        left = parse_primary(pair)

    pair = pairs.next()

    # Handle infix operators (e.g. +, -, *, /, ^)
    #
    # This is the heart of "precedence climbing". Operators of higher precedence
    # trigger deeper recursion. Lower-precedence operators end the current level.
    while pair and pair.name in INFIX_OPERATORS:
        if PRECEDENCES.get(pair.name, Precedence.LOWEST) >= precedence:
            left = parse_infix_expression(pair, pairs, left)
            pair = pairs.next()
        else:
            # Put the pair back so it can be processed by the caller
            pairs.backup()
            return left

    # Handle postfix operators (e.g. factorial)
    #
    # Postfix operators bind *tighter* than infix ones, so we handle them after
    # finishing all infix climbing. Each postfix operator simply wraps the current
    # expression node.
    while pair and pair.name in POSTFIX_OPERATORS:
        left = parse_postfix_expression(pair, left)
        pair = pairs.next()

    if not pair or pair.name == Rule.EOI:
        return left

    raise CalculatorSyntaxError(f"unexpected {pair.text!r}")


def parse_prefix_expression(pair: Pair, pairs: Pairs) -> PrefixExpr:
    right = pairs.next()

    if right is None:
        raise CalculatorSyntaxError("unexpected end of expression")

    if pair.name == Rule.NEG:
        return PrefixExpr(neg, parse_primary(right))

    raise CalculatorSyntaxError(f"unknown prefix operator {pair.text!r}")


def parse_infix_expression(op: Pair, pairs: Pairs, left: Expression) -> InfixExpr:
    precedence = PRECEDENCES.get(op.rule.name, Precedence.LOWEST)
    right = parse_expr(pairs, precedence)

    match op:
        case Pair(Rule.ADD):
            return InfixExpr(add, left, right)
        case Pair(Rule.SUB):
            return InfixExpr(sub, left, right)
        case Pair(Rule.MUL):
            return InfixExpr(mul, left, right)
        case Pair(Rule.DIV):
            return InfixExpr(floordiv, left, right)
        case Pair(Rule.POW):
            return InfixExpr(pow, left, right)
        case _:
            raise CalculatorSyntaxError(f"unknown infix operator {op.text!r}")


def parse_postfix_expression(op: Pair, left: Expression) -> PostfixExpr:
    if op.rule.name == Rule.FAC:
        return PostfixExpr(factorial, left)

    raise CalculatorSyntaxError(f"unknown postfix operator {op.text!r}")


def parse_primary(pair: Pair) -> Expression:
    match pair:
        case Pair(Rule.INT):
            return IntExpr(int(pair.text))
        case Pair(Rule.IDENT):
            return VarExpr(pair.text)
        case Pair(Rule.EXPR):
            return parse_expr(Pairs(pair.children))
        case _:
            raise CalculatorSyntaxError(f"unexpected {pair.text!r}")


def main() -> None:
    # TODO: get expression from stdin
    # TODO: wrap PestParsingError
    pairs = parse(Rule.PROGRAM, "0")
    expr = parse_expr(Pairs(pairs.first().inner().first().children))
    print(expr.evaluate({"x": 42}))


if __name__ == "__main__":
    main()
