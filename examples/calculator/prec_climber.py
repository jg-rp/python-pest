"""Example precedence climbing parser for a calculator grammar.

The grammar, `./calculator.pest`, was copied from the pest book
(https://pest.rs/book/precedence.html) and modified to support simple
variables.

Example:
    pairs = parse(Rule.PROGRAM, "1 + 2 + x")
    prog = parse_program(pairs)
    print(prog.evaluate({"x": 42}))  # 45

If running this from the root of the Python pest repo, use
`python -m examples.calculator`
"""

from enum import IntEnum
from math import factorial
from operator import add
from operator import floordiv
from operator import mul
from operator import neg
from operator import sub

from pest import Pair
from pest import Pairs
from pest import Stream

from ._ast import Expression
from ._ast import InfixExpr
from ._ast import IntExpr
from ._ast import PostfixExpr
from ._ast import PrefixExpr
from ._ast import VarExpr

# ./parser.py is generated by ./generate.py. tests/test_calculator_examples.py
# also regenerates ./parser.py before each test run.
from .parser import Rule
from .parser import parse


class Precedence(IntEnum):
    """Operator precedence."""

    LOWEST = 1
    ADD = 3
    SUB = 3
    MUL = 4
    DIV = 4
    POW = 5
    FAC = 7
    PRE = 8


PRECEDENCES: dict[str, int] = {
    Rule.ADD: Precedence.ADD,
    Rule.SUB: Precedence.SUB,
    Rule.MUL: Precedence.MUL,
    Rule.DIV: Precedence.DIV,
    Rule.POW: Precedence.POW,
    Rule.FAC: Precedence.FAC,
}

INFIX_OPERATORS = frozenset(
    [
        Rule.ADD,
        Rule.SUB,
        Rule.MUL,
        Rule.DIV,
        Rule.POW,
    ]
)

PREFIX_OPERATORS = frozenset(
    [
        Rule.NEG,
    ]
)

POSTFIX_OPERATORS = frozenset(
    [
        Rule.FAC,
    ]
)


class CalculatorSyntaxError(Exception):
    """Exception raised when there is a syntax error in our calculator grammar."""


def parse_program(program: Pairs) -> Expression:
    """Entry point for parsing tokens from our calculator grammar.

    Unwraps top-level `program` and `expr` token pairs. For the example
    program `1 + 2`, we expect this token tree structure.

    ```
    [{'rule': 'program',
    'span': {'str': '1 + 2', 'start': 0, 'end': 5},
    'inner': [{'rule': 'expr',
                'span': {'str': '1 + 2', 'start': 0, 'end': 5},
                'inner': [{'rule': 'int',
                            'span': {'str': '1', 'start': 0, 'end': 1},
                            'inner': []},
                        {'rule': 'add',
                            'span': {'str': '+', 'start': 2, 'end': 3},
                            'inner': []},
                        {'rule': 'int',
                            'span': {'str': '2', 'start': 4, 'end': 5},
                            'inner': []}]},
                {'rule': 'EOI',
                'span': {'str': '', 'start': 5, 'end': 5},
                'inner': []}]}]
    ```
    """
    # A successful pest parse with our grammar guarantees root pairs contain
    # exactly one child and that child was parsed with the `program` rule.
    assert len(program) == 1
    assert program[0].name == "program"

    # We unwrap the program token pair and get its child token pairs.
    pairs = program.first().inner()

    # Similarly, our grammar guarantees there's exactly two children for the
    # top-level program. One `expr` and one `EOI`.
    assert len(pairs) == 2  # noqa: PLR2004
    assert pairs[0].name == "expr"
    assert pairs[1].name == "EOI"

    # We only need the inner `expr` child. All these assertions are strictly
    # unnecessary. A `PestParsingError` would have been raised before reaching
    # this function if the input was not valid.
    expr = pairs.first()

    # Finally we pass children of the top-level expression to `parse_expr` as
    # a stream of inner token pairs. A stream lets us step through token pairs
    # and peek ahead if needed.
    return parse_expr(expr.stream())


def parse_expr(pairs: Stream, precedence: int = Precedence.LOWEST) -> Expression:
    """Parse an expression from a stream of pest Pairs, handling operator precedence.

    This function implements a precedence-climbing parser. It recursively
    parses subexpressions based on the current precedence level.
    """
    pair = pairs.next()

    if pair is None:
        raise CalculatorSyntaxError("unexpected end of expression")

    # Parse the left-hand side (the "prefix" part)
    #
    # If we see a prefix operator (e.g. unary minus), handle that first.
    # Otherwise, parse a primary expression (number or parenthesized expression).
    if pair.name in PREFIX_OPERATORS:
        left: Expression = parse_prefix_expression(pair, pairs)
    else:
        left = parse_primary(pair)

    pair = pairs.next()

    # Handle infix operators (e.g. +, -, *, /, ^)
    #
    # This is the heart of "precedence climbing". Operators of higher precedence
    # trigger deeper recursion. Lower-precedence operators end the current level.
    while pair and pair.name in INFIX_OPERATORS:
        if PRECEDENCES.get(pair.name, Precedence.LOWEST) >= precedence:
            left = parse_infix_expression(pair, pairs, left)
            pair = pairs.next()
        else:
            # Put the pair back so it can be processed by the caller
            pairs.backup()
            return left

    # Handle postfix operators (e.g. factorial)
    #
    # Postfix operators bind *tighter* than infix ones, so we handle them after
    # finishing all infix climbing. Each postfix operator simply wraps the current
    # expression node.
    while pair and pair.name in POSTFIX_OPERATORS:
        left = parse_postfix_expression(pair, left)
        pair = pairs.next()

    if not pair or pair.name == Rule.EOI:
        return left

    raise CalculatorSyntaxError(f"unexpected {pair.text!r}")


def parse_prefix_expression(pair: Pair, pairs: Stream) -> PrefixExpr:
    if pair.name == Rule.NEG:
        return PrefixExpr(neg, parse_expr(pairs, Precedence.PRE))

    raise CalculatorSyntaxError(f"unknown prefix operator {pair.text!r}")


def parse_infix_expression(op: Pair, pairs: Stream, left: Expression) -> InfixExpr:
    precedence = PRECEDENCES.get(op.rule.name, Precedence.LOWEST)
    right = parse_expr(pairs, precedence)

    match op:
        case Pair(Rule.ADD):
            return InfixExpr(add, left, right)
        case Pair(Rule.SUB):
            return InfixExpr(sub, left, right)
        case Pair(Rule.MUL):
            return InfixExpr(mul, left, right)
        case Pair(Rule.DIV):
            return InfixExpr(floordiv, left, right)
        case Pair(Rule.POW):
            return InfixExpr(pow, left, right)
        case _:
            raise CalculatorSyntaxError(f"unknown infix operator {op.text!r}")


def parse_postfix_expression(op: Pair, left: Expression) -> PostfixExpr:
    if op.rule.name == Rule.FAC:
        return PostfixExpr(factorial, left)

    raise CalculatorSyntaxError(f"unknown postfix operator {op.text!r}")


def parse_primary(pair: Pair) -> Expression:
    match pair:
        case Pair(Rule.INT):
            return IntExpr(int(pair.text))
        case Pair(Rule.IDENT):
            return VarExpr(pair.text)
        case Pair(Rule.EXPR):
            return parse_expr(pair.inner().stream())
        case _:
            raise CalculatorSyntaxError(f"unexpected {pair.text!r}")


def example() -> None:
    pairs = parse(Rule.PROGRAM, "1 + 2 + x")
    prog = parse_program(pairs)
    print(prog.evaluate({"x": 42}))  # noqa: T201


if __name__ == "__main__":
    example()
