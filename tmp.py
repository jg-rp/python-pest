"""This file was generated by Python pest.

DO NOT EDIT THIS FILE BY HAND.
"""

from __future__ import annotations

from enum import StrEnum
from enum import auto
from typing import TYPE_CHECKING

import regex as re

from pest.grammar.codegen.state import ParseError
from pest.grammar.codegen.state import RuleFrame
from pest.grammar.codegen.state import State
from pest.pairs import Pair
from pest.pairs import Pairs

if TYPE_CHECKING:
    from collections.abc import Callable

# ruff: noqa: D103 N802 N816 N806 PLR0912 PLR0915


class Rule(StrEnum):
    """Grammar rules."""
    EOI = auto()
    ITEM = auto()
    LISTS = auto()
    LINES = auto()
    TOP_FIRST = auto()
    TOP_CONTINUE = auto()
    INDENTATION = auto()
    CHILDREN = auto()

def _parse_EOI() -> Callable[[State], Pairs]:
    rule_frame = RuleFrame('EOI', 0)
    
    def inner(state: State) -> Pairs:
        """Parse EOI."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        pairs: list[Pair] = []
        if state.pos != len(state.input):
            raise ParseError('expected end of input')
        state.rule_stack.pop()
        state.atomic_depth.restore()
        return Pairs([Pair(state.input, pos1, state.pos, rule_frame, pairs,)])
    
    return inner
    
parse_EOI = _parse_EOI()

def _parse_item() -> Callable[[State], Pairs]:
    rule_frame = RuleFrame('item', 0)
    
    def inner(state: State) -> Pairs:
        """Parse item."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        pairs: list[Pair] = []
        # Repeat: match as many occurrences as we can
        trivia_pos3 = state.pos
        children2: list[Pair] = []
        while True:
            state.checkpoint()
            try:
                # Sequence
                # NegativePredicate: !expression
                children4: list[Pair] = []
                state.checkpoint()
                try:
                    if state.input.startswith('\n', state.pos):
                        state.pos += 1
                    else:
                        raise ParseError('\n')
                except ParseError:
                    state.restore()
                    children4.clear()  # discard lookahead children
                else:
                    state.restore()
                    raise ParseError('unexpected String')
                # Implicit whitespace/comments between sequence elements
                parse_trivia(state, children2)
                if state.pos < len(state.input):
                    state.pos += 1
                else:
                    raise ParseError('unexpected end of input')
                state.ok()
                pairs.extend(children2)
                children2.clear()
                trivia_pos3 = state.pos
                parse_trivia(state, children2)
            except ParseError:
                state.restore()
                state.pos = trivia_pos3
                break
        state.rule_stack.pop()
        state.atomic_depth.restore()
        return Pairs([Pair(state.input, pos1, state.pos, rule_frame, pairs,)])
    
    return inner
    
parse_item = _parse_item()

def _parse_lists() -> Callable[[State], Pairs]:
    rule_frame = RuleFrame('lists', 2)
    
    def inner(state: State) -> Pairs:
        """Parse lists."""
        state.rule_stack.push(rule_frame)
        pairs: list[Pair] = []
        # Sequence
        pairs.extend(parse_lines(state))
        # Implicit whitespace/comments between sequence elements
        parse_trivia(state, pairs)
        pairs.extend(parse_EOI(state))
        state.rule_stack.pop()
        state.atomic_depth.restore()
        # Silent rule lists
        return Pairs(pairs)
    
    return inner
    
parse_lists = _parse_lists()

def _parse_lines() -> Callable[[State], Pairs]:
    rule_frame = RuleFrame('lines', 2)
    
    def inner(state: State) -> Pairs:
        """Parse lines."""
        state.rule_stack.push(rule_frame)
        pairs: list[Pair] = []
        # Sequence
        pairs.extend(parse_top_first(state))
        # Implicit whitespace/comments between sequence elements
        parse_trivia(state, pairs)
        # Repeat: match as many occurrences as we can
        trivia_pos3 = state.pos
        children2: list[Pair] = []
        while True:
            state.checkpoint()
            try:
                # Sequence
                if state.input.startswith('\n', state.pos):
                    state.pos += 1
                else:
                    raise ParseError('\n')
                # Implicit whitespace/comments between sequence elements
                parse_trivia(state, children2)
                children2.extend(parse_top_continue(state))
                state.ok()
                pairs.extend(children2)
                children2.clear()
                trivia_pos3 = state.pos
                parse_trivia(state, children2)
            except ParseError:
                state.restore()
                state.pos = trivia_pos3
                break
        state.rule_stack.pop()
        state.atomic_depth.restore()
        # Silent rule lines
        return Pairs(pairs)
    
    return inner
    
parse_lines = _parse_lines()

def _parse_top_first() -> Callable[[State], Pairs]:
    rule_frame = RuleFrame('top_first', 2)
    
    def inner(state: State) -> Pairs:
        """Parse top_first."""
        state.rule_stack.push(rule_frame)
        pairs: list[Pair] = []
        # Sequence
        if state.input.startswith('- ', state.pos):
            state.pos += 2
        else:
            raise ParseError('- ')
        # Implicit whitespace/comments between sequence elements
        parse_trivia(state, pairs)
        pairs.extend(parse_item(state))
        # Implicit whitespace/comments between sequence elements
        parse_trivia(state, pairs)
        children2: list[Pair] = []
        state.checkpoint()
        try:
            # Sequence
            if state.input.startswith('\n', state.pos):
                state.pos += 1
            else:
                raise ParseError('\n')
            # Implicit whitespace/comments between sequence elements
            parse_trivia(state, children2)
            children2.extend(parse_children(state))
            pairs.extend(children2)
            state.ok()
        except ParseError:
            state.restore()
            children2.clear()
        state.rule_stack.pop()
        state.atomic_depth.restore()
        # Silent rule top_first
        return Pairs(pairs)
    
    return inner
    
parse_top_first = _parse_top_first()

def _parse_top_continue() -> Callable[[State], Pairs]:
    rule_frame = RuleFrame('top_continue', 2)
    
    def inner(state: State) -> Pairs:
        """Parse top_continue."""
        state.rule_stack.push(rule_frame)
        pairs: list[Pair] = []
        # Sequence
        # PeekAll: PEEK_ALL
        pos2 = state.pos
        for _i, _literal in enumerate(reversed(state.user_stack)):
            if state.input.startswith(_literal, pos2):
                pos2 += len(_literal)
                if _i < len(state.user_stack):
                    for _match in state.parse_implicit_rules(pos2):
                        pos2 = _match.pos
            else:
                raise ParseError(f'expected {_literal!r}')
        state.pos = pos2
        # Implicit whitespace/comments between sequence elements
        parse_trivia(state, pairs)
        if state.input.startswith('- ', state.pos):
            state.pos += 2
        else:
            raise ParseError('- ')
        # Implicit whitespace/comments between sequence elements
        parse_trivia(state, pairs)
        pairs.extend(parse_item(state))
        # Implicit whitespace/comments between sequence elements
        parse_trivia(state, pairs)
        children3: list[Pair] = []
        state.checkpoint()
        try:
            # Sequence
            if state.input.startswith('\n', state.pos):
                state.pos += 1
            else:
                raise ParseError('\n')
            # Implicit whitespace/comments between sequence elements
            parse_trivia(state, children3)
            children3.extend(parse_children(state))
            pairs.extend(children3)
            state.ok()
        except ParseError:
            state.restore()
            children3.clear()
        state.rule_stack.pop()
        state.atomic_depth.restore()
        # Silent rule top_continue
        return Pairs(pairs)
    
    return inner
    
parse_top_continue = _parse_top_continue()

def _parse_indentation() -> Callable[[State], Pairs]:
    rule_frame = RuleFrame('indentation', 2)
    
    def inner(state: State) -> Pairs:
        """Parse indentation."""
        state.rule_stack.push(rule_frame)
        pairs: list[Pair] = []
        # RepeatOnce: attempt to match at least one occurrence
        trivia_pos4 = state.pos
        children2: list[Pair] = []
        count3 = 0
        while True:
            state.checkpoint()
            try:
                # Choice: expression | expression
                children5: list[Pair] = []
                matched6 = False
                if not matched6:
                    state.checkpoint()
                    try:
                        if state.input.startswith(' ', state.pos):
                            state.pos += 1
                        else:
                            raise ParseError(' ')
                        matched6 = True
                        state.ok()
                    except ParseError:
                        state.restore()
                        children5.clear()
                if not matched6:
                    state.checkpoint()
                    try:
                        if state.input.startswith('\t', state.pos):
                            state.pos += 1
                        else:
                            raise ParseError('\t')
                        matched6 = True
                        state.ok()
                    except ParseError:
                        state.restore()
                        children5.clear()
                if not matched6:
                    raise ParseError("no choice matched")
                children2.extend(children5)
                count3 += 1
                state.ok()
                pairs.extend(children2)
                children2.clear()
                trivia_pos4 = state.pos
                parse_trivia(state, children2)
            except ParseError:
                state.restore()
                state.pos = trivia_pos4
                break
        if count3 < 1:
            raise ParseError('Expected at least one match')
        state.rule_stack.pop()
        state.atomic_depth.restore()
        # Silent rule indentation
        return Pairs(pairs)
    
    return inner
    
parse_indentation = _parse_indentation()

def _parse_children() -> Callable[[State], Pairs]:
    rule_frame = RuleFrame('children', 0)
    
    def inner(state: State) -> Pairs:
        """Parse children."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        pairs: list[Pair] = []
        # Sequence
        # PeekAll: PEEK_ALL
        pos2 = state.pos
        for _i, _literal in enumerate(reversed(state.user_stack)):
            if state.input.startswith(_literal, pos2):
                pos2 += len(_literal)
                if _i < len(state.user_stack):
                    for _match in state.parse_implicit_rules(pos2):
                        pos2 = _match.pos
            else:
                raise ParseError(f'expected {_literal!r}')
        state.pos = pos2
        # Implicit whitespace/comments between sequence elements
        parse_trivia(state, pairs)
        # Push: PUSH(expression)
        start3 = state.pos
        pairs.extend(parse_indentation(state))
        state.push(state.input[start3 : state.pos])
        # Implicit whitespace/comments between sequence elements
        parse_trivia(state, pairs)
        pairs.extend(parse_lines(state))
        # Implicit whitespace/comments between sequence elements
        parse_trivia(state, pairs)
        # Drop: DROP
        if not state.user_stack.empty():
            state.user_stack.pop()
        else:
            raise ParseError('drop from empty stack')
        state.rule_stack.pop()
        state.atomic_depth.restore()
        return Pairs([Pair(state.input, pos1, state.pos, rule_frame, pairs,)])
    
    return inner
    
parse_children = _parse_children()

def parse_trivia(state: State, pairs: list[Pair]) -> None:
    pass

_RULE_MAP: dict[str, Callable[[State], Pairs]] = {
    'EOI': parse_EOI,
    'item': parse_item,
    'lists': parse_lists,
    'lines': parse_lines,
    'top_first': parse_top_first,
    'top_continue': parse_top_continue,
    'indentation': parse_indentation,
    'children': parse_children,
}

def parse(start_rule: str, input_: str, *, start_pos: int = 0) -> Pairs:
    """Parse `input_` starting from `rule`."""
    state = State(input_, start_pos)
    return _RULE_MAP[start_rule](state)