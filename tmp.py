"""This file was generated by Python pest.

DO NOT EDIT THIS FILE BY HAND.
"""

from __future__ import annotations

from enum import StrEnum
from enum import auto
from typing import TYPE_CHECKING

import regex as re

from pest.exceptions import PestParsingError
from pest.grammar.codegen.state import ParseError
from pest.grammar.codegen.state import RuleFrame
from pest.grammar.codegen.state import State
from pest.pairs import Pair
from pest.pairs import Pairs

if TYPE_CHECKING:
    from collections.abc import Callable

# ruff: noqa: D103 N802 N816 N806 PLR0912 PLR0915 PLR2004


class Rule(StrEnum):
    """Grammar rules."""

    EOI = auto()
    EXPR = auto()
    C = auto()


def _parse_EOI() -> Callable[[State], Pairs]:
    rule_frame = RuleFrame("EOI", 0)

    def inner(state: State) -> Pairs:
        """Parse EOI."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        pairs: list[Pair] = []
        with state.atomic_checkpoint():
            if state.pos != len(state.input):
                raise ParseError("expected end of input")
        state.rule_stack.pop()
        if state.tag_stack:
            tag2: str | None = state.tag_stack.pop()
        else:
            tag2 = None
        return Pairs([Pair(state.input, pos1, state.pos, rule_frame, pairs, tag2)])

    return inner


parse_EOI = _parse_EOI()


def _parse_expr() -> Callable[[State], Pairs]:
    rule_frame = RuleFrame("expr", 0)

    def inner(state: State) -> Pairs:
        """Parse expr."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        pairs: list[Pair] = []
        with state.atomic_checkpoint():
            # Choice: expression | expression
            children2: list[Pair] = []
            matched3 = False
            if not matched3:
                state.checkpoint()
                try:
                    if state.input.startswith("a", state.pos):
                        state.pos += 1
                    else:
                        raise ParseError("a")
                    matched3 = True
                    state.ok()
                except ParseError:
                    state.restore()
                    children2.clear()
            if not matched3:
                state.checkpoint()
                try:
                    if state.input.startswith("b", state.pos):
                        state.pos += 1
                    else:
                        raise ParseError("b")
                    matched3 = True
                    state.ok()
                except ParseError:
                    state.restore()
                    children2.clear()
            if not matched3:
                state.checkpoint()
                try:
                    children2.extend(parse_c(state))
                    matched3 = True
                    state.ok()
                except ParseError:
                    state.restore()
                    children2.clear()
            if not matched3:
                raise ParseError("no choice matched")
            pairs.extend(children2)
        state.rule_stack.pop()
        if state.tag_stack:
            tag4: str | None = state.tag_stack.pop()
        else:
            tag4 = None
        return Pairs([Pair(state.input, pos1, state.pos, rule_frame, pairs, tag4)])

    return inner


parse_expr = _parse_expr()


def _parse_c() -> Callable[[State], Pairs]:
    rule_frame = RuleFrame("c", 2)

    def inner(state: State) -> Pairs:
        """Parse c."""
        state.rule_stack.push(rule_frame)
        pairs: list[Pair] = []
        with state.atomic_checkpoint():
            if state.input.startswith("c", state.pos):
                state.pos += 1
            else:
                raise ParseError("c")
        state.rule_stack.pop()
        if state.tag_stack:
            tag2: str | None = state.tag_stack.pop()
        else:
            tag2 = None
        # Silent rule c
        return Pairs(pairs)

    return inner


parse_c = _parse_c()


def parse_trivia(state: State, pairs: list[Pair]) -> None:
    pass


_RULE_MAP: dict[str, Callable[[State], Pairs]] = {
    "EOI": parse_EOI,
    "expr": parse_expr,
    "c": parse_c,
}


def parse(start_rule: str, input_: str, *, start_pos: int = 0) -> Pairs:
    """Parse `input_` starting from `rule`."""
    state = State(input_, start_pos)
    try:
        return _RULE_MAP[start_rule](state)
    except ParseError as err:
        pos = state.pos
        line = state.input.count("\n", 0, pos) + 1
        col = pos - state.input.rfind("\n", 0, pos)
        found = state.input[pos : pos + 10] or "end of input"
        raise PestParsingError(str(err), [], [], state.pos, "", (line, col)) from err
