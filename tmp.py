"""This file was generated by Python pest.

DO NOT EDIT THIS FILE BY HAND.
"""

from __future__ import annotations

from enum import StrEnum
from typing import TYPE_CHECKING

import regex as re

from pest.exceptions import PestParsingError
from pest.pairs import Pair
from pest.pairs import Pairs
from pest.state import ParserState
from pest.state import RuleFrame

if TYPE_CHECKING:
    from collections.abc import Callable

# ruff: noqa: D103 N802 N816 N806 PLR0912 PLR0915 PLR2004


class Rule(StrEnum):
    """Grammar rules."""

    EOI = "EOI"
    JSON = "json"
    OBJECT = "object"
    PAIR = "pair"
    ARRAY = "array"
    VALUE = "value"
    STRING = "string"
    INNER = "inner"
    ESCAPE = "escape"
    UNICODE = "unicode"
    NUMBER = "number"
    INT = "int"
    EXP = "exp"
    BOOL = "bool"
    NULL = "null"
    WHITESPACE = "WHITESPACE"
    SKIP = "SKIP"


def _parse_EOI() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame("EOI", 0)

    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse EOI."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        if state.pos != len(state.input):
            matched = False
        else:
            matched = True
        state.rule_stack.pop()
        if state.tag_stack:
            tag3: str | None = state.tag_stack.pop()
        else:
            tag3 = None
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    children2,
                    tag3,
                )
            )
        return matched

    return inner


parse_EOI = _parse_EOI()


def _parse_json() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame("json", 0)

    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse json."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=3>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            if state.pos == 0:
                matched3 = True
            else:
                matched3 = False
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Identifier>
            matched3 = parse_value(state, children2)
            # </Identifier>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Identifier>
            matched3 = parse_EOI(state, children2)
            # </Identifier>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag5: str | None = state.tag_stack.pop()
        else:
            tag5 = None
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    children2,
                    tag5,
                )
            )
        return matched

    return inner


parse_json = _parse_json()


def _parse_object() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame("object", 0)

    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse object."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Choice>
        children3: list[Pair] = []
        matched = False
        if not matched:
            state.checkpoint()
            # <Sequence n=4>
            all_ok5 = True
            if all_ok5:
                matched4 = False
                # <String>
                if state.input.startswith("{", state.pos):
                    state.pos += 1
                    matched4 = True
                else:
                    matched4 = False
                    state.fail('"{"')
                # </String>
                if not matched4:
                    all_ok5 = False
                if all_ok5:
                    parse_trivia(state, children3)
            if all_ok5:
                matched4 = False
                # <Identifier>
                matched4 = parse_pair(state, children3)
                # </Identifier>
                if not matched4:
                    all_ok5 = False
                if all_ok5:
                    parse_trivia(state, children3)
            if all_ok5:
                matched4 = False
                # <Repeat>
                trivia_pos7 = state.pos
                children6: list[Pair] = []
                while True:
                    state.checkpoint()
                    # <Group>
                    # <Sequence n=2>
                    all_ok9 = True
                    if all_ok9:
                        matched8 = False
                        # <String>
                        if state.input.startswith(",", state.pos):
                            state.pos += 1
                            matched8 = True
                        else:
                            matched8 = False
                            state.fail('","')
                        # </String>
                        if not matched8:
                            all_ok9 = False
                        if all_ok9:
                            parse_trivia(state, children6)
                    if all_ok9:
                        matched8 = False
                        # <Identifier>
                        matched8 = parse_pair(state, children6)
                        # </Identifier>
                        if not matched8:
                            all_ok9 = False
                    matched4 = all_ok9
                    # </Sequence>
                    # </Group>
                    if matched4:
                        state.ok()
                        children3.extend(children6)
                        children6.clear()
                        trivia_pos7 = state.pos
                        parse_trivia(state, children6)
                    else:
                        state.restore()
                        state.pos = trivia_pos7
                        matched4 = True
                        break
                # </Repeat>
                if not matched4:
                    all_ok5 = False
                if all_ok5:
                    parse_trivia(state, children3)
            if all_ok5:
                matched4 = False
                # <String>
                if state.input.startswith("}", state.pos):
                    state.pos += 1
                    matched4 = True
                else:
                    matched4 = False
                    state.fail('"}"')
                # </String>
                if not matched4:
                    all_ok5 = False
            matched = all_ok5
            # </Sequence>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Sequence n=2>
            all_ok11 = True
            if all_ok11:
                matched10 = False
                # <String>
                if state.input.startswith("{", state.pos):
                    state.pos += 1
                    matched10 = True
                else:
                    matched10 = False
                    state.fail('"{"')
                # </String>
                if not matched10:
                    all_ok11 = False
                if all_ok11:
                    parse_trivia(state, children3)
            if all_ok11:
                matched10 = False
                # <String>
                if state.input.startswith("}", state.pos):
                    state.pos += 1
                    matched10 = True
                else:
                    matched10 = False
                    state.fail('"}"')
                # </String>
                if not matched10:
                    all_ok11 = False
            matched = all_ok11
            # </Sequence>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        # </Choice>
        state.rule_stack.pop()
        if state.tag_stack:
            tag12: str | None = state.tag_stack.pop()
        else:
            tag12 = None
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    children2,
                    tag12,
                )
            )
        return matched

    return inner


parse_object = _parse_object()


def _parse_pair() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame("pair", 0)

    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse pair."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=3>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            # <Identifier>
            matched3 = parse_string(state, children2)
            # </Identifier>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <String>
            if state.input.startswith(":", state.pos):
                state.pos += 1
                matched3 = True
            else:
                matched3 = False
                state.fail('":"')
            # </String>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Identifier>
            matched3 = parse_value(state, children2)
            # </Identifier>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag5: str | None = state.tag_stack.pop()
        else:
            tag5 = None
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    children2,
                    tag5,
                )
            )
        return matched

    return inner


parse_pair = _parse_pair()


def _parse_array() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame("array", 0)

    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse array."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Choice>
        children3: list[Pair] = []
        matched = False
        if not matched:
            state.checkpoint()
            # <Sequence n=4>
            all_ok5 = True
            if all_ok5:
                matched4 = False
                # <String>
                if state.input.startswith("[", state.pos):
                    state.pos += 1
                    matched4 = True
                else:
                    matched4 = False
                    state.fail('"["')
                # </String>
                if not matched4:
                    all_ok5 = False
                if all_ok5:
                    parse_trivia(state, children3)
            if all_ok5:
                matched4 = False
                # <Identifier>
                matched4 = parse_value(state, children3)
                # </Identifier>
                if not matched4:
                    all_ok5 = False
                if all_ok5:
                    parse_trivia(state, children3)
            if all_ok5:
                matched4 = False
                # <Repeat>
                trivia_pos7 = state.pos
                children6: list[Pair] = []
                while True:
                    state.checkpoint()
                    # <Group>
                    # <Sequence n=2>
                    all_ok9 = True
                    if all_ok9:
                        matched8 = False
                        # <String>
                        if state.input.startswith(",", state.pos):
                            state.pos += 1
                            matched8 = True
                        else:
                            matched8 = False
                            state.fail('","')
                        # </String>
                        if not matched8:
                            all_ok9 = False
                        if all_ok9:
                            parse_trivia(state, children6)
                    if all_ok9:
                        matched8 = False
                        # <Identifier>
                        matched8 = parse_value(state, children6)
                        # </Identifier>
                        if not matched8:
                            all_ok9 = False
                    matched4 = all_ok9
                    # </Sequence>
                    # </Group>
                    if matched4:
                        state.ok()
                        children3.extend(children6)
                        children6.clear()
                        trivia_pos7 = state.pos
                        parse_trivia(state, children6)
                    else:
                        state.restore()
                        state.pos = trivia_pos7
                        matched4 = True
                        break
                # </Repeat>
                if not matched4:
                    all_ok5 = False
                if all_ok5:
                    parse_trivia(state, children3)
            if all_ok5:
                matched4 = False
                # <String>
                if state.input.startswith("]", state.pos):
                    state.pos += 1
                    matched4 = True
                else:
                    matched4 = False
                    state.fail('"]"')
                # </String>
                if not matched4:
                    all_ok5 = False
            matched = all_ok5
            # </Sequence>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Sequence n=2>
            all_ok11 = True
            if all_ok11:
                matched10 = False
                # <String>
                if state.input.startswith("[", state.pos):
                    state.pos += 1
                    matched10 = True
                else:
                    matched10 = False
                    state.fail('"["')
                # </String>
                if not matched10:
                    all_ok11 = False
                if all_ok11:
                    parse_trivia(state, children3)
            if all_ok11:
                matched10 = False
                # <String>
                if state.input.startswith("]", state.pos):
                    state.pos += 1
                    matched10 = True
                else:
                    matched10 = False
                    state.fail('"]"')
                # </String>
                if not matched10:
                    all_ok11 = False
            matched = all_ok11
            # </Sequence>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        # </Choice>
        state.rule_stack.pop()
        if state.tag_stack:
            tag12: str | None = state.tag_stack.pop()
        else:
            tag12 = None
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    children2,
                    tag12,
                )
            )
        return matched

    return inner


parse_array = _parse_array()


def _parse_value() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame("value", 0)

    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse value."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Choice>
        children3: list[Pair] = []
        matched = False
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_string(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_number(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_object(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_array(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_bool(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_null(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        # </Choice>
        state.rule_stack.pop()
        if state.tag_stack:
            tag4: str | None = state.tag_stack.pop()
        else:
            tag4 = None
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    children2,
                    tag4,
                )
            )
        return matched

    return inner


parse_value = _parse_value()


def _parse_string() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame("string", 4)

    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse string."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        with state.atomic_checkpoint():
            state.atomic_depth += 1
            # <Sequence n=3>
            all_ok4 = True
            if all_ok4:
                matched3 = False
                # <String>
                if state.input.startswith('"', state.pos):
                    state.pos += 1
                    matched3 = True
                else:
                    matched3 = False
                    state.fail('"""')
                # </String>
                if not matched3:
                    all_ok4 = False
                if all_ok4:
                    parse_trivia(state, children2)
            if all_ok4:
                matched3 = False
                # <Identifier>
                matched3 = parse_inner(state, children2)
                # </Identifier>
                if not matched3:
                    all_ok4 = False
                if all_ok4:
                    parse_trivia(state, children2)
            if all_ok4:
                matched3 = False
                # <String>
                if state.input.startswith('"', state.pos):
                    state.pos += 1
                    matched3 = True
                else:
                    matched3 = False
                    state.fail('"""')
                # </String>
                if not matched3:
                    all_ok4 = False
            matched = all_ok4
            # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag5: str | None = state.tag_stack.pop()
        else:
            tag5 = None
        # Atomic rule: 'string'
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    [],
                    tag5,
                )
            )
        return matched

    return inner


parse_string = _parse_string()


def _parse_inner() -> Callable[[ParserState, list[Pair]], bool]:
    SUBS5 = ['"', "\\"]

    rule_frame = RuleFrame("inner", 4)

    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse inner."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        with state.atomic_checkpoint():
            state.atomic_depth += 1
            # <Sequence n=2>
            all_ok4 = True
            if all_ok4:
                matched3 = False
                # <SkipUntil>
                s8 = state.input
                idx7: int | None = None
                for sub6 in SUBS5:
                    pos9 = s8.find(sub6, state.pos)
                    if pos9 != -1 and (idx7 is None or pos9 < idx7):
                        idx7 = pos9
                if idx7 is not None:
                    state.pos = idx7
                else:
                    state.pos = len(state.input)
                matched3 = True
                # </SkipUntil>
                if not matched3:
                    all_ok4 = False
                if all_ok4:
                    parse_trivia(state, children2)
            if all_ok4:
                matched3 = False
                # <Optional>
                children10: list[Pair] = []
                state.checkpoint()
                # <Group>
                # <Sequence n=2>
                all_ok12 = True
                if all_ok12:
                    matched11 = False
                    # <Identifier>
                    matched11 = parse_escape(state, children10)
                    # </Identifier>
                    if not matched11:
                        all_ok12 = False
                    if all_ok12:
                        parse_trivia(state, children10)
                if all_ok12:
                    matched11 = False
                    # <Identifier>
                    matched11 = parse_inner(state, children10)
                    # </Identifier>
                    if not matched11:
                        all_ok12 = False
                matched3 = all_ok12
                # </Sequence>
                # </Group>
                if matched3:
                    state.ok()
                    children2.extend(children10)
                else:
                    state.restore()
                    children10.clear()
                matched3 = True
                # </Optional>
                if not matched3:
                    all_ok4 = False
            matched = all_ok4
            # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag13: str | None = state.tag_stack.pop()
        else:
            tag13 = None
        # Atomic rule: 'inner'
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    [],
                    tag13,
                )
            )
        return matched

    return inner


parse_inner = _parse_inner()


def _parse_escape() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame("escape", 4)

    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse escape."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        with state.atomic_checkpoint():
            state.atomic_depth += 1
            # <Sequence n=2>
            all_ok4 = True
            if all_ok4:
                matched3 = False
                # <String>
                if state.input.startswith("\\", state.pos):
                    state.pos += 1
                    matched3 = True
                else:
                    matched3 = False
                    state.fail('"\\"')
                # </String>
                if not matched3:
                    all_ok4 = False
                if all_ok4:
                    parse_trivia(state, children2)
            if all_ok4:
                matched3 = False
                # <Group>
                # <Choice>
                children5: list[Pair] = []
                matched3 = False
                if not matched3:
                    state.checkpoint()
                    # <String>
                    if state.input.startswith('"', state.pos):
                        state.pos += 1
                        matched3 = True
                    else:
                        matched3 = False
                        state.fail('"""')
                    # </String>
                    if matched3:
                        state.ok()
                        children2.extend(children5)
                    else:
                        state.restore()
                        children5.clear()
                if not matched3:
                    state.checkpoint()
                    # <String>
                    if state.input.startswith("\\", state.pos):
                        state.pos += 1
                        matched3 = True
                    else:
                        matched3 = False
                        state.fail('"\\"')
                    # </String>
                    if matched3:
                        state.ok()
                        children2.extend(children5)
                    else:
                        state.restore()
                        children5.clear()
                if not matched3:
                    state.checkpoint()
                    # <String>
                    if state.input.startswith("/", state.pos):
                        state.pos += 1
                        matched3 = True
                    else:
                        matched3 = False
                        state.fail('"/"')
                    # </String>
                    if matched3:
                        state.ok()
                        children2.extend(children5)
                    else:
                        state.restore()
                        children5.clear()
                if not matched3:
                    state.checkpoint()
                    # <String>
                    if state.input.startswith("b", state.pos):
                        state.pos += 1
                        matched3 = True
                    else:
                        matched3 = False
                        state.fail('"b"')
                    # </String>
                    if matched3:
                        state.ok()
                        children2.extend(children5)
                    else:
                        state.restore()
                        children5.clear()
                if not matched3:
                    state.checkpoint()
                    # <String>
                    if state.input.startswith("f", state.pos):
                        state.pos += 1
                        matched3 = True
                    else:
                        matched3 = False
                        state.fail('"f"')
                    # </String>
                    if matched3:
                        state.ok()
                        children2.extend(children5)
                    else:
                        state.restore()
                        children5.clear()
                if not matched3:
                    state.checkpoint()
                    # <String>
                    if state.input.startswith("n", state.pos):
                        state.pos += 1
                        matched3 = True
                    else:
                        matched3 = False
                        state.fail('"n"')
                    # </String>
                    if matched3:
                        state.ok()
                        children2.extend(children5)
                    else:
                        state.restore()
                        children5.clear()
                if not matched3:
                    state.checkpoint()
                    # <String>
                    if state.input.startswith("r", state.pos):
                        state.pos += 1
                        matched3 = True
                    else:
                        matched3 = False
                        state.fail('"r"')
                    # </String>
                    if matched3:
                        state.ok()
                        children2.extend(children5)
                    else:
                        state.restore()
                        children5.clear()
                if not matched3:
                    state.checkpoint()
                    # <String>
                    if state.input.startswith("t", state.pos):
                        state.pos += 1
                        matched3 = True
                    else:
                        matched3 = False
                        state.fail('"t"')
                    # </String>
                    if matched3:
                        state.ok()
                        children2.extend(children5)
                    else:
                        state.restore()
                        children5.clear()
                if not matched3:
                    state.checkpoint()
                    # <Identifier>
                    matched3 = parse_unicode(state, children5)
                    # </Identifier>
                    if matched3:
                        state.ok()
                        children2.extend(children5)
                    else:
                        state.restore()
                        children5.clear()
                # </Choice>
                # </Group>
                if not matched3:
                    all_ok4 = False
            matched = all_ok4
            # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag6: str | None = state.tag_stack.pop()
        else:
            tag6 = None
        # Atomic rule: 'escape'
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    [],
                    tag6,
                )
            )
        return matched

    return inner


parse_escape = _parse_escape()


def _parse_unicode() -> Callable[[ParserState, list[Pair]], bool]:
    RE7 = re.compile("[0-9A-Fa-f]", re.VERSION1)
    RE8 = re.compile("[0-9A-Fa-f]", re.VERSION1)
    RE9 = re.compile("[0-9A-Fa-f]", re.VERSION1)
    RE10 = re.compile("[0-9A-Fa-f]", re.VERSION1)

    rule_frame = RuleFrame("unicode", 4)

    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse unicode."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        with state.atomic_checkpoint():
            state.atomic_depth += 1
            # <Sequence n=2>
            all_ok4 = True
            if all_ok4:
                matched3 = False
                # <String>
                if state.input.startswith("u", state.pos):
                    state.pos += 1
                    matched3 = True
                else:
                    matched3 = False
                    state.fail('"u"')
                # </String>
                if not matched3:
                    all_ok4 = False
                if all_ok4:
                    parse_trivia(state, children2)
            if all_ok4:
                matched3 = False
                # <Sequence n=4>
                all_ok6 = True
                if all_ok6:
                    matched5 = False
                    # <ChoiceRegex>
                    if match := RE7.match(state.input, state.pos):
                        state.pos = match.end()
                        matched5 = True
                    else:
                        matched5 = False
                    # </ChoiceRegex>
                    if not matched5:
                        all_ok6 = False
                    if all_ok6:
                        parse_trivia(state, children2)
                if all_ok6:
                    matched5 = False
                    # <ChoiceRegex>
                    if match := RE8.match(state.input, state.pos):
                        state.pos = match.end()
                        matched5 = True
                    else:
                        matched5 = False
                    # </ChoiceRegex>
                    if not matched5:
                        all_ok6 = False
                    if all_ok6:
                        parse_trivia(state, children2)
                if all_ok6:
                    matched5 = False
                    # <ChoiceRegex>
                    if match := RE9.match(state.input, state.pos):
                        state.pos = match.end()
                        matched5 = True
                    else:
                        matched5 = False
                    # </ChoiceRegex>
                    if not matched5:
                        all_ok6 = False
                    if all_ok6:
                        parse_trivia(state, children2)
                if all_ok6:
                    matched5 = False
                    # <ChoiceRegex>
                    if match := RE10.match(state.input, state.pos):
                        state.pos = match.end()
                        matched5 = True
                    else:
                        matched5 = False
                    # </ChoiceRegex>
                    if not matched5:
                        all_ok6 = False
                matched3 = all_ok6
                # </Sequence>
                if not matched3:
                    all_ok4 = False
            matched = all_ok4
            # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag11: str | None = state.tag_stack.pop()
        else:
            tag11 = None
        # Atomic rule: 'unicode'
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    [],
                    tag11,
                )
            )
        return matched

    return inner


parse_unicode = _parse_unicode()


def _parse_number() -> Callable[[ParserState, list[Pair]], bool]:
    RE12 = re.compile("[0-9]", re.I)
    RE15 = re.compile("[0-9]", re.I)

    rule_frame = RuleFrame("number", 4)

    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse number."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        with state.atomic_checkpoint():
            state.atomic_depth += 1
            # <Sequence n=3>
            all_ok4 = True
            if all_ok4:
                matched3 = False
                # <Optional>
                children5: list[Pair] = []
                state.checkpoint()
                # <String>
                if state.input.startswith("-", state.pos):
                    state.pos += 1
                    matched3 = True
                else:
                    matched3 = False
                    state.fail('"-"')
                # </String>
                if matched3:
                    state.ok()
                    children2.extend(children5)
                else:
                    state.restore()
                    children5.clear()
                matched3 = True
                # </Optional>
                if not matched3:
                    all_ok4 = False
                if all_ok4:
                    parse_trivia(state, children2)
            if all_ok4:
                matched3 = False
                # <Identifier>
                matched3 = parse_int(state, children2)
                # </Identifier>
                if not matched3:
                    all_ok4 = False
                if all_ok4:
                    parse_trivia(state, children2)
            if all_ok4:
                matched3 = False
                # <Optional>
                children6: list[Pair] = []
                state.checkpoint()
                # <Group>
                # <Choice>
                children7: list[Pair] = []
                matched3 = False
                if not matched3:
                    state.checkpoint()
                    # <Sequence n=3>
                    all_ok9 = True
                    if all_ok9:
                        matched8 = False
                        # <String>
                        if state.input.startswith(".", state.pos):
                            state.pos += 1
                            matched8 = True
                        else:
                            matched8 = False
                            state.fail('"."')
                        # </String>
                        if not matched8:
                            all_ok9 = False
                        if all_ok9:
                            parse_trivia(state, children7)
                    if all_ok9:
                        matched8 = False
                        # <Sequence n=2>
                        all_ok11 = True
                        if all_ok11:
                            matched10 = False
                            # <Range>
                            if match := RE12.match(state.input, state.pos):
                                state.pos = match.end()
                                matched10 = True
                            else:
                                matched10 = False
                                state.fail("''0''..''9''")
                            # </Range>
                            if not matched10:
                                all_ok11 = False
                            if all_ok11:
                                parse_trivia(state, children7)
                        if all_ok11:
                            matched10 = False
                            # <Repeat>
                            trivia_pos14 = state.pos
                            children13: list[Pair] = []
                            while True:
                                state.checkpoint()
                                # <Range>
                                if match := RE15.match(state.input, state.pos):
                                    state.pos = match.end()
                                    matched10 = True
                                else:
                                    matched10 = False
                                    state.fail("''0''..''9''")
                                # </Range>
                                if matched10:
                                    state.ok()
                                    children7.extend(children13)
                                    children13.clear()
                                    trivia_pos14 = state.pos
                                    parse_trivia(state, children13)
                                else:
                                    state.restore()
                                    state.pos = trivia_pos14
                                    matched10 = True
                                    break
                            # </Repeat>
                            if not matched10:
                                all_ok11 = False
                        matched8 = all_ok11
                        # </Sequence>
                        if not matched8:
                            all_ok9 = False
                        if all_ok9:
                            parse_trivia(state, children7)
                    if all_ok9:
                        matched8 = False
                        # <Optional>
                        children16: list[Pair] = []
                        state.checkpoint()
                        # <Identifier>
                        matched8 = parse_exp(state, children16)
                        # </Identifier>
                        if matched8:
                            state.ok()
                            children7.extend(children16)
                        else:
                            state.restore()
                            children16.clear()
                        matched8 = True
                        # </Optional>
                        if not matched8:
                            all_ok9 = False
                    matched3 = all_ok9
                    # </Sequence>
                    if matched3:
                        state.ok()
                        children6.extend(children7)
                    else:
                        state.restore()
                        children7.clear()
                if not matched3:
                    state.checkpoint()
                    # <Identifier>
                    matched3 = parse_exp(state, children7)
                    # </Identifier>
                    if matched3:
                        state.ok()
                        children6.extend(children7)
                    else:
                        state.restore()
                        children7.clear()
                # </Choice>
                # </Group>
                if matched3:
                    state.ok()
                    children2.extend(children6)
                else:
                    state.restore()
                    children6.clear()
                matched3 = True
                # </Optional>
                if not matched3:
                    all_ok4 = False
            matched = all_ok4
            # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag17: str | None = state.tag_stack.pop()
        else:
            tag17 = None
        # Atomic rule: 'number'
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    [],
                    tag17,
                )
            )
        return matched

    return inner


parse_number = _parse_number()


def _parse_int() -> Callable[[ParserState, list[Pair]], bool]:
    RE6 = re.compile("[1-9]", re.I)
    RE9 = re.compile("[0-9]", re.I)

    rule_frame = RuleFrame("int", 4)

    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse int."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        with state.atomic_checkpoint():
            state.atomic_depth += 1
            # <Choice>
            children3: list[Pair] = []
            matched = False
            if not matched:
                state.checkpoint()
                # <String>
                if state.input.startswith("0", state.pos):
                    state.pos += 1
                    matched = True
                else:
                    matched = False
                    state.fail('"0"')
                # </String>
                if matched:
                    state.ok()
                    children2.extend(children3)
                else:
                    state.restore()
                    children3.clear()
            if not matched:
                state.checkpoint()
                # <Sequence n=2>
                all_ok5 = True
                if all_ok5:
                    matched4 = False
                    # <Range>
                    if match := RE6.match(state.input, state.pos):
                        state.pos = match.end()
                        matched4 = True
                    else:
                        matched4 = False
                        state.fail("''1''..''9''")
                    # </Range>
                    if not matched4:
                        all_ok5 = False
                    if all_ok5:
                        parse_trivia(state, children3)
                if all_ok5:
                    matched4 = False
                    # <Repeat>
                    trivia_pos8 = state.pos
                    children7: list[Pair] = []
                    while True:
                        state.checkpoint()
                        # <Range>
                        if match := RE9.match(state.input, state.pos):
                            state.pos = match.end()
                            matched4 = True
                        else:
                            matched4 = False
                            state.fail("''0''..''9''")
                        # </Range>
                        if matched4:
                            state.ok()
                            children3.extend(children7)
                            children7.clear()
                            trivia_pos8 = state.pos
                            parse_trivia(state, children7)
                        else:
                            state.restore()
                            state.pos = trivia_pos8
                            matched4 = True
                            break
                    # </Repeat>
                    if not matched4:
                        all_ok5 = False
                matched = all_ok5
                # </Sequence>
                if matched:
                    state.ok()
                    children2.extend(children3)
                else:
                    state.restore()
                    children3.clear()
            # </Choice>
        state.rule_stack.pop()
        if state.tag_stack:
            tag10: str | None = state.tag_stack.pop()
        else:
            tag10 = None
        # Atomic rule: 'int'
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    [],
                    tag10,
                )
            )
        return matched

    return inner


parse_int = _parse_int()


def _parse_exp() -> Callable[[ParserState, list[Pair]], bool]:
    RE5 = re.compile("[Ee]", re.VERSION1)
    RE7 = re.compile("[\\+\\-]", re.VERSION1)
    RE10 = re.compile("[0-9]", re.I)
    RE13 = re.compile("[0-9]", re.I)

    rule_frame = RuleFrame("exp", 4)

    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse exp."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        with state.atomic_checkpoint():
            state.atomic_depth += 1
            # <Sequence n=3>
            all_ok4 = True
            if all_ok4:
                matched3 = False
                # <Group>
                # <ChoiceRegex>
                if match := RE5.match(state.input, state.pos):
                    state.pos = match.end()
                    matched3 = True
                else:
                    matched3 = False
                # </ChoiceRegex>
                # </Group>
                if not matched3:
                    all_ok4 = False
                if all_ok4:
                    parse_trivia(state, children2)
            if all_ok4:
                matched3 = False
                # <Optional>
                children6: list[Pair] = []
                state.checkpoint()
                # <Group>
                # <ChoiceRegex>
                if match := RE7.match(state.input, state.pos):
                    state.pos = match.end()
                    matched3 = True
                else:
                    matched3 = False
                # </ChoiceRegex>
                # </Group>
                if matched3:
                    state.ok()
                    children2.extend(children6)
                else:
                    state.restore()
                    children6.clear()
                matched3 = True
                # </Optional>
                if not matched3:
                    all_ok4 = False
                if all_ok4:
                    parse_trivia(state, children2)
            if all_ok4:
                matched3 = False
                # <Sequence n=2>
                all_ok9 = True
                if all_ok9:
                    matched8 = False
                    # <Range>
                    if match := RE10.match(state.input, state.pos):
                        state.pos = match.end()
                        matched8 = True
                    else:
                        matched8 = False
                        state.fail("''0''..''9''")
                    # </Range>
                    if not matched8:
                        all_ok9 = False
                    if all_ok9:
                        parse_trivia(state, children2)
                if all_ok9:
                    matched8 = False
                    # <Repeat>
                    trivia_pos12 = state.pos
                    children11: list[Pair] = []
                    while True:
                        state.checkpoint()
                        # <Range>
                        if match := RE13.match(state.input, state.pos):
                            state.pos = match.end()
                            matched8 = True
                        else:
                            matched8 = False
                            state.fail("''0''..''9''")
                        # </Range>
                        if matched8:
                            state.ok()
                            children2.extend(children11)
                            children11.clear()
                            trivia_pos12 = state.pos
                            parse_trivia(state, children11)
                        else:
                            state.restore()
                            state.pos = trivia_pos12
                            matched8 = True
                            break
                    # </Repeat>
                    if not matched8:
                        all_ok9 = False
                matched3 = all_ok9
                # </Sequence>
                if not matched3:
                    all_ok4 = False
            matched = all_ok4
            # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag14: str | None = state.tag_stack.pop()
        else:
            tag14 = None
        # Atomic rule: 'exp'
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    [],
                    tag14,
                )
            )
        return matched

    return inner


parse_exp = _parse_exp()


def _parse_bool() -> Callable[[ParserState, list[Pair]], bool]:
    RE3 = re.compile("(?:true|false)", re.VERSION1)

    rule_frame = RuleFrame("bool", 0)

    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse bool."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <ChoiceRegex>
        if match := RE3.match(state.input, state.pos):
            state.pos = match.end()
            matched = True
        else:
            matched = False
        # </ChoiceRegex>
        state.rule_stack.pop()
        if state.tag_stack:
            tag4: str | None = state.tag_stack.pop()
        else:
            tag4 = None
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    children2,
                    tag4,
                )
            )
        return matched

    return inner


parse_bool = _parse_bool()


def _parse_null() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame("null", 0)

    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse null."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <String>
        if state.input.startswith("null", state.pos):
            state.pos += 4
            matched = True
        else:
            matched = False
            state.fail('"null"')
        # </String>
        state.rule_stack.pop()
        if state.tag_stack:
            tag3: str | None = state.tag_stack.pop()
        else:
            tag3 = None
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    children2,
                    tag3,
                )
            )
        return matched

    return inner


parse_null = _parse_null()


def _parse_WHITESPACE() -> Callable[[ParserState, list[Pair]], bool]:
    RE3 = re.compile("[\\\t\\\n\\\r\\ ]", re.VERSION1)

    rule_frame = RuleFrame("WHITESPACE", 2)

    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse WHITESPACE."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <ChoiceRegex>
        if match := RE3.match(state.input, state.pos):
            state.pos = match.end()
            matched = True
        else:
            matched = False
        # </ChoiceRegex>
        state.rule_stack.pop()
        # Silent rule 'WHITESPACE'
        pairs.extend(children2)
        return matched

    return inner


parse_WHITESPACE = _parse_WHITESPACE()


def _parse_SKIP() -> Callable[[ParserState, list[Pair]], bool]:
    RE3 = re.compile("(?:[\\\t\\\n\\\r\\ ])*", re.VERSION1)

    rule_frame = RuleFrame("SKIP", 2)

    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse SKIP."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <ChoiceRegex>
        if match := RE3.match(state.input, state.pos):
            state.pos = match.end()
            matched = True
        else:
            matched = False
        # </ChoiceRegex>
        state.rule_stack.pop()
        # Silent rule 'SKIP'
        pairs.extend(children2)
        return matched

    return inner


parse_SKIP = _parse_SKIP()


def parse_trivia(state: ParserState, pairs: list[Pair]) -> bool:
    if state.atomic_depth > 0:
        return True
    return parse_SKIP(state, pairs)


_RULE_MAP: dict[str, Callable[[ParserState, list[Pair]], bool]] = {
    "EOI": parse_EOI,
    "json": parse_json,
    "object": parse_object,
    "pair": parse_pair,
    "array": parse_array,
    "value": parse_value,
    "string": parse_string,
    "inner": parse_inner,
    "escape": parse_escape,
    "unicode": parse_unicode,
    "number": parse_number,
    "int": parse_int,
    "exp": parse_exp,
    "bool": parse_bool,
    "null": parse_null,
    "WHITESPACE": parse_WHITESPACE,
    "SKIP": parse_SKIP,
}


def parse(start_rule: str, input_: str, *, start_pos: int = 0) -> Pairs:
    """Parse `input_` starting from `rule`."""
    state = ParserState(input_, start_pos)
    pairs: list[Pair] = []
    matched = _RULE_MAP[start_rule](state, pairs)
    if matched:
        return Pairs(pairs)
    raise PestParsingError(state)


class Parser:
    def parse(self, start_rule: str, input_: str, *, start_pos: int = 0) -> Pairs:
        return parse(start_rule, input_, start_pos=start_pos)


def main() -> None:
    parser = argparse.ArgumentParser(
        prog="parser",
        description="A parser generated by Python pest.",
    )

    parser.add_argument(
        "rule",
        metavar="RULE",
        help="The name of the rule to start parsing from.",
    )

    group = parser.add_mutually_exclusive_group(required=True)

    group.add_argument(
        "-i",
        "--input",
        metavar="INPUT",
        help="Input text to parse.",
    )

    group.add_argument(
        "-f",
        "--file",
        metavar="FILE",
        type=argparse.FileType("r"),
        help="Path to a file containing text to parse, or `-` to read from stdin.",
    )

    parser.add_argument(
        "--verbose",
        action="store_true",
        help="Display verbose output",
    )

    args = parser.parse_args()
    text = args.input or args.file.read()

    print(  # noqa: T201
        parse(args.rule, text).dumps(compact=not args.verbose)
    )


if __name__ == "__main__":
    import argparse

    main()
