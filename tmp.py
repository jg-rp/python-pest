"""This file was generated by Python pest.

DO NOT EDIT THIS FILE BY HAND.
"""

from __future__ import annotations

from enum import StrEnum
from enum import auto
from typing import TYPE_CHECKING

import regex as re

from pest.exceptions import PestParsingError
from pest.grammar.codegen.state import ParseError
from pest.grammar.codegen.state import RuleFrame
from pest.grammar.codegen.state import State
from pest.pairs import Pair
from pest.pairs import Pairs

if TYPE_CHECKING:
    from collections.abc import Callable

# ruff: noqa: D103 N802 N816 N806 PLR0912 PLR0915 PLR2004


class Rule(StrEnum):
    """Grammar rules."""

    EOI = auto()
    JSON = auto()
    OBJECT = auto()
    PAIR = auto()
    ARRAY = auto()
    VALUE = auto()
    STRING = auto()
    INNER = auto()
    ESCAPE = auto()
    UNICODE = auto()
    NUMBER = auto()
    INT = auto()
    EXP = auto()
    BOOL = auto()
    NULL = auto()
    WHITESPACE = auto()


def _parse_EOI() -> Callable[[State], Pairs]:
    rule_frame = RuleFrame("EOI", 0)

    def inner(state: State) -> Pairs:
        """Parse EOI."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        pairs: list[Pair] = []
        with state.atomic_checkpoint():
            if state.pos != len(state.input):
                raise ParseError("expected end of input")
        state.rule_stack.pop()
        return Pairs(
            [
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    pairs,
                )
            ]
        )

    return inner


parse_EOI = _parse_EOI()


def _parse_json() -> Callable[[State], Pairs]:
    rule_frame = RuleFrame("json", 0)

    def inner(state: State) -> Pairs:
        """Parse json."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        pairs: list[Pair] = []
        with state.atomic_checkpoint():
            # Sequence
            if state.pos != 0:
                raise ParseError("expected start of input")
            # Implicit whitespace/comments between sequence elements
            parse_trivia(state, pairs)
            pairs.extend(parse_value(state))
            # Implicit whitespace/comments between sequence elements
            parse_trivia(state, pairs)
            pairs.extend(parse_EOI(state))
        state.rule_stack.pop()
        return Pairs(
            [
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    pairs,
                )
            ]
        )

    return inner


parse_json = _parse_json()


def _parse_object() -> Callable[[State], Pairs]:
    rule_frame = RuleFrame("object", 0)

    def inner(state: State) -> Pairs:
        """Parse object."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        pairs: list[Pair] = []
        with state.atomic_checkpoint():
            # Choice: expression | expression
            children2: list[Pair] = []
            matched3 = False
            if not matched3:
                state.checkpoint()
                try:
                    # Sequence
                    if state.input.startswith("{", state.pos):
                        state.pos += 1
                    else:
                        raise ParseError("{")
                    # Implicit whitespace/comments between sequence elements
                    parse_trivia(state, children2)
                    children2.extend(parse_pair(state))
                    # Implicit whitespace/comments between sequence elements
                    parse_trivia(state, children2)
                    # Repeat: match as many occurrences as we can
                    trivia_pos5 = state.pos
                    children4: list[Pair] = []
                    while True:
                        state.checkpoint()
                        try:
                            # Sequence
                            if state.input.startswith(",", state.pos):
                                state.pos += 1
                            else:
                                raise ParseError(",")
                            # Implicit whitespace/comments between sequence elements
                            parse_trivia(state, children4)
                            children4.extend(parse_pair(state))
                            state.ok()
                            children2.extend(children4)
                            children4.clear()
                            trivia_pos5 = state.pos
                            parse_trivia(state, children4)
                        except ParseError:
                            state.restore()
                            state.pos = trivia_pos5
                            break
                    # Implicit whitespace/comments between sequence elements
                    parse_trivia(state, children2)
                    if state.input.startswith("}", state.pos):
                        state.pos += 1
                    else:
                        raise ParseError("}")
                    matched3 = True
                    state.ok()
                except ParseError:
                    state.restore()
                    children2.clear()
            if not matched3:
                state.checkpoint()
                try:
                    # Sequence
                    if state.input.startswith("{", state.pos):
                        state.pos += 1
                    else:
                        raise ParseError("{")
                    # Implicit whitespace/comments between sequence elements
                    parse_trivia(state, children2)
                    if state.input.startswith("}", state.pos):
                        state.pos += 1
                    else:
                        raise ParseError("}")
                    matched3 = True
                    state.ok()
                except ParseError:
                    state.restore()
                    children2.clear()
            if not matched3:
                raise ParseError("no choice matched")
            pairs.extend(children2)
        state.rule_stack.pop()
        return Pairs(
            [
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    pairs,
                )
            ]
        )

    return inner


parse_object = _parse_object()


def _parse_pair() -> Callable[[State], Pairs]:
    rule_frame = RuleFrame("pair", 0)

    def inner(state: State) -> Pairs:
        """Parse pair."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        pairs: list[Pair] = []
        with state.atomic_checkpoint():
            # Sequence
            pairs.extend(parse_string(state))
            # Implicit whitespace/comments between sequence elements
            parse_trivia(state, pairs)
            if state.input.startswith(":", state.pos):
                state.pos += 1
            else:
                raise ParseError(":")
            # Implicit whitespace/comments between sequence elements
            parse_trivia(state, pairs)
            pairs.extend(parse_value(state))
        state.rule_stack.pop()
        return Pairs(
            [
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    pairs,
                )
            ]
        )

    return inner


parse_pair = _parse_pair()


def _parse_array() -> Callable[[State], Pairs]:
    rule_frame = RuleFrame("array", 0)

    def inner(state: State) -> Pairs:
        """Parse array."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        pairs: list[Pair] = []
        with state.atomic_checkpoint():
            # Choice: expression | expression
            children2: list[Pair] = []
            matched3 = False
            if not matched3:
                state.checkpoint()
                try:
                    # Sequence
                    if state.input.startswith("[", state.pos):
                        state.pos += 1
                    else:
                        raise ParseError("[")
                    # Implicit whitespace/comments between sequence elements
                    parse_trivia(state, children2)
                    children2.extend(parse_value(state))
                    # Implicit whitespace/comments between sequence elements
                    parse_trivia(state, children2)
                    # Repeat: match as many occurrences as we can
                    trivia_pos5 = state.pos
                    children4: list[Pair] = []
                    while True:
                        state.checkpoint()
                        try:
                            # Sequence
                            if state.input.startswith(",", state.pos):
                                state.pos += 1
                            else:
                                raise ParseError(",")
                            # Implicit whitespace/comments between sequence elements
                            parse_trivia(state, children4)
                            children4.extend(parse_value(state))
                            state.ok()
                            children2.extend(children4)
                            children4.clear()
                            trivia_pos5 = state.pos
                            parse_trivia(state, children4)
                        except ParseError:
                            state.restore()
                            state.pos = trivia_pos5
                            break
                    # Implicit whitespace/comments between sequence elements
                    parse_trivia(state, children2)
                    if state.input.startswith("]", state.pos):
                        state.pos += 1
                    else:
                        raise ParseError("]")
                    matched3 = True
                    state.ok()
                except ParseError:
                    state.restore()
                    children2.clear()
            if not matched3:
                state.checkpoint()
                try:
                    # Sequence
                    if state.input.startswith("[", state.pos):
                        state.pos += 1
                    else:
                        raise ParseError("[")
                    # Implicit whitespace/comments between sequence elements
                    parse_trivia(state, children2)
                    if state.input.startswith("]", state.pos):
                        state.pos += 1
                    else:
                        raise ParseError("]")
                    matched3 = True
                    state.ok()
                except ParseError:
                    state.restore()
                    children2.clear()
            if not matched3:
                raise ParseError("no choice matched")
            pairs.extend(children2)
        state.rule_stack.pop()
        return Pairs(
            [
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    pairs,
                )
            ]
        )

    return inner


parse_array = _parse_array()


def _parse_value() -> Callable[[State], Pairs]:
    rule_frame = RuleFrame("value", 0)

    def inner(state: State) -> Pairs:
        """Parse value."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        pairs: list[Pair] = []
        with state.atomic_checkpoint():
            # Choice: expression | expression
            children2: list[Pair] = []
            matched3 = False
            if not matched3:
                state.checkpoint()
                try:
                    children2.extend(parse_string(state))
                    matched3 = True
                    state.ok()
                except ParseError:
                    state.restore()
                    children2.clear()
            if not matched3:
                state.checkpoint()
                try:
                    children2.extend(parse_number(state))
                    matched3 = True
                    state.ok()
                except ParseError:
                    state.restore()
                    children2.clear()
            if not matched3:
                state.checkpoint()
                try:
                    children2.extend(parse_object(state))
                    matched3 = True
                    state.ok()
                except ParseError:
                    state.restore()
                    children2.clear()
            if not matched3:
                state.checkpoint()
                try:
                    children2.extend(parse_array(state))
                    matched3 = True
                    state.ok()
                except ParseError:
                    state.restore()
                    children2.clear()
            if not matched3:
                state.checkpoint()
                try:
                    children2.extend(parse_bool(state))
                    matched3 = True
                    state.ok()
                except ParseError:
                    state.restore()
                    children2.clear()
            if not matched3:
                state.checkpoint()
                try:
                    children2.extend(parse_null(state))
                    matched3 = True
                    state.ok()
                except ParseError:
                    state.restore()
                    children2.clear()
            if not matched3:
                raise ParseError("no choice matched")
            pairs.extend(children2)
        state.rule_stack.pop()
        return Pairs(
            [
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    pairs,
                )
            ]
        )

    return inner


parse_value = _parse_value()


def _parse_string() -> Callable[[State], Pairs]:
    rule_frame = RuleFrame("string", 4)

    def inner(state: State) -> Pairs:
        """Parse string."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        pairs: list[Pair] = []
        with state.atomic_checkpoint():
            state.atomic_depth += 1
            # Sequence
            if state.input.startswith('"', state.pos):
                state.pos += 1
            else:
                raise ParseError('"')
            # Implicit whitespace/comments between sequence elements
            parse_trivia(state, pairs)
            pairs.extend(parse_inner(state))
            # Implicit whitespace/comments between sequence elements
            parse_trivia(state, pairs)
            if state.input.startswith('"', state.pos):
                state.pos += 1
            else:
                raise ParseError('"')
        state.rule_stack.pop()
        # Atomic rule: 'string'
        return Pairs(
            [
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    [],
                )
            ]
        )

    return inner


parse_string = _parse_string()


def _parse_inner() -> Callable[[State], Pairs]:
    SUBS2 = ['"', "\\"]

    rule_frame = RuleFrame("inner", 4)

    def inner(state: State) -> Pairs:
        """Parse inner."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        pairs: list[Pair] = []
        with state.atomic_checkpoint():
            state.atomic_depth += 1
            # Sequence
            # SkipUntil:
            s5 = state.input
            idx4: int | None = None
            for sub3 in SUBS2:
                pos6 = s5.find(sub3, state.pos)
                if pos6 != -1 and (idx4 is None or pos6 < idx4):
                    idx4 = pos6
            if idx4 is not None:
                state.pos = idx4
            else:
                state.pos = len(state.input)
            # Implicit whitespace/comments between sequence elements
            parse_trivia(state, pairs)
            children7: list[Pair] = []
            state.checkpoint()
            try:
                # Sequence
                children7.extend(parse_escape(state))
                # Implicit whitespace/comments between sequence elements
                parse_trivia(state, children7)
                children7.extend(parse_inner(state))
                pairs.extend(children7)
                state.ok()
            except ParseError:
                state.restore()
                children7.clear()
        state.rule_stack.pop()
        # Atomic rule: 'inner'
        return Pairs(
            [
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    [],
                )
            ]
        )

    return inner


parse_inner = _parse_inner()


def _parse_escape() -> Callable[[State], Pairs]:
    rule_frame = RuleFrame("escape", 4)

    def inner(state: State) -> Pairs:
        """Parse escape."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        pairs: list[Pair] = []
        with state.atomic_checkpoint():
            state.atomic_depth += 1
            # Sequence
            if state.input.startswith("\\", state.pos):
                state.pos += 1
            else:
                raise ParseError("\\")
            # Implicit whitespace/comments between sequence elements
            parse_trivia(state, pairs)
            # Choice: expression | expression
            children2: list[Pair] = []
            matched3 = False
            if not matched3:
                state.checkpoint()
                try:
                    if state.input.startswith('"', state.pos):
                        state.pos += 1
                    else:
                        raise ParseError('"')
                    matched3 = True
                    state.ok()
                except ParseError:
                    state.restore()
                    children2.clear()
            if not matched3:
                state.checkpoint()
                try:
                    if state.input.startswith("\\", state.pos):
                        state.pos += 1
                    else:
                        raise ParseError("\\")
                    matched3 = True
                    state.ok()
                except ParseError:
                    state.restore()
                    children2.clear()
            if not matched3:
                state.checkpoint()
                try:
                    if state.input.startswith("/", state.pos):
                        state.pos += 1
                    else:
                        raise ParseError("/")
                    matched3 = True
                    state.ok()
                except ParseError:
                    state.restore()
                    children2.clear()
            if not matched3:
                state.checkpoint()
                try:
                    if state.input.startswith("b", state.pos):
                        state.pos += 1
                    else:
                        raise ParseError("b")
                    matched3 = True
                    state.ok()
                except ParseError:
                    state.restore()
                    children2.clear()
            if not matched3:
                state.checkpoint()
                try:
                    if state.input.startswith("f", state.pos):
                        state.pos += 1
                    else:
                        raise ParseError("f")
                    matched3 = True
                    state.ok()
                except ParseError:
                    state.restore()
                    children2.clear()
            if not matched3:
                state.checkpoint()
                try:
                    if state.input.startswith("n", state.pos):
                        state.pos += 1
                    else:
                        raise ParseError("n")
                    matched3 = True
                    state.ok()
                except ParseError:
                    state.restore()
                    children2.clear()
            if not matched3:
                state.checkpoint()
                try:
                    if state.input.startswith("r", state.pos):
                        state.pos += 1
                    else:
                        raise ParseError("r")
                    matched3 = True
                    state.ok()
                except ParseError:
                    state.restore()
                    children2.clear()
            if not matched3:
                state.checkpoint()
                try:
                    if state.input.startswith("t", state.pos):
                        state.pos += 1
                    else:
                        raise ParseError("t")
                    matched3 = True
                    state.ok()
                except ParseError:
                    state.restore()
                    children2.clear()
            if not matched3:
                state.checkpoint()
                try:
                    children2.extend(parse_unicode(state))
                    matched3 = True
                    state.ok()
                except ParseError:
                    state.restore()
                    children2.clear()
            if not matched3:
                raise ParseError("no choice matched")
            pairs.extend(children2)
        state.rule_stack.pop()
        # Atomic rule: 'escape'
        return Pairs(
            [
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    [],
                )
            ]
        )

    return inner


parse_escape = _parse_escape()


def _parse_unicode() -> Callable[[State], Pairs]:
    RE2 = re.compile("[0-9A-Fa-f]", re.VERSION1)
    RE3 = re.compile("[0-9A-Fa-f]", re.VERSION1)
    RE4 = re.compile("[0-9A-Fa-f]", re.VERSION1)
    RE5 = re.compile("[0-9A-Fa-f]", re.VERSION1)

    rule_frame = RuleFrame("unicode", 4)

    def inner(state: State) -> Pairs:
        """Parse unicode."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        pairs: list[Pair] = []
        with state.atomic_checkpoint():
            state.atomic_depth += 1
            # Sequence
            if state.input.startswith("u", state.pos):
                state.pos += 1
            else:
                raise ParseError("u")
            # Implicit whitespace/comments between sequence elements
            parse_trivia(state, pairs)
            # Sequence
            # ChoiceRegex:
            if match := RE2.match(state.input, state.pos):
                state.pos = match.end()
            else:
                raise ParseError("expected one of choice")
            # Implicit whitespace/comments between sequence elements
            parse_trivia(state, pairs)
            # ChoiceRegex:
            if match := RE3.match(state.input, state.pos):
                state.pos = match.end()
            else:
                raise ParseError("expected one of choice")
            # Implicit whitespace/comments between sequence elements
            parse_trivia(state, pairs)
            # ChoiceRegex:
            if match := RE4.match(state.input, state.pos):
                state.pos = match.end()
            else:
                raise ParseError("expected one of choice")
            # Implicit whitespace/comments between sequence elements
            parse_trivia(state, pairs)
            # ChoiceRegex:
            if match := RE5.match(state.input, state.pos):
                state.pos = match.end()
            else:
                raise ParseError("expected one of choice")
        state.rule_stack.pop()
        # Atomic rule: 'unicode'
        return Pairs(
            [
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    [],
                )
            ]
        )

    return inner


parse_unicode = _parse_unicode()


def _parse_number() -> Callable[[State], Pairs]:
    RE6 = re.compile("[0-9]", re.I)
    RE9 = re.compile("[0-9]", re.I)

    rule_frame = RuleFrame("number", 4)

    def inner(state: State) -> Pairs:
        """Parse number."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        pairs: list[Pair] = []
        with state.atomic_checkpoint():
            state.atomic_depth += 1
            # Sequence
            children2: list[Pair] = []
            state.checkpoint()
            try:
                if state.input.startswith("-", state.pos):
                    state.pos += 1
                else:
                    raise ParseError("-")
                pairs.extend(children2)
                state.ok()
            except ParseError:
                state.restore()
                children2.clear()
            # Implicit whitespace/comments between sequence elements
            parse_trivia(state, pairs)
            pairs.extend(parse_int(state))
            # Implicit whitespace/comments between sequence elements
            parse_trivia(state, pairs)
            children3: list[Pair] = []
            state.checkpoint()
            try:
                # Choice: expression | expression
                children4: list[Pair] = []
                matched5 = False
                if not matched5:
                    state.checkpoint()
                    try:
                        # Sequence
                        if state.input.startswith(".", state.pos):
                            state.pos += 1
                        else:
                            raise ParseError(".")
                        # Implicit whitespace/comments between sequence elements
                        parse_trivia(state, children4)
                        # Sequence
                        # Range: start..stop
                        if match := RE6.match(state.input, state.pos):
                            state.pos = match.end()
                        else:
                            raise ParseError("expected '0'..'9'")
                        # Implicit whitespace/comments between sequence elements
                        parse_trivia(state, children4)
                        # Repeat: match as many occurrences as we can
                        trivia_pos8 = state.pos
                        children7: list[Pair] = []
                        while True:
                            state.checkpoint()
                            try:
                                # Range: start..stop
                                if match := RE9.match(state.input, state.pos):
                                    state.pos = match.end()
                                else:
                                    raise ParseError("expected '0'..'9'")
                                state.ok()
                                children4.extend(children7)
                                children7.clear()
                                trivia_pos8 = state.pos
                                parse_trivia(state, children7)
                            except ParseError:
                                state.restore()
                                state.pos = trivia_pos8
                                break
                        # Implicit whitespace/comments between sequence elements
                        parse_trivia(state, children4)
                        children10: list[Pair] = []
                        state.checkpoint()
                        try:
                            children10.extend(parse_exp(state))
                            children4.extend(children10)
                            state.ok()
                        except ParseError:
                            state.restore()
                            children10.clear()
                        matched5 = True
                        state.ok()
                    except ParseError:
                        state.restore()
                        children4.clear()
                if not matched5:
                    state.checkpoint()
                    try:
                        children4.extend(parse_exp(state))
                        matched5 = True
                        state.ok()
                    except ParseError:
                        state.restore()
                        children4.clear()
                if not matched5:
                    raise ParseError("no choice matched")
                children3.extend(children4)
                pairs.extend(children3)
                state.ok()
            except ParseError:
                state.restore()
                children3.clear()
        state.rule_stack.pop()
        # Atomic rule: 'number'
        return Pairs(
            [
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    [],
                )
            ]
        )

    return inner


parse_number = _parse_number()


def _parse_int() -> Callable[[State], Pairs]:
    RE4 = re.compile("[1-9]", re.I)
    RE7 = re.compile("[0-9]", re.I)

    rule_frame = RuleFrame("int", 4)

    def inner(state: State) -> Pairs:
        """Parse int."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        pairs: list[Pair] = []
        with state.atomic_checkpoint():
            state.atomic_depth += 1
            # Choice: expression | expression
            children2: list[Pair] = []
            matched3 = False
            if not matched3:
                state.checkpoint()
                try:
                    if state.input.startswith("0", state.pos):
                        state.pos += 1
                    else:
                        raise ParseError("0")
                    matched3 = True
                    state.ok()
                except ParseError:
                    state.restore()
                    children2.clear()
            if not matched3:
                state.checkpoint()
                try:
                    # Sequence
                    # Range: start..stop
                    if match := RE4.match(state.input, state.pos):
                        state.pos = match.end()
                    else:
                        raise ParseError("expected '1'..'9'")
                    # Implicit whitespace/comments between sequence elements
                    parse_trivia(state, children2)
                    # Repeat: match as many occurrences as we can
                    trivia_pos6 = state.pos
                    children5: list[Pair] = []
                    while True:
                        state.checkpoint()
                        try:
                            # Range: start..stop
                            if match := RE7.match(state.input, state.pos):
                                state.pos = match.end()
                            else:
                                raise ParseError("expected '0'..'9'")
                            state.ok()
                            children2.extend(children5)
                            children5.clear()
                            trivia_pos6 = state.pos
                            parse_trivia(state, children5)
                        except ParseError:
                            state.restore()
                            state.pos = trivia_pos6
                            break
                    matched3 = True
                    state.ok()
                except ParseError:
                    state.restore()
                    children2.clear()
            if not matched3:
                raise ParseError("no choice matched")
            pairs.extend(children2)
        state.rule_stack.pop()
        # Atomic rule: 'int'
        return Pairs(
            [
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    [],
                )
            ]
        )

    return inner


parse_int = _parse_int()


def _parse_exp() -> Callable[[State], Pairs]:
    RE2 = re.compile("[Ee]", re.VERSION1)
    RE4 = re.compile("[\\+\\-]", re.VERSION1)
    RE5 = re.compile("[0-9]", re.I)
    RE8 = re.compile("[0-9]", re.I)

    rule_frame = RuleFrame("exp", 4)

    def inner(state: State) -> Pairs:
        """Parse exp."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        pairs: list[Pair] = []
        with state.atomic_checkpoint():
            state.atomic_depth += 1
            # Sequence
            # ChoiceRegex:
            if match := RE2.match(state.input, state.pos):
                state.pos = match.end()
            else:
                raise ParseError("expected one of choice")
            # Implicit whitespace/comments between sequence elements
            parse_trivia(state, pairs)
            children3: list[Pair] = []
            state.checkpoint()
            try:
                # ChoiceRegex:
                if match := RE4.match(state.input, state.pos):
                    state.pos = match.end()
                else:
                    raise ParseError("expected one of choice")
                pairs.extend(children3)
                state.ok()
            except ParseError:
                state.restore()
                children3.clear()
            # Implicit whitespace/comments between sequence elements
            parse_trivia(state, pairs)
            # Sequence
            # Range: start..stop
            if match := RE5.match(state.input, state.pos):
                state.pos = match.end()
            else:
                raise ParseError("expected '0'..'9'")
            # Implicit whitespace/comments between sequence elements
            parse_trivia(state, pairs)
            # Repeat: match as many occurrences as we can
            trivia_pos7 = state.pos
            children6: list[Pair] = []
            while True:
                state.checkpoint()
                try:
                    # Range: start..stop
                    if match := RE8.match(state.input, state.pos):
                        state.pos = match.end()
                    else:
                        raise ParseError("expected '0'..'9'")
                    state.ok()
                    pairs.extend(children6)
                    children6.clear()
                    trivia_pos7 = state.pos
                    parse_trivia(state, children6)
                except ParseError:
                    state.restore()
                    state.pos = trivia_pos7
                    break
        state.rule_stack.pop()
        # Atomic rule: 'exp'
        return Pairs(
            [
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    [],
                )
            ]
        )

    return inner


parse_exp = _parse_exp()


def _parse_bool() -> Callable[[State], Pairs]:
    RE2 = re.compile("(?:true|false)", re.VERSION1)

    rule_frame = RuleFrame("bool", 0)

    def inner(state: State) -> Pairs:
        """Parse bool."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        pairs: list[Pair] = []
        with state.atomic_checkpoint():
            # ChoiceRegex:
            if match := RE2.match(state.input, state.pos):
                state.pos = match.end()
            else:
                raise ParseError("expected one of choice")
        state.rule_stack.pop()
        return Pairs(
            [
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    pairs,
                )
            ]
        )

    return inner


parse_bool = _parse_bool()


def _parse_null() -> Callable[[State], Pairs]:
    rule_frame = RuleFrame("null", 0)

    def inner(state: State) -> Pairs:
        """Parse null."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        pairs: list[Pair] = []
        with state.atomic_checkpoint():
            if state.input.startswith("null", state.pos):
                state.pos += 4
            else:
                raise ParseError("null")
        state.rule_stack.pop()
        return Pairs(
            [
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    pairs,
                )
            ]
        )

    return inner


parse_null = _parse_null()


def _parse_WHITESPACE() -> Callable[[State], Pairs]:
    RE2 = re.compile("[\\\t\\\n\\\r\\ ]", re.VERSION1)

    rule_frame = RuleFrame("WHITESPACE", 2)

    def inner(state: State) -> Pairs:
        """Parse WHITESPACE."""
        state.rule_stack.push(rule_frame)
        pairs: list[Pair] = []
        with state.atomic_checkpoint():
            # ChoiceRegex:
            if match := RE2.match(state.input, state.pos):
                state.pos = match.end()
            else:
                raise ParseError("expected one of choice")
        state.rule_stack.pop()
        # Silent rule WHITESPACE
        return Pairs(pairs)

    return inner


parse_WHITESPACE = _parse_WHITESPACE()


def parse_trivia(state: State, pairs: list[Pair]) -> None:
    if state.atomic_depth > 0:
        return
    while True:
        state.checkpoint()
        matched = False
        try:
            pairs.extend(parse_WHITESPACE(state))
            state.ok()
            matched = True
        except ParseError:
            state.restore()
        if not matched:
            break


_RULE_MAP: dict[str, Callable[[State], Pairs]] = {
    "EOI": parse_EOI,
    "json": parse_json,
    "object": parse_object,
    "pair": parse_pair,
    "array": parse_array,
    "value": parse_value,
    "string": parse_string,
    "inner": parse_inner,
    "escape": parse_escape,
    "unicode": parse_unicode,
    "number": parse_number,
    "int": parse_int,
    "exp": parse_exp,
    "bool": parse_bool,
    "null": parse_null,
    "WHITESPACE": parse_WHITESPACE,
}


def parse(start_rule: str, input_: str, *, start_pos: int = 0) -> Pairs:
    """Parse `input_` starting from `rule`."""
    state = State(input_, start_pos)
    try:
        return _RULE_MAP[start_rule](state)
    except ParseError as err:
        pos = state.pos
        line = state.input.count("\n", 0, pos) + 1
        col = pos - state.input.rfind("\n", 0, pos)
        found = state.input[pos : pos + 10] or "end of input"
        raise PestParsingError(str(err), [], [], state.pos, "", (line, col)) from err
