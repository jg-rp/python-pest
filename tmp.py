"""This file was generated by Python pest.

DO NOT EDIT THIS FILE BY HAND.
"""

from __future__ import annotations

from enum import StrEnum
from typing import TYPE_CHECKING

import regex as re

from pest.exceptions import PestParsingError
from pest.exceptions import error_context
from pest.grammar.codegen.state import RuleFrame
from pest.grammar.codegen.state import State
from pest.pairs import Pair
from pest.pairs import Pairs

if TYPE_CHECKING:
    from collections.abc import Callable

# ruff: noqa: D103 N802 N816 N806 PLR0912 PLR0915 PLR2004


class Rule(StrEnum):
    """Grammar rules."""
    EOI = 'EOI'
    A = 'a'
    B = 'b'
    C = 'c'
    D = 'd'
    CHOICES = 'choices'
    CHOICES_NO_PROGRESS = 'choices_no_progress'
    CHOICES_A_PROGRESS = 'choices_a_progress'
    CHOICES_B_PROGRESS = 'choices_b_progress'
    LEVEL1 = 'level1'
    LEVEL2 = 'level2'
    NEGATIVE = 'negative'
    NEGATIVE_MATCH = 'negative_match'
    MIXED = 'mixed'
    MIXED_PROGRESS = 'mixed_progress'

def _parse_EOI() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame('EOI', 0)
    
    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse EOI."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        if state.pos != len(state.input):
            matched = False
        else:
            matched = True
        state.rule_stack.pop()
        if state.tag_stack:
            tag3: str | None = state.tag_stack.pop()
        else:
            tag3 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag3,))
        return matched
    
    return inner
    
parse_EOI = _parse_EOI()

def _parse_a() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame('a', 0)
    
    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse a."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <String>
        if state.input.startswith('a', state.pos):
            state.pos += 1
            matched = True
        else:
            matched = False
            state.fail('"a"')
        # </String>
        state.rule_stack.pop()
        if state.tag_stack:
            tag3: str | None = state.tag_stack.pop()
        else:
            tag3 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag3,))
        return matched
    
    return inner
    
parse_a = _parse_a()

def _parse_b() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame('b', 0)
    
    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse b."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <String>
        if state.input.startswith('b', state.pos):
            state.pos += 1
            matched = True
        else:
            matched = False
            state.fail('"b"')
        # </String>
        state.rule_stack.pop()
        if state.tag_stack:
            tag3: str | None = state.tag_stack.pop()
        else:
            tag3 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag3,))
        return matched
    
    return inner
    
parse_b = _parse_b()

def _parse_c() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame('c', 0)
    
    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse c."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <String>
        if state.input.startswith('c', state.pos):
            state.pos += 1
            matched = True
        else:
            matched = False
            state.fail('"c"')
        # </String>
        state.rule_stack.pop()
        if state.tag_stack:
            tag3: str | None = state.tag_stack.pop()
        else:
            tag3 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag3,))
        return matched
    
    return inner
    
parse_c = _parse_c()

def _parse_d() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame('d', 0)
    
    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse d."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        if state.pos < len(state.input):
            state.pos += 1
            matched = True
        else:
            matched = False
        state.rule_stack.pop()
        if state.tag_stack:
            tag3: str | None = state.tag_stack.pop()
        else:
            tag3 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag3,))
        return matched
    
    return inner
    
parse_d = _parse_d()

def _parse_choices() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame('choices', 2)
    
    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse choices."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Choice>
        children3: list[Pair] = []
        matched = False
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_a(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_b(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_c(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        # </Choice>
        state.rule_stack.pop()
        # Silent rule 'choices'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_choices = _parse_choices()

def _parse_choices_no_progress() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame('choices_no_progress', 0)
    
    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse choices_no_progress."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Choice>
        children3: list[Pair] = []
        matched = False
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_a(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_b(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_c(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        # </Choice>
        state.rule_stack.pop()
        if state.tag_stack:
            tag4: str | None = state.tag_stack.pop()
        else:
            tag4 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag4,))
        return matched
    
    return inner
    
parse_choices_no_progress = _parse_choices_no_progress()

def _parse_choices_a_progress() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame('choices_a_progress', 0)
    
    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse choices_a_progress."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Choice>
        children3: list[Pair] = []
        matched = False
        if not matched:
            state.checkpoint()
            # <Sequence n=2>
            all_ok5 = True
            if all_ok5:
                matched4 = False
                # <Identifier>
                matched4 = parse_a(state, children3)
                # </Identifier>
                if not matched4:
                    all_ok5 = False
                if all_ok5:
                    parse_trivia(state, children3)
            if all_ok5:
                matched4 = False
                # <Identifier>
                matched4 = parse_a(state, children3)
                # </Identifier>
                if not matched4:
                    all_ok5 = False
            matched = all_ok5
            # </Sequence>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_b(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_c(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        # </Choice>
        state.rule_stack.pop()
        if state.tag_stack:
            tag6: str | None = state.tag_stack.pop()
        else:
            tag6 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag6,))
        return matched
    
    return inner
    
parse_choices_a_progress = _parse_choices_a_progress()

def _parse_choices_b_progress() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame('choices_b_progress', 0)
    
    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse choices_b_progress."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Choice>
        children3: list[Pair] = []
        matched = False
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_a(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Sequence n=2>
            all_ok5 = True
            if all_ok5:
                matched4 = False
                # <Identifier>
                matched4 = parse_b(state, children3)
                # </Identifier>
                if not matched4:
                    all_ok5 = False
                if all_ok5:
                    parse_trivia(state, children3)
            if all_ok5:
                matched4 = False
                # <Identifier>
                matched4 = parse_b(state, children3)
                # </Identifier>
                if not matched4:
                    all_ok5 = False
            matched = all_ok5
            # </Sequence>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_c(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        # </Choice>
        state.rule_stack.pop()
        if state.tag_stack:
            tag6: str | None = state.tag_stack.pop()
        else:
            tag6 = None
        if matched:
            pairs.append(Pair(state.input, pos1, state.pos, rule_frame, children2, tag6,))
        return matched
    
    return inner
    
parse_choices_b_progress = _parse_choices_b_progress()

def _parse_level1() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame('level1', 2)
    
    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse level1."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Identifier>
        matched = parse_level2(state, children2)
        # </Identifier>
        state.rule_stack.pop()
        # Silent rule 'level1'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_level1 = _parse_level1()

def _parse_level2() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame('level2', 2)
    
    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse level2."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Choice>
        children3: list[Pair] = []
        matched = False
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_a(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_b(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_c(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        # </Choice>
        state.rule_stack.pop()
        # Silent rule 'level2'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_level2 = _parse_level2()

def _parse_negative() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame('negative', 2)
    
    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse negative."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <NegativePredicate>
        children3: list[Pair] = []
        state.checkpoint()
        state.neg_pred_depth += 1
        # <Identifier>
        matched = parse_d(state, children3)
        # </Identifier>
        if not matched:
            state.restore()
            children3.clear()  # discard lookahead children
            matched = True
        else:
            state.restore()
            matched = False
        state.neg_pred_depth -= 1
        # </NegativePredicate>
        state.rule_stack.pop()
        # Silent rule 'negative'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_negative = _parse_negative()

def _parse_negative_match() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame('negative_match', 2)
    
    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse negative_match."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=2>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            # <NegativePredicate>
            children5: list[Pair] = []
            state.checkpoint()
            state.neg_pred_depth += 1
            # <Identifier>
            matched3 = parse_a(state, children5)
            # </Identifier>
            if not matched3:
                state.restore()
                children5.clear()  # discard lookahead children
                matched3 = True
            else:
                state.restore()
                matched3 = False
            state.neg_pred_depth -= 1
            # </NegativePredicate>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Identifier>
            matched3 = parse_b(state, children2)
            # </Identifier>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        # Silent rule 'negative_match'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_negative_match = _parse_negative_match()

def _parse_mixed() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame('mixed', 2)
    
    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse mixed."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Choice>
        children3: list[Pair] = []
        matched = False
        if not matched:
            state.checkpoint()
            # <NegativePredicate>
            children4: list[Pair] = []
            state.checkpoint()
            state.neg_pred_depth += 1
            # <Identifier>
            matched = parse_d(state, children4)
            # </Identifier>
            if not matched:
                state.restore()
                children4.clear()  # discard lookahead children
                matched = True
            else:
                state.restore()
                matched = False
            state.neg_pred_depth -= 1
            # </NegativePredicate>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        if not matched:
            state.checkpoint()
            # <Identifier>
            matched = parse_a(state, children3)
            # </Identifier>
            if matched:
                state.ok()
                children2.extend(children3)
            else:
                state.restore()
                children3.clear()
        # </Choice>
        state.rule_stack.pop()
        # Silent rule 'mixed'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_mixed = _parse_mixed()

def _parse_mixed_progress() -> Callable[[State, list[Pair]], bool]:
    rule_frame = RuleFrame('mixed_progress', 2)
    
    def inner(state: State, pairs: list[Pair]) -> bool:
        """Parse mixed_progress."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=2>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            # <Group>
            # <Choice>
            children5: list[Pair] = []
            matched3 = False
            if not matched3:
                state.checkpoint()
                # <NegativePredicate>
                children6: list[Pair] = []
                state.checkpoint()
                state.neg_pred_depth += 1
                # <Identifier>
                matched3 = parse_d(state, children6)
                # </Identifier>
                if not matched3:
                    state.restore()
                    children6.clear()  # discard lookahead children
                    matched3 = True
                else:
                    state.restore()
                    matched3 = False
                state.neg_pred_depth -= 1
                # </NegativePredicate>
                if matched3:
                    state.ok()
                    children2.extend(children5)
                else:
                    state.restore()
                    children5.clear()
            if not matched3:
                state.checkpoint()
                # <Identifier>
                matched3 = parse_a(state, children5)
                # </Identifier>
                if matched3:
                    state.ok()
                    children2.extend(children5)
                else:
                    state.restore()
                    children5.clear()
            if not matched3:
                state.checkpoint()
                # <Identifier>
                matched3 = parse_b(state, children5)
                # </Identifier>
                if matched3:
                    state.ok()
                    children2.extend(children5)
                else:
                    state.restore()
                    children5.clear()
            # </Choice>
            # </Group>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Identifier>
            matched3 = parse_a(state, children2)
            # </Identifier>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        # Silent rule 'mixed_progress'
        pairs.extend(children2)
        return matched
    
    return inner
    
parse_mixed_progress = _parse_mixed_progress()

def parse_trivia(state: State, pairs: list[Pair]) -> bool:
    return True

_RULE_MAP: dict[str, Callable[[State, list[Pair]], bool]] = {
    'EOI': parse_EOI,
    'a': parse_a,
    'b': parse_b,
    'c': parse_c,
    'd': parse_d,
    'choices': parse_choices,
    'choices_no_progress': parse_choices_no_progress,
    'choices_a_progress': parse_choices_a_progress,
    'choices_b_progress': parse_choices_b_progress,
    'level1': parse_level1,
    'level2': parse_level2,
    'negative': parse_negative,
    'negative_match': parse_negative_match,
    'mixed': parse_mixed,
    'mixed_progress': parse_mixed_progress,
}

def parse(start_rule: str, input_: str, *, start_pos: int = 0) -> Pairs:
    """Parse `input_` starting from `rule`."""
    state = State(input_, start_pos)
    pairs: list[Pair] = []
    matched = _RULE_MAP[start_rule](state, pairs)
    if matched:
        return Pairs(pairs)
    raise PestParsingError(state.furthest_stack, list(state.furthest_expected), [], state.furthest_pos, *error_context(state.input, state.furthest_pos),)