"""This file was generated by Python pest.

DO NOT EDIT THIS FILE BY HAND.
"""

from __future__ import annotations

from enum import StrEnum
from typing import TYPE_CHECKING

import regex as re

from pest.exceptions import PestParsingError
from pest.pairs import Pair
from pest.pairs import Pairs
from pest.state import ParserState
from pest.state import RuleFrame

if TYPE_CHECKING:
    from collections.abc import Callable

# ruff: noqa: D103 N802 N816 N806 PLR0912 PLR0915 PLR2004


class Rule(StrEnum):
    """Grammar rules."""

    EOI = "EOI"
    ARRAY = "array"
    INT_LIST = "int_list"
    INT = "int"
    WHITESPACE = "WHITESPACE"


def _parse_EOI() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame("EOI", 0)

    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse EOI."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        if state.pos != len(state.input):
            matched = False
        else:
            matched = True
        state.rule_stack.pop()
        if state.tag_stack:
            tag3: str | None = state.tag_stack.pop()
        else:
            tag3 = None
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    children2,
                    tag3,
                )
            )
        return matched

    return inner


parse_EOI = _parse_EOI()


def _parse_array() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame("array", 0)

    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse array."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=3>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            # <String>
            if state.input.startswith("[", state.pos):
                state.pos += 1
                matched3 = True
            else:
                matched3 = False
                state.fail('"["')
            # </String>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Identifier>
            matched3 = parse_int_list(state, children2)
            # </Identifier>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <String>
            if state.input.startswith("]", state.pos):
                state.pos += 1
                matched3 = True
            else:
                matched3 = False
                state.fail('"]"')
            # </String>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag5: str | None = state.tag_stack.pop()
        else:
            tag5 = None
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    children2,
                    tag5,
                )
            )
        return matched

    return inner


parse_array = _parse_array()


def _parse_int_list() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame("int_list", 0)

    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse int_list."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        # <Sequence n=2>
        all_ok4 = True
        if all_ok4:
            matched3 = False
            # <Identifier>
            matched3 = parse_int(state, children2)
            # </Identifier>
            if not matched3:
                all_ok4 = False
            if all_ok4:
                parse_trivia(state, children2)
        if all_ok4:
            matched3 = False
            # <Repeat>
            trivia_pos6 = state.pos
            children5: list[Pair] = []
            while True:
                state.checkpoint()
                # <Group>
                # <Sequence n=2>
                all_ok8 = True
                if all_ok8:
                    matched7 = False
                    # <String>
                    if state.input.startswith(",", state.pos):
                        state.pos += 1
                        matched7 = True
                    else:
                        matched7 = False
                        state.fail('","')
                    # </String>
                    if not matched7:
                        all_ok8 = False
                    if all_ok8:
                        parse_trivia(state, children5)
                if all_ok8:
                    matched7 = False
                    # <Identifier>
                    matched7 = parse_int(state, children5)
                    # </Identifier>
                    if not matched7:
                        all_ok8 = False
                matched3 = all_ok8
                # </Sequence>
                # </Group>
                if matched3:
                    state.ok()
                    children2.extend(children5)
                    children5.clear()
                    trivia_pos6 = state.pos
                    parse_trivia(state, children5)
                else:
                    state.restore()
                    state.pos = trivia_pos6
                    matched3 = True
                    break
            # </Repeat>
            if not matched3:
                all_ok4 = False
        matched = all_ok4
        # </Sequence>
        state.rule_stack.pop()
        if state.tag_stack:
            tag9: str | None = state.tag_stack.pop()
        else:
            tag9 = None
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    children2,
                    tag9,
                )
            )
        return matched

    return inner


parse_int_list = _parse_int_list()


def _parse_int() -> Callable[[ParserState, list[Pair]], bool]:
    RE6 = re.compile("[1-9]", re.I)
    RE9 = re.compile("[0-9]", re.I)

    rule_frame = RuleFrame("int", 4)

    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse int."""
        pos1 = state.pos
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        with state.atomic_checkpoint():
            state.atomic_depth += 1
            # <Choice>
            children3: list[Pair] = []
            matched = False
            if not matched:
                state.checkpoint()
                # <String>
                if state.input.startswith("0", state.pos):
                    state.pos += 1
                    matched = True
                else:
                    matched = False
                    state.fail('"0"')
                # </String>
                if matched:
                    state.ok()
                    children2.extend(children3)
                else:
                    state.restore()
                    children3.clear()
            if not matched:
                state.checkpoint()
                # <Sequence n=2>
                all_ok5 = True
                if all_ok5:
                    matched4 = False
                    # <Range>
                    if match := RE6.match(state.input, state.pos):
                        state.pos = match.end()
                        matched4 = True
                    else:
                        matched4 = False
                        state.fail("''1''..''9''")
                    # </Range>
                    if not matched4:
                        all_ok5 = False
                    if all_ok5:
                        parse_trivia(state, children3)
                if all_ok5:
                    matched4 = False
                    # <Repeat>
                    trivia_pos8 = state.pos
                    children7: list[Pair] = []
                    while True:
                        state.checkpoint()
                        # <Range>
                        if match := RE9.match(state.input, state.pos):
                            state.pos = match.end()
                            matched4 = True
                        else:
                            matched4 = False
                            state.fail("''0''..''9''")
                        # </Range>
                        if matched4:
                            state.ok()
                            children3.extend(children7)
                            children7.clear()
                            trivia_pos8 = state.pos
                            parse_trivia(state, children7)
                        else:
                            state.restore()
                            state.pos = trivia_pos8
                            matched4 = True
                            break
                    # </Repeat>
                    if not matched4:
                        all_ok5 = False
                matched = all_ok5
                # </Sequence>
                if matched:
                    state.ok()
                    children2.extend(children3)
                else:
                    state.restore()
                    children3.clear()
            # </Choice>
        state.rule_stack.pop()
        if state.tag_stack:
            tag10: str | None = state.tag_stack.pop()
        else:
            tag10 = None
        # Atomic rule: 'int'
        if matched:
            pairs.append(
                Pair(
                    state.input,
                    pos1,
                    state.pos,
                    rule_frame,
                    [],
                    tag10,
                )
            )
        return matched

    return inner


parse_int = _parse_int()


def _parse_WHITESPACE() -> Callable[[ParserState, list[Pair]], bool]:
    rule_frame = RuleFrame("WHITESPACE", 2)

    def inner(state: ParserState, pairs: list[Pair]) -> bool:
        """Parse WHITESPACE."""
        state.rule_stack.push(rule_frame)
        children2: list[Pair] = []
        with state.atomic_checkpoint():
            state.atomic_depth += 1
            # <String>
            if state.input.startswith(" ", state.pos):
                state.pos += 1
                matched = True
            else:
                matched = False
                state.fail('" "')
            # </String>
        state.rule_stack.pop()
        # Silent rule 'WHITESPACE'
        pairs.extend(children2)
        return matched

    return inner


parse_WHITESPACE = _parse_WHITESPACE()


def parse_trivia(state: ParserState, pairs: list[Pair]) -> bool:
    if state.atomic_depth > 0:
        return True
    with state.suppress_failures():
        while True:
            state.checkpoint()
            matched = False
            matched = parse_WHITESPACE(state, pairs)
            if matched:
                state.ok()
                continue
            else:
                state.restore()
            if not matched:
                break
    return True


_RULE_MAP: dict[str, Callable[[ParserState, list[Pair]], bool]] = {
    "EOI": parse_EOI,
    "array": parse_array,
    "int_list": parse_int_list,
    "int": parse_int,
    "WHITESPACE": parse_WHITESPACE,
}


def parse(start_rule: str, text: str, *, start_pos: int = 0) -> Pairs:
    """Parse `input_` starting from `rule`."""
    state = ParserState(text, start_pos)
    pairs: list[Pair] = []
    matched = _RULE_MAP[start_rule](state, pairs)
    if matched:
        return Pairs(pairs)
    raise PestParsingError(state)


class Parser:
    def parse(self, start_rule: str, input_: str, *, start_pos: int = 0) -> Pairs:
        return parse(start_rule, input_, start_pos=start_pos)


def main() -> None:
    parser = argparse.ArgumentParser(
        prog="parser",
        description="A parser generated by Python pest.",
    )

    parser.add_argument(
        "rule",
        metavar="RULE",
        help="The name of the rule to start parsing from.",
    )

    group = parser.add_mutually_exclusive_group(required=True)

    group.add_argument(
        "-i",
        "--input",
        metavar="INPUT",
        help="Input text to parse.",
    )

    group.add_argument(
        "-f",
        "--file",
        metavar="FILE",
        type=argparse.FileType("r"),
        help="Path to a file containing text to parse, or `-` to read from stdin.",
    )

    parser.add_argument(
        "--verbose",
        action="store_true",
        help="Display verbose output",
    )

    args = parser.parse_args()
    text = args.input or args.file.read()

    print(  # noqa: T201
        parse(args.rule, text).dumps(compact=not args.verbose)
    )


if __name__ == "__main__":
    import argparse

    main()
