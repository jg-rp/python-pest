import re
from collections.abc import Iterable
from typing import Self


class LazyRegexExpression:
    """A lazily-compiled regex expression with positive/negative strings
    and optimized character sets from ranges + single-char literals.
    """

    __slots__ = ("_pos_ranges", "_multi_pos", "_neg_ranges", "_neg_multi", "_compiled")

    def __init__(self) -> None:
        # positives
        self._pos_ranges: list[tuple[str, str]] = []  # [("a","z"), ...]
        self._multi_pos: list[str] = []  # multi-char literals

        # negatives
        self._neg_ranges: list[tuple[str, str]] = []  # [("0","9"), ("\n","\n"), ...]
        self._neg_multi: list[str] = []  # multi-char literals (foo, bar)

        self._compiled: re.Pattern[str] | None = None

    # -----------------------------
    # Builders
    # -----------------------------

    def with_positive(self, s: str) -> Self:
        if self._compiled:
            new = self._copy()
            return new.with_positive(s)

        if len(s) == 1:
            self._pos_ranges.append((s, s))
        else:
            self._multi_pos.append(s)
        return self

    def with_negative(self, s: str) -> Self:
        if self._compiled:
            new = self._copy()
            return new.with_negative(s)

        if len(s) == 1:
            self._neg_ranges.append((s, s))
        else:
            self._neg_multi.append(s)
        return self

    def with_range(self, start: str, end: str) -> Self:
        if self._compiled:
            new = self._copy()
            return new.with_range(start, end)

        self._pos_ranges.append((start, end))
        return self

    def with_negative_range(self, start: str, end: str) -> Self:
        if self._compiled:
            new = self._copy()
            return new.with_negative_range(start, end)

        self._neg_ranges.append((start, end))
        return self

    # -----------------------------
    # Regex compilation
    # -----------------------------

    @property
    def regex(self) -> re.Pattern[str]:
        if self._compiled is None:
            self._compiled = re.compile(self._build_pattern())
        return self._compiled

    def _build_pattern(self) -> str:
        # positive charset
        charset = ""
        if self._pos_ranges:
            charset = self._merge_ranges(self._pos_ranges)

        parts: list[str] = []
        if charset:
            parts.append(f"[{charset}]")
        if self._multi_pos:
            parts.extend(re.escape(s) for s in self._multi_pos)

        body = "|".join(parts) if parts else "."

        # handle negative ranges/charsets
        neg_charset = ""
        if self._neg_ranges:
            neg_charset = self._merge_ranges(self._neg_ranges)

        if neg_charset:
            # If we already had a positive charset, subtract with [^...]
            # If not, fallback to dot + negative class
            if parts and charset:
                body = f"[{charset}&&[^{neg_charset}]]"  # intersection
            else:
                body = f"[^{neg_charset}]"

        # negative multi-char literals â†’ lookaheads
        lookaheads = "".join(f"(?!{re.escape(s)})" for s in self._neg_multi)

        return f"{lookaheads}(?:{body})"

    # -----------------------------
    # Range normalization
    # -----------------------------

    @staticmethod
    def _merge_ranges(ranges: Iterable[tuple[str, str]]) -> str:
        intervals = [(ord(a), ord(b)) for a, b in ranges]
        intervals.sort()

        merged: list[tuple[int, int]] = []
        for start, end in intervals:
            if not merged or start > merged[-1][1] + 1:
                merged.append((start, end))
            else:
                merged[-1] = (merged[-1][0], max(merged[-1][1], end))

        return "".join(
            f"{re.escape(chr(a))}-{re.escape(chr(b))}" if a != b else re.escape(chr(a))
            for a, b in merged
        )

    # -----------------------------
    # Utils
    # -----------------------------

    def _copy(self) -> Self:
        new = LazyRegexExpression()
        new._pos_ranges = self._pos_ranges[:]
        new._multi_pos = self._multi_pos[:]
        new._neg_ranges = self._neg_ranges[:]
        new._neg_multi = self._neg_multi[:]
        return new

    def __str__(self) -> str:
        return self._build_pattern()


import regex
from typing import Sequence


class LazyRegexExpression:
    """A lazily compiled regex with support for positives and negatives.

    Supports:
      - Union of positive ranges/patterns.
      - Subtraction/intersection of negative ranges/patterns.
      - Automatic merging of ranges into compact character sets.
    """

    __slots__ = ("positives", "negatives", "_compiled")

    def __init__(
        self,
        positives: Sequence[str] | None = None,
        negatives: Sequence[str] | None = None,
    ) -> None:
        self.positives: list[str] = list(positives or [])
        self.negatives: list[str] = list(negatives or [])
        self._compiled: regex.Pattern | None = None

    # -------------------------------
    # Building blocks
    # -------------------------------

    def with_positive(self, pattern: str) -> "LazyRegexExpression":
        if self._compiled:
            # frozen, return new
            return LazyRegexExpression(self.positives + [pattern], self.negatives)
        self.positives.append(pattern)
        return self

    def with_negative(self, pattern: str) -> "LazyRegexExpression":
        if self._compiled:
            return LazyRegexExpression(self.positives, self.negatives + [pattern])
        self.negatives.append(pattern)
        return self

    # -------------------------------
    # Regex construction
    # -------------------------------

    def _merge_to_charset(self, patterns: list[str]) -> str | None:
        """If all patterns are single-char literals or ranges, merge into one charset.
        Otherwise return None.
        """
        parts: list[str] = []
        for p in patterns:
            # match simple literal or range like 'a-z'
            if regex.fullmatch(r"[A-Za-z0-9]-[A-Za-z0-9]", p) or len(p) == 1:
                parts.append(p)
            else:
                return None
        return "".join(parts)

    def _build_pattern(self) -> str:
        pos_charset = self._merge_to_charset(self.positives)
        neg_charset = self._merge_to_charset(self.negatives)

        # Case 1: positives only
        if self.positives and not self.negatives:
            if pos_charset is not None:
                return f"[{pos_charset}]"
            return "(?:" + "|".join(self.positives) + ")"

        # Case 2: negatives only
        if self.negatives and not self.positives:
            if neg_charset is not None:
                return f"[^{neg_charset}]"
            # fallback: negative lookahead
            return "(?:(?! (?:" + "|".join(self.negatives) + ")).)"

        # Case 3: both positives and negatives
        if pos_charset is not None and neg_charset is not None:
            # regex supports subtraction: [pos--[neg]]
            return f"[{pos_charset}--[{neg_charset}]]"

        # fallback: use intersection syntax
        if pos_charset is not None:
            pos = f"[{pos_charset}]"
        else:
            pos = "(?:" + "|".join(self.positives) + ")"

        if neg_charset is not None:
            neg = f"[{neg_charset}]"
        else:
            neg = "(?:" + "|".join(self.negatives) + ")"

        # regex extended syntax: intersection
        return f"{pos}&&[^{neg}]"

    # -------------------------------
    # Public API
    # -------------------------------

    @property
    def pattern(self) -> regex.Pattern:
        if self._compiled is None:
            pat = self._build_pattern()
            self._compiled = regex.compile(pat)
        return self._compiled

    def __str__(self) -> str:
        return self.pattern.pattern
